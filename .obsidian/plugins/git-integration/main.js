/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self = debug2;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self, args);
          const logFn = self.log || createDebug.log;
          logFn.apply(self, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug.useColors();
        debug2.color = createDebug.selectColor(namespace);
        debug2.extend = extend;
        debug2.destroy = createDebug.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug2);
        }
        return debug2;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module2) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/@kwsites/file-exists/dist/src/index.js
var require_src = __commonJS({
  "node_modules/@kwsites/file-exists/dist/src/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var fs_1 = require("fs");
    var debug_1 = __importDefault(require_browser());
    var log = debug_1.default("@kwsites/file-exists");
    function check(path2, isFile, isDirectory) {
      log(`checking %s`, path2);
      try {
        const stat = fs_1.statSync(path2);
        if (stat.isFile() && isFile) {
          log(`[OK] path represents a file`);
          return true;
        }
        if (stat.isDirectory() && isDirectory) {
          log(`[OK] path represents a directory`);
          return true;
        }
        log(`[FAIL] path represents something other than a file or directory`);
        return false;
      } catch (e) {
        if (e.code === "ENOENT") {
          log(`[FAIL] path is not accessible: %o`, e);
          return false;
        }
        log(`[FATAL] %o`, e);
        throw e;
      }
    }
    function exists2(path2, type = exports.READABLE) {
      return check(path2, (type & exports.FILE) > 0, (type & exports.FOLDER) > 0);
    }
    exports.exists = exists2;
    exports.FILE = 1;
    exports.FOLDER = 2;
    exports.READABLE = exports.FILE + exports.FOLDER;
  }
});

// node_modules/@kwsites/file-exists/dist/index.js
var require_dist = __commonJS({
  "node_modules/@kwsites/file-exists/dist/index.js"(exports) {
    "use strict";
    function __export3(m) {
      for (var p in m)
        if (!exports.hasOwnProperty(p))
          exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export3(require_src());
  }
});

// node_modules/@kwsites/promise-deferred/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@kwsites/promise-deferred/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDeferred = exports.deferred = void 0;
    function deferred2() {
      let done;
      let fail;
      let status = "pending";
      const promise = new Promise((_done, _fail) => {
        done = _done;
        fail = _fail;
      });
      return {
        promise,
        done(result) {
          if (status === "pending") {
            status = "resolved";
            done(result);
          }
        },
        fail(error) {
          if (status === "pending") {
            status = "rejected";
            fail(error);
          }
        },
        get fulfilled() {
          return status !== "pending";
        },
        get status() {
          return status;
        }
      };
    }
    exports.deferred = deferred2;
    exports.createDeferred = deferred2;
    exports.default = deferred2;
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => GitPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian9 = require("obsidian");

// src/components/git-commit.modal.ts
var import_obsidian = require("obsidian");
var GitCommitModal = class extends import_obsidian.Modal {
  constructor(app, onCompleteCallback) {
    super(app);
    this.commit = false;
    this.sync = false;
    this.onCompleteCallback = onCompleteCallback;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h1", { text: "Git commit" });
    new import_obsidian.Setting(contentEl).setName("Commit message").addTextArea((comp) => {
      comp.setPlaceholder("Enter commit message...");
      comp.onChange((value) => this.msg = value);
    }).setClass("modal-setting-item-w-text-area");
    const buttons = new import_obsidian.Setting(contentEl).addButton(
      (btn) => btn.setButtonText("Cancel").onClick(() => {
        this.close();
      })
    ).addButton(
      (btn) => btn.setButtonText("Commit").setClass("bg-theme").onClick(() => {
        if (this.msg && this.msg.trim().length > 0) {
          this.commit = true;
          this.close();
        }
      })
    );
    const checkboxContainer = contentEl.createDiv({
      cls: "checkbox-container-w-text"
    });
    const checkbox = contentEl.createEl("input", {
      type: "checkbox",
      attr: {
        id: "sync-checkbox"
      }
    });
    checkbox.addEventListener("change", () => {
      this.sync = checkbox.checked;
    });
    const checkboxText = contentEl.createEl("label", {
      text: "Automatically push to remote repository",
      cls: "font-small",
      attr: {
        for: "sync-checkbox"
      }
    });
    checkboxContainer.appendChild(checkbox);
    checkboxContainer.appendChild(checkboxText);
    buttons.controlEl.insertAdjacentElement("afterbegin", checkboxContainer);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    if (this.commit) {
      this.onCompleteCallback(this.msg, this.sync);
    }
  }
};

// src/components/git-init.modal.ts
var import_obsidian2 = require("obsidian");
var GitInitRemote = class extends import_obsidian2.Modal {
  constructor(app, onCompleteCallback) {
    super(app);
    this.addRemote = false;
    this.onCompleteCallback = onCompleteCallback;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h1", { text: "Git init remote" });
    new import_obsidian2.Setting(contentEl).setName("Remote repository url").addText(
      (text) => text.setPlaceholder("Enter repository url...").onChange((value) => this.repo = value)
    );
    new import_obsidian2.Setting(contentEl).addButton(
      (btn) => btn.setButtonText("Initialize").setClass("bg-theme").onClick(() => {
        if (this.repo) {
          this.addRemote = true;
          this.close();
        }
      })
    );
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    if (this.addRemote) {
      this.onCompleteCallback(this.repo);
    }
  }
};

// src/components/git-menu.modal.ts
var import_obsidian3 = require("obsidian");
var GitMenuModal = class extends import_obsidian3.Modal {
  constructor(app, gitInitModal, gitCommitModal, gitSyncModal) {
    super(app);
    this.gitInitModal = gitInitModal;
    this.gitCommitModal = gitCommitModal;
    this.gitSyncModal = gitSyncModal;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h1", { text: "Git menu" });
    if (this.gitInitModal !== null) {
      new import_obsidian3.Setting(contentEl).setClass("setting-item-without-info").addButton((button) => {
        button.setButtonText("Git init");
        button.setClass("w-100").setClass("font-medium");
        button.onClick(() => {
          this.gitInitModal.open();
          this.close();
        });
      });
    }
    new import_obsidian3.Setting(contentEl).setClass("setting-item-without-info").addButton((button) => {
      button.setButtonText("Git commit");
      button.setClass("w-100").setClass("font-medium");
      button.onClick(() => {
        this.gitCommitModal.open();
        this.close();
      });
    }).addButton((button) => {
      button.setButtonText("Git sync");
      button.setClass("w-100").setClass("font-medium");
      button.onClick(() => {
        this.gitSyncModal.open();
        this.close();
      });
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/components/git-sync.modal.ts
var import_obsidian4 = require("obsidian");
var GitSyncModal = class extends import_obsidian4.Modal {
  constructor(app, onCompleteCallback) {
    super(app);
    this.onCompleteCallback = onCompleteCallback;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h1", { text: "Git sync?" });
    contentEl.createEl("span", {
      text: "This will sync with the remote branch."
    });
    new import_obsidian4.Setting(contentEl).setHeading().addButton(
      (btn) => btn.setButtonText("Cancel").onClick(() => {
        this.close();
      })
    ).addButton((btn) => {
      btn.setButtonText("Sync").setClass("bg-theme").onClick(() => {
        this.onCompleteCallback();
        this.close();
      });
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/config/config.ts
var DEFAULT_SETTINGS = {
  gitRemote: null
};
var IS_DEBUG_MODE = true;

// src/debug/debug.modal.ts
var import_obsidian5 = require("obsidian");
var DebugModal = class extends import_obsidian5.Modal {
  constructor(app, contents) {
    super(app);
    this.heading = "Git Integration Plugin debug message:";
    this.contents = contents;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h1", {
      text: this.heading
    });
    contentEl.createEl("span", { text: this.contents });
  }
};

// src/debug/delete-git-folder.modal.ts
var import_obsidian6 = require("obsidian");
var DeleteGitFolderModal = class extends import_obsidian6.Modal {
  constructor(app, onCompleteCallback) {
    super(app);
    this.onCompleteCallback = onCompleteCallback;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h1", {
      text: "Are you sure to delete .git folder?"
    });
    new import_obsidian6.Setting(contentEl).setClass("setting-item-without-info").addButton(
      (btn) => btn.setButtonText("Cancel").onClick(() => {
        this.close();
      })
    ).addButton((btn) => {
      btn.setButtonText("Delete").setClass("bg-theme").onClick(() => {
        this.onCompleteCallback();
        this.close();
      });
    });
  }
};

// src/debug/error.modal.ts
var ErrorModal = class extends DebugModal {
  constructor(app, contents) {
    super(app, contents);
    this.heading = "Git Integration Plugin ran into an error:";
  }
};

// src/debug/utils/delete-folder.ts
var fs = __toESM(require("fs"));
var path = __toESM(require("path"));
var deleteFolder = (folderPath) => {
  fs.rm(folderPath, { recursive: true, force: true }, () => {
  });
};
var deleteGitFolder = (folderPath) => {
  deleteFolder(path.resolve(folderPath, ".git"));
};

// src/debug/utils/open-folder.ts
var childProcess = __toESM(require("child_process"));
var openFolder = (path2) => {
  childProcess.exec(`start "" "${path2}"`);
};

// node_modules/simple-git/dist/esm/index.js
var import_file_exists = __toESM(require_dist(), 1);
var import_debug2 = __toESM(require_browser(), 1);
var import_child_process = require("child_process");
var import_promise_deferred = __toESM(require_dist2(), 1);
var import_promise_deferred2 = __toESM(require_dist2(), 1);
var __defProp2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp2.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp2(target, "__esModule", { value: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames2(fn)[0]])(fn = 0)), res;
};
var __commonJS2 = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export2 = (target, all) => {
  for (var name in all)
    __defProp2(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames2(module2))
      if (!__hasOwnProp2.call(target, key) && (copyDefault || key !== "default"))
        __defProp2(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc2(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toCommonJS2 = /* @__PURE__ */ ((cache2) => {
  return (module2, temp) => {
    return cache2 && cache2.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache2 && cache2.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve2, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve2(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function pathspec(...paths) {
  const key = new String(paths);
  cache.set(key, paths);
  return key;
}
function isPathSpec(path2) {
  return path2 instanceof String && cache.has(path2);
}
function toPaths(pathSpec) {
  return cache.get(pathSpec) || [];
}
var cache;
var init_pathspec = __esm({
  "src/lib/args/pathspec.ts"() {
    cache = /* @__PURE__ */ new WeakMap();
  }
});
var GitError;
var init_git_error = __esm({
  "src/lib/errors/git-error.ts"() {
    GitError = class extends Error {
      constructor(task, message) {
        super(message);
        this.task = task;
        Object.setPrototypeOf(this, new.target.prototype);
      }
    };
  }
});
var GitResponseError;
var init_git_response_error = __esm({
  "src/lib/errors/git-response-error.ts"() {
    init_git_error();
    GitResponseError = class extends GitError {
      constructor(git, message) {
        super(void 0, message || String(git));
        this.git = git;
      }
    };
  }
});
var TaskConfigurationError;
var init_task_configuration_error = __esm({
  "src/lib/errors/task-configuration-error.ts"() {
    init_git_error();
    TaskConfigurationError = class extends GitError {
      constructor(message) {
        super(void 0, message);
      }
    };
  }
});
function asFunction(source) {
  return typeof source === "function" ? source : NOOP;
}
function isUserFunction(source) {
  return typeof source === "function" && source !== NOOP;
}
function splitOn(input, char) {
  const index = input.indexOf(char);
  if (index <= 0) {
    return [input, ""];
  }
  return [input.substr(0, index), input.substr(index + 1)];
}
function first(input, offset = 0) {
  return isArrayLike(input) && input.length > offset ? input[offset] : void 0;
}
function last(input, offset = 0) {
  if (isArrayLike(input) && input.length > offset) {
    return input[input.length - 1 - offset];
  }
}
function isArrayLike(input) {
  return !!(input && typeof input.length === "number");
}
function toLinesWithContent(input = "", trimmed2 = true, separator = "\n") {
  return input.split(separator).reduce((output, line) => {
    const lineContent = trimmed2 ? line.trim() : line;
    if (lineContent) {
      output.push(lineContent);
    }
    return output;
  }, []);
}
function forEachLineWithContent(input, callback) {
  return toLinesWithContent(input, true).map((line) => callback(line));
}
function folderExists(path2) {
  return (0, import_file_exists.exists)(path2, import_file_exists.FOLDER);
}
function append(target, item) {
  if (Array.isArray(target)) {
    if (!target.includes(item)) {
      target.push(item);
    }
  } else {
    target.add(item);
  }
  return item;
}
function including(target, item) {
  if (Array.isArray(target) && !target.includes(item)) {
    target.push(item);
  }
  return target;
}
function remove(target, item) {
  if (Array.isArray(target)) {
    const index = target.indexOf(item);
    if (index >= 0) {
      target.splice(index, 1);
    }
  } else {
    target.delete(item);
  }
  return item;
}
function asArray(source) {
  return Array.isArray(source) ? source : [source];
}
function asStringArray(source) {
  return asArray(source).map(String);
}
function asNumber(source, onNaN = 0) {
  if (source == null) {
    return onNaN;
  }
  const num = parseInt(source, 10);
  return isNaN(num) ? onNaN : num;
}
function prefixedArray(input, prefix) {
  const output = [];
  for (let i = 0, max = input.length; i < max; i++) {
    output.push(prefix, input[i]);
  }
  return output;
}
function bufferToString(input) {
  return (Array.isArray(input) ? Buffer.concat(input) : input).toString("utf-8");
}
function pick(source, properties) {
  return Object.assign({}, ...properties.map((property) => property in source ? { [property]: source[property] } : {}));
}
function delay(duration = 0) {
  return new Promise((done) => setTimeout(done, duration));
}
function orVoid(input) {
  if (input === false) {
    return void 0;
  }
  return input;
}
var NULL;
var NOOP;
var objectToString;
var init_util = __esm({
  "src/lib/utils/util.ts"() {
    NULL = "\0";
    NOOP = () => {
    };
    objectToString = Object.prototype.toString.call.bind(Object.prototype.toString);
  }
});
function filterType(input, filter, def) {
  if (filter(input)) {
    return input;
  }
  return arguments.length > 2 ? def : void 0;
}
function filterPrimitives(input, omit) {
  const type = isPathSpec(input) ? "string" : typeof input;
  return /number|string|boolean/.test(type) && (!omit || !omit.includes(type));
}
function filterPlainObject(input) {
  return !!input && objectToString(input) === "[object Object]";
}
function filterFunction(input) {
  return typeof input === "function";
}
var filterArray;
var filterString;
var filterStringArray;
var filterStringOrStringArray;
var filterHasLength;
var init_argument_filters = __esm({
  "src/lib/utils/argument-filters.ts"() {
    init_util();
    init_pathspec();
    filterArray = (input) => {
      return Array.isArray(input);
    };
    filterString = (input) => {
      return typeof input === "string";
    };
    filterStringArray = (input) => {
      return Array.isArray(input) && input.every(filterString);
    };
    filterStringOrStringArray = (input) => {
      return filterString(input) || Array.isArray(input) && input.every(filterString);
    };
    filterHasLength = (input) => {
      if (input == null || "number|boolean|function".includes(typeof input)) {
        return false;
      }
      return Array.isArray(input) || typeof input === "string" || typeof input.length === "number";
    };
  }
});
var ExitCodes;
var init_exit_codes = __esm({
  "src/lib/utils/exit-codes.ts"() {
    ExitCodes = /* @__PURE__ */ ((ExitCodes2) => {
      ExitCodes2[ExitCodes2["SUCCESS"] = 0] = "SUCCESS";
      ExitCodes2[ExitCodes2["ERROR"] = 1] = "ERROR";
      ExitCodes2[ExitCodes2["NOT_FOUND"] = -2] = "NOT_FOUND";
      ExitCodes2[ExitCodes2["UNCLEAN"] = 128] = "UNCLEAN";
      return ExitCodes2;
    })(ExitCodes || {});
  }
});
var GitOutputStreams;
var init_git_output_streams = __esm({
  "src/lib/utils/git-output-streams.ts"() {
    GitOutputStreams = class {
      constructor(stdOut, stdErr) {
        this.stdOut = stdOut;
        this.stdErr = stdErr;
      }
      asStrings() {
        return new GitOutputStreams(this.stdOut.toString("utf8"), this.stdErr.toString("utf8"));
      }
    };
  }
});
var LineParser;
var RemoteLineParser;
var init_line_parser = __esm({
  "src/lib/utils/line-parser.ts"() {
    LineParser = class {
      constructor(regExp, useMatches) {
        this.matches = [];
        this.parse = (line, target) => {
          this.resetMatches();
          if (!this._regExp.every((reg, index) => this.addMatch(reg, index, line(index)))) {
            return false;
          }
          return this.useMatches(target, this.prepareMatches()) !== false;
        };
        this._regExp = Array.isArray(regExp) ? regExp : [regExp];
        if (useMatches) {
          this.useMatches = useMatches;
        }
      }
      useMatches(target, match) {
        throw new Error(`LineParser:useMatches not implemented`);
      }
      resetMatches() {
        this.matches.length = 0;
      }
      prepareMatches() {
        return this.matches;
      }
      addMatch(reg, index, line) {
        const matched = line && reg.exec(line);
        if (matched) {
          this.pushMatch(index, matched);
        }
        return !!matched;
      }
      pushMatch(_index, matched) {
        this.matches.push(...matched.slice(1));
      }
    };
    RemoteLineParser = class extends LineParser {
      addMatch(reg, index, line) {
        return /^remote:\s/.test(String(line)) && super.addMatch(reg, index, line);
      }
      pushMatch(index, matched) {
        if (index > 0 || matched.length > 1) {
          super.pushMatch(index, matched);
        }
      }
    };
  }
});
function createInstanceConfig(...options) {
  const baseDir = process.cwd();
  const config = Object.assign(__spreadValues({ baseDir }, defaultOptions), ...options.filter((o) => typeof o === "object" && o));
  config.baseDir = config.baseDir || baseDir;
  config.trimmed = config.trimmed === true;
  return config;
}
var defaultOptions;
var init_simple_git_options = __esm({
  "src/lib/utils/simple-git-options.ts"() {
    defaultOptions = {
      binary: "git",
      maxConcurrentProcesses: 5,
      config: [],
      trimmed: false
    };
  }
});
function appendTaskOptions(options, commands = []) {
  if (!filterPlainObject(options)) {
    return commands;
  }
  return Object.keys(options).reduce((commands2, key) => {
    const value = options[key];
    if (isPathSpec(value)) {
      commands2.push(value);
    } else if (filterPrimitives(value, ["boolean"])) {
      commands2.push(key + "=" + value);
    } else {
      commands2.push(key);
    }
    return commands2;
  }, commands);
}
function getTrailingOptions(args, initialPrimitive = 0, objectOnly = false) {
  const command = [];
  for (let i = 0, max = initialPrimitive < 0 ? args.length : initialPrimitive; i < max; i++) {
    if ("string|number".includes(typeof args[i])) {
      command.push(String(args[i]));
    }
  }
  appendTaskOptions(trailingOptionsArgument(args), command);
  if (!objectOnly) {
    command.push(...trailingArrayArgument(args));
  }
  return command;
}
function trailingArrayArgument(args) {
  const hasTrailingCallback = typeof last(args) === "function";
  return filterType(last(args, hasTrailingCallback ? 1 : 0), filterArray, []);
}
function trailingOptionsArgument(args) {
  const hasTrailingCallback = filterFunction(last(args));
  return filterType(last(args, hasTrailingCallback ? 1 : 0), filterPlainObject);
}
function trailingFunctionArgument(args, includeNoop = true) {
  const callback = asFunction(last(args));
  return includeNoop || isUserFunction(callback) ? callback : void 0;
}
var init_task_options = __esm({
  "src/lib/utils/task-options.ts"() {
    init_argument_filters();
    init_util();
    init_pathspec();
  }
});
function callTaskParser(parser3, streams) {
  return parser3(streams.stdOut, streams.stdErr);
}
function parseStringResponse(result, parsers12, texts, trim = true) {
  asArray(texts).forEach((text) => {
    for (let lines = toLinesWithContent(text, trim), i = 0, max = lines.length; i < max; i++) {
      const line = (offset = 0) => {
        if (i + offset >= max) {
          return;
        }
        return lines[i + offset];
      };
      parsers12.some(({ parse }) => parse(line, result));
    }
  });
  return result;
}
var init_task_parser = __esm({
  "src/lib/utils/task-parser.ts"() {
    init_util();
  }
});
var utils_exports = {};
__export2(utils_exports, {
  ExitCodes: () => ExitCodes,
  GitOutputStreams: () => GitOutputStreams,
  LineParser: () => LineParser,
  NOOP: () => NOOP,
  NULL: () => NULL,
  RemoteLineParser: () => RemoteLineParser,
  append: () => append,
  appendTaskOptions: () => appendTaskOptions,
  asArray: () => asArray,
  asFunction: () => asFunction,
  asNumber: () => asNumber,
  asStringArray: () => asStringArray,
  bufferToString: () => bufferToString,
  callTaskParser: () => callTaskParser,
  createInstanceConfig: () => createInstanceConfig,
  delay: () => delay,
  filterArray: () => filterArray,
  filterFunction: () => filterFunction,
  filterHasLength: () => filterHasLength,
  filterPlainObject: () => filterPlainObject,
  filterPrimitives: () => filterPrimitives,
  filterString: () => filterString,
  filterStringArray: () => filterStringArray,
  filterStringOrStringArray: () => filterStringOrStringArray,
  filterType: () => filterType,
  first: () => first,
  folderExists: () => folderExists,
  forEachLineWithContent: () => forEachLineWithContent,
  getTrailingOptions: () => getTrailingOptions,
  including: () => including,
  isUserFunction: () => isUserFunction,
  last: () => last,
  objectToString: () => objectToString,
  orVoid: () => orVoid,
  parseStringResponse: () => parseStringResponse,
  pick: () => pick,
  prefixedArray: () => prefixedArray,
  remove: () => remove,
  splitOn: () => splitOn,
  toLinesWithContent: () => toLinesWithContent,
  trailingFunctionArgument: () => trailingFunctionArgument,
  trailingOptionsArgument: () => trailingOptionsArgument
});
var init_utils = __esm({
  "src/lib/utils/index.ts"() {
    init_argument_filters();
    init_exit_codes();
    init_git_output_streams();
    init_line_parser();
    init_simple_git_options();
    init_task_options();
    init_task_parser();
    init_util();
  }
});
var check_is_repo_exports = {};
__export2(check_is_repo_exports, {
  CheckRepoActions: () => CheckRepoActions,
  checkIsBareRepoTask: () => checkIsBareRepoTask,
  checkIsRepoRootTask: () => checkIsRepoRootTask,
  checkIsRepoTask: () => checkIsRepoTask
});
function checkIsRepoTask(action) {
  switch (action) {
    case "bare":
      return checkIsBareRepoTask();
    case "root":
      return checkIsRepoRootTask();
  }
  const commands = ["rev-parse", "--is-inside-work-tree"];
  return {
    commands,
    format: "utf-8",
    onError,
    parser
  };
}
function checkIsRepoRootTask() {
  const commands = ["rev-parse", "--git-dir"];
  return {
    commands,
    format: "utf-8",
    onError,
    parser(path2) {
      return /^\.(git)?$/.test(path2.trim());
    }
  };
}
function checkIsBareRepoTask() {
  const commands = ["rev-parse", "--is-bare-repository"];
  return {
    commands,
    format: "utf-8",
    onError,
    parser
  };
}
function isNotRepoMessage(error) {
  return /(Not a git repository|Kein Git-Repository)/i.test(String(error));
}
var CheckRepoActions;
var onError;
var parser;
var init_check_is_repo = __esm({
  "src/lib/tasks/check-is-repo.ts"() {
    init_utils();
    CheckRepoActions = /* @__PURE__ */ ((CheckRepoActions2) => {
      CheckRepoActions2["BARE"] = "bare";
      CheckRepoActions2["IN_TREE"] = "tree";
      CheckRepoActions2["IS_REPO_ROOT"] = "root";
      return CheckRepoActions2;
    })(CheckRepoActions || {});
    onError = ({ exitCode }, error, done, fail) => {
      if (exitCode === 128 && isNotRepoMessage(error)) {
        return done(Buffer.from("false"));
      }
      fail(error);
    };
    parser = (text) => {
      return text.trim() === "true";
    };
  }
});
function cleanSummaryParser(dryRun, text) {
  const summary = new CleanResponse(dryRun);
  const regexp = dryRun ? dryRunRemovalRegexp : removalRegexp;
  toLinesWithContent(text).forEach((line) => {
    const removed = line.replace(regexp, "");
    summary.paths.push(removed);
    (isFolderRegexp.test(removed) ? summary.folders : summary.files).push(removed);
  });
  return summary;
}
var CleanResponse;
var removalRegexp;
var dryRunRemovalRegexp;
var isFolderRegexp;
var init_CleanSummary = __esm({
  "src/lib/responses/CleanSummary.ts"() {
    init_utils();
    CleanResponse = class {
      constructor(dryRun) {
        this.dryRun = dryRun;
        this.paths = [];
        this.files = [];
        this.folders = [];
      }
    };
    removalRegexp = /^[a-z]+\s*/i;
    dryRunRemovalRegexp = /^[a-z]+\s+[a-z]+\s*/i;
    isFolderRegexp = /\/$/;
  }
});
var task_exports = {};
__export2(task_exports, {
  EMPTY_COMMANDS: () => EMPTY_COMMANDS,
  adhocExecTask: () => adhocExecTask,
  configurationErrorTask: () => configurationErrorTask,
  isBufferTask: () => isBufferTask,
  isEmptyTask: () => isEmptyTask,
  straightThroughBufferTask: () => straightThroughBufferTask,
  straightThroughStringTask: () => straightThroughStringTask
});
function adhocExecTask(parser3) {
  return {
    commands: EMPTY_COMMANDS,
    format: "empty",
    parser: parser3
  };
}
function configurationErrorTask(error) {
  return {
    commands: EMPTY_COMMANDS,
    format: "empty",
    parser() {
      throw typeof error === "string" ? new TaskConfigurationError(error) : error;
    }
  };
}
function straightThroughStringTask(commands, trimmed2 = false) {
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return trimmed2 ? String(text).trim() : text;
    }
  };
}
function straightThroughBufferTask(commands) {
  return {
    commands,
    format: "buffer",
    parser(buffer) {
      return buffer;
    }
  };
}
function isBufferTask(task) {
  return task.format === "buffer";
}
function isEmptyTask(task) {
  return task.format === "empty" || !task.commands.length;
}
var EMPTY_COMMANDS;
var init_task = __esm({
  "src/lib/tasks/task.ts"() {
    init_task_configuration_error();
    EMPTY_COMMANDS = [];
  }
});
var clean_exports = {};
__export2(clean_exports, {
  CONFIG_ERROR_INTERACTIVE_MODE: () => CONFIG_ERROR_INTERACTIVE_MODE,
  CONFIG_ERROR_MODE_REQUIRED: () => CONFIG_ERROR_MODE_REQUIRED,
  CONFIG_ERROR_UNKNOWN_OPTION: () => CONFIG_ERROR_UNKNOWN_OPTION,
  CleanOptions: () => CleanOptions,
  cleanTask: () => cleanTask,
  cleanWithOptionsTask: () => cleanWithOptionsTask,
  isCleanOptionsArray: () => isCleanOptionsArray
});
function cleanWithOptionsTask(mode, customArgs) {
  const { cleanMode, options, valid } = getCleanOptions(mode);
  if (!cleanMode) {
    return configurationErrorTask(CONFIG_ERROR_MODE_REQUIRED);
  }
  if (!valid.options) {
    return configurationErrorTask(CONFIG_ERROR_UNKNOWN_OPTION + JSON.stringify(mode));
  }
  options.push(...customArgs);
  if (options.some(isInteractiveMode)) {
    return configurationErrorTask(CONFIG_ERROR_INTERACTIVE_MODE);
  }
  return cleanTask(cleanMode, options);
}
function cleanTask(mode, customArgs) {
  const commands = ["clean", `-${mode}`, ...customArgs];
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return cleanSummaryParser(mode === "n", text);
    }
  };
}
function isCleanOptionsArray(input) {
  return Array.isArray(input) && input.every((test) => CleanOptionValues.has(test));
}
function getCleanOptions(input) {
  let cleanMode;
  let options = [];
  let valid = { cleanMode: false, options: true };
  input.replace(/[^a-z]i/g, "").split("").forEach((char) => {
    if (isCleanMode(char)) {
      cleanMode = char;
      valid.cleanMode = true;
    } else {
      valid.options = valid.options && isKnownOption(options[options.length] = `-${char}`);
    }
  });
  return {
    cleanMode,
    options,
    valid
  };
}
function isCleanMode(cleanMode) {
  return cleanMode === "f" || cleanMode === "n";
}
function isKnownOption(option) {
  return /^-[a-z]$/i.test(option) && CleanOptionValues.has(option.charAt(1));
}
function isInteractiveMode(option) {
  if (/^-[^\-]/.test(option)) {
    return option.indexOf("i") > 0;
  }
  return option === "--interactive";
}
var CONFIG_ERROR_INTERACTIVE_MODE;
var CONFIG_ERROR_MODE_REQUIRED;
var CONFIG_ERROR_UNKNOWN_OPTION;
var CleanOptions;
var CleanOptionValues;
var init_clean = __esm({
  "src/lib/tasks/clean.ts"() {
    init_CleanSummary();
    init_utils();
    init_task();
    CONFIG_ERROR_INTERACTIVE_MODE = "Git clean interactive mode is not supported";
    CONFIG_ERROR_MODE_REQUIRED = 'Git clean mode parameter ("n" or "f") is required';
    CONFIG_ERROR_UNKNOWN_OPTION = "Git clean unknown option found in: ";
    CleanOptions = /* @__PURE__ */ ((CleanOptions2) => {
      CleanOptions2["DRY_RUN"] = "n";
      CleanOptions2["FORCE"] = "f";
      CleanOptions2["IGNORED_INCLUDED"] = "x";
      CleanOptions2["IGNORED_ONLY"] = "X";
      CleanOptions2["EXCLUDING"] = "e";
      CleanOptions2["QUIET"] = "q";
      CleanOptions2["RECURSIVE"] = "d";
      return CleanOptions2;
    })(CleanOptions || {});
    CleanOptionValues = /* @__PURE__ */ new Set([
      "i",
      ...asStringArray(Object.values(CleanOptions))
    ]);
  }
});
function configListParser(text) {
  const config = new ConfigList();
  for (const item of configParser(text)) {
    config.addValue(item.file, String(item.key), item.value);
  }
  return config;
}
function configGetParser(text, key) {
  let value = null;
  const values = [];
  const scopes = /* @__PURE__ */ new Map();
  for (const item of configParser(text, key)) {
    if (item.key !== key) {
      continue;
    }
    values.push(value = item.value);
    if (!scopes.has(item.file)) {
      scopes.set(item.file, []);
    }
    scopes.get(item.file).push(value);
  }
  return {
    key,
    paths: Array.from(scopes.keys()),
    scopes,
    value,
    values
  };
}
function configFilePath(filePath) {
  return filePath.replace(/^(file):/, "");
}
function* configParser(text, requestedKey = null) {
  const lines = text.split("\0");
  for (let i = 0, max = lines.length - 1; i < max; ) {
    const file = configFilePath(lines[i++]);
    let value = lines[i++];
    let key = requestedKey;
    if (value.includes("\n")) {
      const line = splitOn(value, "\n");
      key = line[0];
      value = line[1];
    }
    yield { file, key, value };
  }
}
var ConfigList;
var init_ConfigList = __esm({
  "src/lib/responses/ConfigList.ts"() {
    init_utils();
    ConfigList = class {
      constructor() {
        this.files = [];
        this.values = /* @__PURE__ */ Object.create(null);
      }
      get all() {
        if (!this._all) {
          this._all = this.files.reduce((all, file) => {
            return Object.assign(all, this.values[file]);
          }, {});
        }
        return this._all;
      }
      addFile(file) {
        if (!(file in this.values)) {
          const latest = last(this.files);
          this.values[file] = latest ? Object.create(this.values[latest]) : {};
          this.files.push(file);
        }
        return this.values[file];
      }
      addValue(file, key, value) {
        const values = this.addFile(file);
        if (!values.hasOwnProperty(key)) {
          values[key] = value;
        } else if (Array.isArray(values[key])) {
          values[key].push(value);
        } else {
          values[key] = [values[key], value];
        }
        this._all = void 0;
      }
    };
  }
});
function asConfigScope(scope, fallback) {
  if (typeof scope === "string" && GitConfigScope.hasOwnProperty(scope)) {
    return scope;
  }
  return fallback;
}
function addConfigTask(key, value, append2, scope) {
  const commands = ["config", `--${scope}`];
  if (append2) {
    commands.push("--add");
  }
  commands.push(key, value);
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return text;
    }
  };
}
function getConfigTask(key, scope) {
  const commands = ["config", "--null", "--show-origin", "--get-all", key];
  if (scope) {
    commands.splice(1, 0, `--${scope}`);
  }
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return configGetParser(text, key);
    }
  };
}
function listConfigTask(scope) {
  const commands = ["config", "--list", "--show-origin", "--null"];
  if (scope) {
    commands.push(`--${scope}`);
  }
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return configListParser(text);
    }
  };
}
function config_default() {
  return {
    addConfig(key, value, ...rest) {
      return this._runTask(addConfigTask(key, value, rest[0] === true, asConfigScope(
        rest[1],
        "local"
        /* local */
      )), trailingFunctionArgument(arguments));
    },
    getConfig(key, scope) {
      return this._runTask(getConfigTask(key, asConfigScope(scope, void 0)), trailingFunctionArgument(arguments));
    },
    listConfig(...rest) {
      return this._runTask(listConfigTask(asConfigScope(rest[0], void 0)), trailingFunctionArgument(arguments));
    }
  };
}
var GitConfigScope;
var init_config = __esm({
  "src/lib/tasks/config.ts"() {
    init_ConfigList();
    init_utils();
    GitConfigScope = /* @__PURE__ */ ((GitConfigScope2) => {
      GitConfigScope2["system"] = "system";
      GitConfigScope2["global"] = "global";
      GitConfigScope2["local"] = "local";
      GitConfigScope2["worktree"] = "worktree";
      return GitConfigScope2;
    })(GitConfigScope || {});
  }
});
function isDiffNameStatus(input) {
  return diffNameStatus.has(input);
}
var DiffNameStatus;
var diffNameStatus;
var init_diff_name_status = __esm({
  "src/lib/tasks/diff-name-status.ts"() {
    DiffNameStatus = /* @__PURE__ */ ((DiffNameStatus2) => {
      DiffNameStatus2["ADDED"] = "A";
      DiffNameStatus2["COPIED"] = "C";
      DiffNameStatus2["DELETED"] = "D";
      DiffNameStatus2["MODIFIED"] = "M";
      DiffNameStatus2["RENAMED"] = "R";
      DiffNameStatus2["CHANGED"] = "T";
      DiffNameStatus2["UNMERGED"] = "U";
      DiffNameStatus2["UNKNOWN"] = "X";
      DiffNameStatus2["BROKEN"] = "B";
      return DiffNameStatus2;
    })(DiffNameStatus || {});
    diffNameStatus = new Set(Object.values(DiffNameStatus));
  }
});
function grepQueryBuilder(...params) {
  return new GrepQuery().param(...params);
}
function parseGrep(grep) {
  const paths = /* @__PURE__ */ new Set();
  const results = {};
  forEachLineWithContent(grep, (input) => {
    const [path2, line, preview] = input.split(NULL);
    paths.add(path2);
    (results[path2] = results[path2] || []).push({
      line: asNumber(line),
      path: path2,
      preview
    });
  });
  return {
    paths,
    results
  };
}
function grep_default() {
  return {
    grep(searchTerm) {
      const then = trailingFunctionArgument(arguments);
      const options = getTrailingOptions(arguments);
      for (const option of disallowedOptions) {
        if (options.includes(option)) {
          return this._runTask(configurationErrorTask(`git.grep: use of "${option}" is not supported.`), then);
        }
      }
      if (typeof searchTerm === "string") {
        searchTerm = grepQueryBuilder().param(searchTerm);
      }
      const commands = ["grep", "--null", "-n", "--full-name", ...options, ...searchTerm];
      return this._runTask({
        commands,
        format: "utf-8",
        parser(stdOut) {
          return parseGrep(stdOut);
        }
      }, then);
    }
  };
}
var disallowedOptions;
var Query;
var _a;
var GrepQuery;
var init_grep = __esm({
  "src/lib/tasks/grep.ts"() {
    init_utils();
    init_task();
    disallowedOptions = ["-h"];
    Query = Symbol("grepQuery");
    GrepQuery = class {
      constructor() {
        this[_a] = [];
      }
      *[(_a = Query, Symbol.iterator)]() {
        for (const query of this[Query]) {
          yield query;
        }
      }
      and(...and) {
        and.length && this[Query].push("--and", "(", ...prefixedArray(and, "-e"), ")");
        return this;
      }
      param(...param) {
        this[Query].push(...prefixedArray(param, "-e"));
        return this;
      }
    };
  }
});
var reset_exports = {};
__export2(reset_exports, {
  ResetMode: () => ResetMode,
  getResetMode: () => getResetMode,
  resetTask: () => resetTask
});
function resetTask(mode, customArgs) {
  const commands = ["reset"];
  if (isValidResetMode(mode)) {
    commands.push(`--${mode}`);
  }
  commands.push(...customArgs);
  return straightThroughStringTask(commands);
}
function getResetMode(mode) {
  if (isValidResetMode(mode)) {
    return mode;
  }
  switch (typeof mode) {
    case "string":
    case "undefined":
      return "soft";
  }
  return;
}
function isValidResetMode(mode) {
  return ResetModes.includes(mode);
}
var ResetMode;
var ResetModes;
var init_reset = __esm({
  "src/lib/tasks/reset.ts"() {
    init_task();
    ResetMode = /* @__PURE__ */ ((ResetMode2) => {
      ResetMode2["MIXED"] = "mixed";
      ResetMode2["SOFT"] = "soft";
      ResetMode2["HARD"] = "hard";
      ResetMode2["MERGE"] = "merge";
      ResetMode2["KEEP"] = "keep";
      return ResetMode2;
    })(ResetMode || {});
    ResetModes = Array.from(Object.values(ResetMode));
  }
});
function createLog() {
  return (0, import_debug2.default)("simple-git");
}
function prefixedLogger(to, prefix, forward) {
  if (!prefix || !String(prefix).replace(/\s*/, "")) {
    return !forward ? to : (message, ...args) => {
      to(message, ...args);
      forward(message, ...args);
    };
  }
  return (message, ...args) => {
    to(`%s ${message}`, prefix, ...args);
    if (forward) {
      forward(message, ...args);
    }
  };
}
function childLoggerName(name, childDebugger, { namespace: parentNamespace }) {
  if (typeof name === "string") {
    return name;
  }
  const childNamespace = childDebugger && childDebugger.namespace || "";
  if (childNamespace.startsWith(parentNamespace)) {
    return childNamespace.substr(parentNamespace.length + 1);
  }
  return childNamespace || parentNamespace;
}
function createLogger(label, verbose, initialStep, infoDebugger = createLog()) {
  const labelPrefix = label && `[${label}]` || "";
  const spawned = [];
  const debugDebugger = typeof verbose === "string" ? infoDebugger.extend(verbose) : verbose;
  const key = childLoggerName(filterType(verbose, filterString), debugDebugger, infoDebugger);
  return step(initialStep);
  function sibling(name, initial) {
    return append(spawned, createLogger(label, key.replace(/^[^:]+/, name), initial, infoDebugger));
  }
  function step(phase) {
    const stepPrefix = phase && `[${phase}]` || "";
    const debug2 = debugDebugger && prefixedLogger(debugDebugger, stepPrefix) || NOOP;
    const info = prefixedLogger(infoDebugger, `${labelPrefix} ${stepPrefix}`, debug2);
    return Object.assign(debugDebugger ? debug2 : info, {
      label,
      sibling,
      info,
      step
    });
  }
}
var init_git_logger = __esm({
  "src/lib/git-logger.ts"() {
    init_utils();
    import_debug2.default.formatters.L = (value) => String(filterHasLength(value) ? value.length : "-");
    import_debug2.default.formatters.B = (value) => {
      if (Buffer.isBuffer(value)) {
        return value.toString("utf8");
      }
      return objectToString(value);
    };
  }
});
var _TasksPendingQueue;
var TasksPendingQueue;
var init_tasks_pending_queue = __esm({
  "src/lib/runners/tasks-pending-queue.ts"() {
    init_git_error();
    init_git_logger();
    _TasksPendingQueue = class {
      constructor(logLabel = "GitExecutor") {
        this.logLabel = logLabel;
        this._queue = /* @__PURE__ */ new Map();
      }
      withProgress(task) {
        return this._queue.get(task);
      }
      createProgress(task) {
        const name = _TasksPendingQueue.getName(task.commands[0]);
        const logger = createLogger(this.logLabel, name);
        return {
          task,
          logger,
          name
        };
      }
      push(task) {
        const progress = this.createProgress(task);
        progress.logger("Adding task to the queue, commands = %o", task.commands);
        this._queue.set(task, progress);
        return progress;
      }
      fatal(err) {
        for (const [task, { logger }] of Array.from(this._queue.entries())) {
          if (task === err.task) {
            logger.info(`Failed %o`, err);
            logger(`Fatal exception, any as-yet un-started tasks run through this executor will not be attempted`);
          } else {
            logger.info(`A fatal exception occurred in a previous task, the queue has been purged: %o`, err.message);
          }
          this.complete(task);
        }
        if (this._queue.size !== 0) {
          throw new Error(`Queue size should be zero after fatal: ${this._queue.size}`);
        }
      }
      complete(task) {
        const progress = this.withProgress(task);
        if (progress) {
          this._queue.delete(task);
        }
      }
      attempt(task) {
        const progress = this.withProgress(task);
        if (!progress) {
          throw new GitError(void 0, "TasksPendingQueue: attempt called for an unknown task");
        }
        progress.logger("Starting task");
        return progress;
      }
      static getName(name = "empty") {
        return `task:${name}:${++_TasksPendingQueue.counter}`;
      }
    };
    TasksPendingQueue = _TasksPendingQueue;
    TasksPendingQueue.counter = 0;
  }
});
function pluginContext(task, commands) {
  return {
    method: first(task.commands) || "",
    commands
  };
}
function onErrorReceived(target, logger) {
  return (err) => {
    logger(`[ERROR] child process exception %o`, err);
    target.push(Buffer.from(String(err.stack), "ascii"));
  };
}
function onDataReceived(target, name, logger, output) {
  return (buffer) => {
    logger(`%s received %L bytes`, name, buffer);
    output(`%B`, buffer);
    target.push(buffer);
  };
}
var GitExecutorChain;
var init_git_executor_chain = __esm({
  "src/lib/runners/git-executor-chain.ts"() {
    init_git_error();
    init_task();
    init_utils();
    init_tasks_pending_queue();
    GitExecutorChain = class {
      constructor(_executor, _scheduler, _plugins) {
        this._executor = _executor;
        this._scheduler = _scheduler;
        this._plugins = _plugins;
        this._chain = Promise.resolve();
        this._queue = new TasksPendingQueue();
      }
      get binary() {
        return this._executor.binary;
      }
      get cwd() {
        return this._cwd || this._executor.cwd;
      }
      set cwd(cwd) {
        this._cwd = cwd;
      }
      get env() {
        return this._executor.env;
      }
      get outputHandler() {
        return this._executor.outputHandler;
      }
      chain() {
        return this;
      }
      push(task) {
        this._queue.push(task);
        return this._chain = this._chain.then(() => this.attemptTask(task));
      }
      attemptTask(task) {
        return __async(this, null, function* () {
          const onScheduleComplete = yield this._scheduler.next();
          const onQueueComplete = () => this._queue.complete(task);
          try {
            const { logger } = this._queue.attempt(task);
            return yield isEmptyTask(task) ? this.attemptEmptyTask(task, logger) : this.attemptRemoteTask(task, logger);
          } catch (e) {
            throw this.onFatalException(task, e);
          } finally {
            onQueueComplete();
            onScheduleComplete();
          }
        });
      }
      onFatalException(task, e) {
        const gitError = e instanceof GitError ? Object.assign(e, { task }) : new GitError(task, e && String(e));
        this._chain = Promise.resolve();
        this._queue.fatal(gitError);
        return gitError;
      }
      attemptRemoteTask(task, logger) {
        return __async(this, null, function* () {
          const args = this._plugins.exec("spawn.args", [...task.commands], pluginContext(task, task.commands));
          const raw = yield this.gitResponse(task, this.binary, args, this.outputHandler, logger.step("SPAWN"));
          const outputStreams = yield this.handleTaskData(task, args, raw, logger.step("HANDLE"));
          logger(`passing response to task's parser as a %s`, task.format);
          if (isBufferTask(task)) {
            return callTaskParser(task.parser, outputStreams);
          }
          return callTaskParser(task.parser, outputStreams.asStrings());
        });
      }
      attemptEmptyTask(task, logger) {
        return __async(this, null, function* () {
          logger(`empty task bypassing child process to call to task's parser`);
          return task.parser(this);
        });
      }
      handleTaskData(task, args, result, logger) {
        const { exitCode, rejection, stdOut, stdErr } = result;
        return new Promise((done, fail) => {
          logger(`Preparing to handle process response exitCode=%d stdOut=`, exitCode);
          const { error } = this._plugins.exec("task.error", { error: rejection }, __spreadValues(__spreadValues({}, pluginContext(task, args)), result));
          if (error && task.onError) {
            logger.info(`exitCode=%s handling with custom error handler`);
            return task.onError(result, error, (newStdOut) => {
              logger.info(`custom error handler treated as success`);
              logger(`custom error returned a %s`, objectToString(newStdOut));
              done(new GitOutputStreams(Array.isArray(newStdOut) ? Buffer.concat(newStdOut) : newStdOut, Buffer.concat(stdErr)));
            }, fail);
          }
          if (error) {
            logger.info(`handling as error: exitCode=%s stdErr=%s rejection=%o`, exitCode, stdErr.length, rejection);
            return fail(error);
          }
          logger.info(`retrieving task output complete`);
          done(new GitOutputStreams(Buffer.concat(stdOut), Buffer.concat(stdErr)));
        });
      }
      gitResponse(task, command, args, outputHandler, logger) {
        return __async(this, null, function* () {
          const outputLogger = logger.sibling("output");
          const spawnOptions = this._plugins.exec("spawn.options", {
            cwd: this.cwd,
            env: this.env,
            windowsHide: true
          }, pluginContext(task, task.commands));
          return new Promise((done) => {
            const stdOut = [];
            const stdErr = [];
            logger.info(`%s %o`, command, args);
            logger("%O", spawnOptions);
            let rejection = this._beforeSpawn(task, args);
            if (rejection) {
              return done({
                stdOut,
                stdErr,
                exitCode: 9901,
                rejection
              });
            }
            this._plugins.exec("spawn.before", void 0, __spreadProps(__spreadValues({}, pluginContext(task, args)), {
              kill(reason) {
                rejection = reason || rejection;
              }
            }));
            const spawned = (0, import_child_process.spawn)(command, args, spawnOptions);
            spawned.stdout.on("data", onDataReceived(stdOut, "stdOut", logger, outputLogger.step("stdOut")));
            spawned.stderr.on("data", onDataReceived(stdErr, "stdErr", logger, outputLogger.step("stdErr")));
            spawned.on("error", onErrorReceived(stdErr, logger));
            if (outputHandler) {
              logger(`Passing child process stdOut/stdErr to custom outputHandler`);
              outputHandler(command, spawned.stdout, spawned.stderr, [...args]);
            }
            this._plugins.exec("spawn.after", void 0, __spreadProps(__spreadValues({}, pluginContext(task, args)), {
              spawned,
              close(exitCode, reason) {
                done({
                  stdOut,
                  stdErr,
                  exitCode,
                  rejection: rejection || reason
                });
              },
              kill(reason) {
                if (spawned.killed) {
                  return;
                }
                rejection = reason;
                spawned.kill("SIGINT");
              }
            }));
          });
        });
      }
      _beforeSpawn(task, args) {
        let rejection;
        this._plugins.exec("spawn.before", void 0, __spreadProps(__spreadValues({}, pluginContext(task, args)), {
          kill(reason) {
            rejection = reason || rejection;
          }
        }));
        return rejection;
      }
    };
  }
});
var git_executor_exports = {};
__export2(git_executor_exports, {
  GitExecutor: () => GitExecutor
});
var GitExecutor;
var init_git_executor = __esm({
  "src/lib/runners/git-executor.ts"() {
    init_git_executor_chain();
    GitExecutor = class {
      constructor(binary = "git", cwd, _scheduler, _plugins) {
        this.binary = binary;
        this.cwd = cwd;
        this._scheduler = _scheduler;
        this._plugins = _plugins;
        this._chain = new GitExecutorChain(this, this._scheduler, this._plugins);
      }
      chain() {
        return new GitExecutorChain(this, this._scheduler, this._plugins);
      }
      push(task) {
        return this._chain.push(task);
      }
    };
  }
});
function taskCallback(task, response, callback = NOOP) {
  const onSuccess = (data) => {
    callback(null, data);
  };
  const onError2 = (err) => {
    if ((err == null ? void 0 : err.task) === task) {
      callback(err instanceof GitResponseError ? addDeprecationNoticeToError(err) : err, void 0);
    }
  };
  response.then(onSuccess, onError2);
}
function addDeprecationNoticeToError(err) {
  let log = (name) => {
    console.warn(`simple-git deprecation notice: accessing GitResponseError.${name} should be GitResponseError.git.${name}, this will no longer be available in version 3`);
    log = NOOP;
  };
  return Object.create(err, Object.getOwnPropertyNames(err.git).reduce(descriptorReducer, {}));
  function descriptorReducer(all, name) {
    if (name in err) {
      return all;
    }
    all[name] = {
      enumerable: false,
      configurable: false,
      get() {
        log(name);
        return err.git[name];
      }
    };
    return all;
  }
}
var init_task_callback = __esm({
  "src/lib/task-callback.ts"() {
    init_git_response_error();
    init_utils();
  }
});
function changeWorkingDirectoryTask(directory, root) {
  return adhocExecTask((instance) => {
    if (!folderExists(directory)) {
      throw new Error(`Git.cwd: cannot change to non-directory "${directory}"`);
    }
    return (root || instance).cwd = directory;
  });
}
var init_change_working_directory = __esm({
  "src/lib/tasks/change-working-directory.ts"() {
    init_utils();
    init_task();
  }
});
function checkoutTask(args) {
  const commands = ["checkout", ...args];
  if (commands[1] === "-b" && commands.includes("-B")) {
    commands[1] = remove(commands, "-B");
  }
  return straightThroughStringTask(commands);
}
function checkout_default() {
  return {
    checkout() {
      return this._runTask(checkoutTask(getTrailingOptions(arguments, 1)), trailingFunctionArgument(arguments));
    },
    checkoutBranch(branchName, startPoint) {
      return this._runTask(checkoutTask(["-b", branchName, startPoint, ...getTrailingOptions(arguments)]), trailingFunctionArgument(arguments));
    },
    checkoutLocalBranch(branchName) {
      return this._runTask(checkoutTask(["-b", branchName, ...getTrailingOptions(arguments)]), trailingFunctionArgument(arguments));
    }
  };
}
var init_checkout = __esm({
  "src/lib/tasks/checkout.ts"() {
    init_utils();
    init_task();
  }
});
function parseCommitResult(stdOut) {
  const result = {
    author: null,
    branch: "",
    commit: "",
    root: false,
    summary: {
      changes: 0,
      insertions: 0,
      deletions: 0
    }
  };
  return parseStringResponse(result, parsers, stdOut);
}
var parsers;
var init_parse_commit = __esm({
  "src/lib/parsers/parse-commit.ts"() {
    init_utils();
    parsers = [
      new LineParser(/^\[([^\s]+)( \([^)]+\))? ([^\]]+)/, (result, [branch, root, commit]) => {
        result.branch = branch;
        result.commit = commit;
        result.root = !!root;
      }),
      new LineParser(/\s*Author:\s(.+)/i, (result, [author]) => {
        const parts = author.split("<");
        const email = parts.pop();
        if (!email || !email.includes("@")) {
          return;
        }
        result.author = {
          email: email.substr(0, email.length - 1),
          name: parts.join("<").trim()
        };
      }),
      new LineParser(/(\d+)[^,]*(?:,\s*(\d+)[^,]*)(?:,\s*(\d+))/g, (result, [changes, insertions, deletions]) => {
        result.summary.changes = parseInt(changes, 10) || 0;
        result.summary.insertions = parseInt(insertions, 10) || 0;
        result.summary.deletions = parseInt(deletions, 10) || 0;
      }),
      new LineParser(/^(\d+)[^,]*(?:,\s*(\d+)[^(]+\(([+-]))?/, (result, [changes, lines, direction]) => {
        result.summary.changes = parseInt(changes, 10) || 0;
        const count = parseInt(lines, 10) || 0;
        if (direction === "-") {
          result.summary.deletions = count;
        } else if (direction === "+") {
          result.summary.insertions = count;
        }
      })
    ];
  }
});
function commitTask(message, files, customArgs) {
  const commands = [
    "-c",
    "core.abbrev=40",
    "commit",
    ...prefixedArray(message, "-m"),
    ...files,
    ...customArgs
  ];
  return {
    commands,
    format: "utf-8",
    parser: parseCommitResult
  };
}
function commit_default() {
  return {
    commit(message, ...rest) {
      const next = trailingFunctionArgument(arguments);
      const task = rejectDeprecatedSignatures(message) || commitTask(asArray(message), asArray(filterType(rest[0], filterStringOrStringArray, [])), [...filterType(rest[1], filterArray, []), ...getTrailingOptions(arguments, 0, true)]);
      return this._runTask(task, next);
    }
  };
  function rejectDeprecatedSignatures(message) {
    return !filterStringOrStringArray(message) && configurationErrorTask(`git.commit: requires the commit message to be supplied as a string/string[]`);
  }
}
var init_commit = __esm({
  "src/lib/tasks/commit.ts"() {
    init_parse_commit();
    init_utils();
    init_task();
  }
});
function first_commit_default() {
  return {
    firstCommit() {
      return this._runTask(straightThroughStringTask(["rev-list", "--max-parents=0", "HEAD"], true), trailingFunctionArgument(arguments));
    }
  };
}
var init_first_commit = __esm({
  "src/lib/tasks/first-commit.ts"() {
    init_utils();
    init_task();
  }
});
function hashObjectTask(filePath, write) {
  const commands = ["hash-object", filePath];
  if (write) {
    commands.push("-w");
  }
  return straightThroughStringTask(commands, true);
}
var init_hash_object = __esm({
  "src/lib/tasks/hash-object.ts"() {
    init_task();
  }
});
function parseInit(bare, path2, text) {
  const response = String(text).trim();
  let result;
  if (result = initResponseRegex.exec(response)) {
    return new InitSummary(bare, path2, false, result[1]);
  }
  if (result = reInitResponseRegex.exec(response)) {
    return new InitSummary(bare, path2, true, result[1]);
  }
  let gitDir = "";
  const tokens = response.split(" ");
  while (tokens.length) {
    const token = tokens.shift();
    if (token === "in") {
      gitDir = tokens.join(" ");
      break;
    }
  }
  return new InitSummary(bare, path2, /^re/i.test(response), gitDir);
}
var InitSummary;
var initResponseRegex;
var reInitResponseRegex;
var init_InitSummary = __esm({
  "src/lib/responses/InitSummary.ts"() {
    InitSummary = class {
      constructor(bare, path2, existing, gitDir) {
        this.bare = bare;
        this.path = path2;
        this.existing = existing;
        this.gitDir = gitDir;
      }
    };
    initResponseRegex = /^Init.+ repository in (.+)$/;
    reInitResponseRegex = /^Rein.+ in (.+)$/;
  }
});
function hasBareCommand(command) {
  return command.includes(bareCommand);
}
function initTask(bare = false, path2, customArgs) {
  const commands = ["init", ...customArgs];
  if (bare && !hasBareCommand(commands)) {
    commands.splice(1, 0, bareCommand);
  }
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return parseInit(commands.includes("--bare"), path2, text);
    }
  };
}
var bareCommand;
var init_init = __esm({
  "src/lib/tasks/init.ts"() {
    init_InitSummary();
    bareCommand = "--bare";
  }
});
function logFormatFromCommand(customArgs) {
  for (let i = 0; i < customArgs.length; i++) {
    const format = logFormatRegex.exec(customArgs[i]);
    if (format) {
      return `--${format[1]}`;
    }
  }
  return "";
}
function isLogFormat(customArg) {
  return logFormatRegex.test(customArg);
}
var logFormatRegex;
var init_log_format = __esm({
  "src/lib/args/log-format.ts"() {
    logFormatRegex = /^--(stat|numstat|name-only|name-status)(=|$)/;
  }
});
var DiffSummary;
var init_DiffSummary = __esm({
  "src/lib/responses/DiffSummary.ts"() {
    DiffSummary = class {
      constructor() {
        this.changed = 0;
        this.deletions = 0;
        this.insertions = 0;
        this.files = [];
      }
    };
  }
});
function getDiffParser(format = "") {
  const parser3 = diffSummaryParsers[format];
  return (stdOut) => parseStringResponse(new DiffSummary(), parser3, stdOut, false);
}
var statParser;
var numStatParser;
var nameOnlyParser;
var nameStatusParser;
var diffSummaryParsers;
var init_parse_diff_summary = __esm({
  "src/lib/parsers/parse-diff-summary.ts"() {
    init_log_format();
    init_DiffSummary();
    init_diff_name_status();
    init_utils();
    statParser = [
      new LineParser(/(.+)\s+\|\s+(\d+)(\s+[+\-]+)?$/, (result, [file, changes, alterations = ""]) => {
        result.files.push({
          file: file.trim(),
          changes: asNumber(changes),
          insertions: alterations.replace(/[^+]/g, "").length,
          deletions: alterations.replace(/[^-]/g, "").length,
          binary: false
        });
      }),
      new LineParser(/(.+) \|\s+Bin ([0-9.]+) -> ([0-9.]+) ([a-z]+)/, (result, [file, before, after]) => {
        result.files.push({
          file: file.trim(),
          before: asNumber(before),
          after: asNumber(after),
          binary: true
        });
      }),
      new LineParser(/(\d+) files? changed\s*((?:, \d+ [^,]+){0,2})/, (result, [changed, summary]) => {
        const inserted = /(\d+) i/.exec(summary);
        const deleted = /(\d+) d/.exec(summary);
        result.changed = asNumber(changed);
        result.insertions = asNumber(inserted == null ? void 0 : inserted[1]);
        result.deletions = asNumber(deleted == null ? void 0 : deleted[1]);
      })
    ];
    numStatParser = [
      new LineParser(/(\d+)\t(\d+)\t(.+)$/, (result, [changesInsert, changesDelete, file]) => {
        const insertions = asNumber(changesInsert);
        const deletions = asNumber(changesDelete);
        result.changed++;
        result.insertions += insertions;
        result.deletions += deletions;
        result.files.push({
          file,
          changes: insertions + deletions,
          insertions,
          deletions,
          binary: false
        });
      }),
      new LineParser(/-\t-\t(.+)$/, (result, [file]) => {
        result.changed++;
        result.files.push({
          file,
          after: 0,
          before: 0,
          binary: true
        });
      })
    ];
    nameOnlyParser = [
      new LineParser(/(.+)$/, (result, [file]) => {
        result.changed++;
        result.files.push({
          file,
          changes: 0,
          insertions: 0,
          deletions: 0,
          binary: false
        });
      })
    ];
    nameStatusParser = [
      new LineParser(/([ACDMRTUXB])([0-9]{0,3})\t(.[^\t]*)(\t(.[^\t]*))?$/, (result, [status, _similarity, from, _to, to]) => {
        result.changed++;
        result.files.push({
          file: to != null ? to : from,
          changes: 0,
          status: orVoid(isDiffNameStatus(status) && status),
          insertions: 0,
          deletions: 0,
          binary: false
        });
      })
    ];
    diffSummaryParsers = {
      [
        ""
        /* NONE */
      ]: statParser,
      [
        "--stat"
        /* STAT */
      ]: statParser,
      [
        "--numstat"
        /* NUM_STAT */
      ]: numStatParser,
      [
        "--name-status"
        /* NAME_STATUS */
      ]: nameStatusParser,
      [
        "--name-only"
        /* NAME_ONLY */
      ]: nameOnlyParser
    };
  }
});
function lineBuilder(tokens, fields) {
  return fields.reduce((line, field, index) => {
    line[field] = tokens[index] || "";
    return line;
  }, /* @__PURE__ */ Object.create({ diff: null }));
}
function createListLogSummaryParser(splitter = SPLITTER, fields = defaultFieldNames, logFormat = "") {
  const parseDiffResult = getDiffParser(logFormat);
  return function(stdOut) {
    const all = toLinesWithContent(stdOut, true, START_BOUNDARY).map(function(item) {
      const lineDetail = item.trim().split(COMMIT_BOUNDARY);
      const listLogLine = lineBuilder(lineDetail[0].trim().split(splitter), fields);
      if (lineDetail.length > 1 && !!lineDetail[1].trim()) {
        listLogLine.diff = parseDiffResult(lineDetail[1]);
      }
      return listLogLine;
    });
    return {
      all,
      latest: all.length && all[0] || null,
      total: all.length
    };
  };
}
var START_BOUNDARY;
var COMMIT_BOUNDARY;
var SPLITTER;
var defaultFieldNames;
var init_parse_list_log_summary = __esm({
  "src/lib/parsers/parse-list-log-summary.ts"() {
    init_utils();
    init_parse_diff_summary();
    init_log_format();
    START_BOUNDARY = "\xF2\xF2\xF2\xF2\xF2\xF2 ";
    COMMIT_BOUNDARY = " \xF2\xF2";
    SPLITTER = " \xF2 ";
    defaultFieldNames = ["hash", "date", "message", "refs", "author_name", "author_email"];
  }
});
var diff_exports = {};
__export2(diff_exports, {
  diffSummaryTask: () => diffSummaryTask,
  validateLogFormatConfig: () => validateLogFormatConfig
});
function diffSummaryTask(customArgs) {
  let logFormat = logFormatFromCommand(customArgs);
  const commands = ["diff"];
  if (logFormat === "") {
    logFormat = "--stat";
    commands.push("--stat=4096");
  }
  commands.push(...customArgs);
  return validateLogFormatConfig(commands) || {
    commands,
    format: "utf-8",
    parser: getDiffParser(logFormat)
  };
}
function validateLogFormatConfig(customArgs) {
  const flags = customArgs.filter(isLogFormat);
  if (flags.length > 1) {
    return configurationErrorTask(`Summary flags are mutually exclusive - pick one of ${flags.join(",")}`);
  }
  if (flags.length && customArgs.includes("-z")) {
    return configurationErrorTask(`Summary flag ${flags} parsing is not compatible with null termination option '-z'`);
  }
}
var init_diff = __esm({
  "src/lib/tasks/diff.ts"() {
    init_log_format();
    init_parse_diff_summary();
    init_task();
  }
});
function prettyFormat(format, splitter) {
  const fields = [];
  const formatStr = [];
  Object.keys(format).forEach((field) => {
    fields.push(field);
    formatStr.push(String(format[field]));
  });
  return [fields, formatStr.join(splitter)];
}
function userOptions(input) {
  return Object.keys(input).reduce((out, key) => {
    if (!(key in excludeOptions)) {
      out[key] = input[key];
    }
    return out;
  }, {});
}
function parseLogOptions(opt = {}, customArgs = []) {
  const splitter = filterType(opt.splitter, filterString, SPLITTER);
  const format = !filterPrimitives(opt.format) && opt.format ? opt.format : {
    hash: "%H",
    date: opt.strictDate === false ? "%ai" : "%aI",
    message: "%s",
    refs: "%D",
    body: opt.multiLine ? "%B" : "%b",
    author_name: opt.mailMap !== false ? "%aN" : "%an",
    author_email: opt.mailMap !== false ? "%aE" : "%ae"
  };
  const [fields, formatStr] = prettyFormat(format, splitter);
  const suffix = [];
  const command = [
    `--pretty=format:${START_BOUNDARY}${formatStr}${COMMIT_BOUNDARY}`,
    ...customArgs
  ];
  const maxCount = opt.n || opt["max-count"] || opt.maxCount;
  if (maxCount) {
    command.push(`--max-count=${maxCount}`);
  }
  if (opt.from || opt.to) {
    const rangeOperator = opt.symmetric !== false ? "..." : "..";
    suffix.push(`${opt.from || ""}${rangeOperator}${opt.to || ""}`);
  }
  if (filterString(opt.file)) {
    command.push("--follow", pathspec(opt.file));
  }
  appendTaskOptions(userOptions(opt), command);
  return {
    fields,
    splitter,
    commands: [...command, ...suffix]
  };
}
function logTask(splitter, fields, customArgs) {
  const parser3 = createListLogSummaryParser(splitter, fields, logFormatFromCommand(customArgs));
  return {
    commands: ["log", ...customArgs],
    format: "utf-8",
    parser: parser3
  };
}
function log_default() {
  return {
    log(...rest) {
      const next = trailingFunctionArgument(arguments);
      const options = parseLogOptions(trailingOptionsArgument(arguments), filterType(arguments[0], filterArray));
      const task = rejectDeprecatedSignatures(...rest) || validateLogFormatConfig(options.commands) || createLogTask(options);
      return this._runTask(task, next);
    }
  };
  function createLogTask(options) {
    return logTask(options.splitter, options.fields, options.commands);
  }
  function rejectDeprecatedSignatures(from, to) {
    return filterString(from) && filterString(to) && configurationErrorTask(`git.log(string, string) should be replaced with git.log({ from: string, to: string })`);
  }
}
var excludeOptions;
var init_log = __esm({
  "src/lib/tasks/log.ts"() {
    init_log_format();
    init_pathspec();
    init_parse_list_log_summary();
    init_utils();
    init_task();
    init_diff();
    excludeOptions = /* @__PURE__ */ ((excludeOptions2) => {
      excludeOptions2[excludeOptions2["--pretty"] = 0] = "--pretty";
      excludeOptions2[excludeOptions2["max-count"] = 1] = "max-count";
      excludeOptions2[excludeOptions2["maxCount"] = 2] = "maxCount";
      excludeOptions2[excludeOptions2["n"] = 3] = "n";
      excludeOptions2[excludeOptions2["file"] = 4] = "file";
      excludeOptions2[excludeOptions2["format"] = 5] = "format";
      excludeOptions2[excludeOptions2["from"] = 6] = "from";
      excludeOptions2[excludeOptions2["to"] = 7] = "to";
      excludeOptions2[excludeOptions2["splitter"] = 8] = "splitter";
      excludeOptions2[excludeOptions2["symmetric"] = 9] = "symmetric";
      excludeOptions2[excludeOptions2["mailMap"] = 10] = "mailMap";
      excludeOptions2[excludeOptions2["multiLine"] = 11] = "multiLine";
      excludeOptions2[excludeOptions2["strictDate"] = 12] = "strictDate";
      return excludeOptions2;
    })(excludeOptions || {});
  }
});
var MergeSummaryConflict;
var MergeSummaryDetail;
var init_MergeSummary = __esm({
  "src/lib/responses/MergeSummary.ts"() {
    MergeSummaryConflict = class {
      constructor(reason, file = null, meta) {
        this.reason = reason;
        this.file = file;
        this.meta = meta;
      }
      toString() {
        return `${this.file}:${this.reason}`;
      }
    };
    MergeSummaryDetail = class {
      constructor() {
        this.conflicts = [];
        this.merges = [];
        this.result = "success";
      }
      get failed() {
        return this.conflicts.length > 0;
      }
      get reason() {
        return this.result;
      }
      toString() {
        if (this.conflicts.length) {
          return `CONFLICTS: ${this.conflicts.join(", ")}`;
        }
        return "OK";
      }
    };
  }
});
var PullSummary;
var PullFailedSummary;
var init_PullSummary = __esm({
  "src/lib/responses/PullSummary.ts"() {
    PullSummary = class {
      constructor() {
        this.remoteMessages = {
          all: []
        };
        this.created = [];
        this.deleted = [];
        this.files = [];
        this.deletions = {};
        this.insertions = {};
        this.summary = {
          changes: 0,
          deletions: 0,
          insertions: 0
        };
      }
    };
    PullFailedSummary = class {
      constructor() {
        this.remote = "";
        this.hash = {
          local: "",
          remote: ""
        };
        this.branch = {
          local: "",
          remote: ""
        };
        this.message = "";
      }
      toString() {
        return this.message;
      }
    };
  }
});
function objectEnumerationResult(remoteMessages) {
  return remoteMessages.objects = remoteMessages.objects || {
    compressing: 0,
    counting: 0,
    enumerating: 0,
    packReused: 0,
    reused: { count: 0, delta: 0 },
    total: { count: 0, delta: 0 }
  };
}
function asObjectCount(source) {
  const count = /^\s*(\d+)/.exec(source);
  const delta = /delta (\d+)/i.exec(source);
  return {
    count: asNumber(count && count[1] || "0"),
    delta: asNumber(delta && delta[1] || "0")
  };
}
var remoteMessagesObjectParsers;
var init_parse_remote_objects = __esm({
  "src/lib/parsers/parse-remote-objects.ts"() {
    init_utils();
    remoteMessagesObjectParsers = [
      new RemoteLineParser(/^remote:\s*(enumerating|counting|compressing) objects: (\d+),/i, (result, [action, count]) => {
        const key = action.toLowerCase();
        const enumeration = objectEnumerationResult(result.remoteMessages);
        Object.assign(enumeration, { [key]: asNumber(count) });
      }),
      new RemoteLineParser(/^remote:\s*(enumerating|counting|compressing) objects: \d+% \(\d+\/(\d+)\),/i, (result, [action, count]) => {
        const key = action.toLowerCase();
        const enumeration = objectEnumerationResult(result.remoteMessages);
        Object.assign(enumeration, { [key]: asNumber(count) });
      }),
      new RemoteLineParser(/total ([^,]+), reused ([^,]+), pack-reused (\d+)/i, (result, [total, reused, packReused]) => {
        const objects = objectEnumerationResult(result.remoteMessages);
        objects.total = asObjectCount(total);
        objects.reused = asObjectCount(reused);
        objects.packReused = asNumber(packReused);
      })
    ];
  }
});
function parseRemoteMessages(_stdOut, stdErr) {
  return parseStringResponse({ remoteMessages: new RemoteMessageSummary() }, parsers2, stdErr);
}
var parsers2;
var RemoteMessageSummary;
var init_parse_remote_messages = __esm({
  "src/lib/parsers/parse-remote-messages.ts"() {
    init_utils();
    init_parse_remote_objects();
    parsers2 = [
      new RemoteLineParser(/^remote:\s*(.+)$/, (result, [text]) => {
        result.remoteMessages.all.push(text.trim());
        return false;
      }),
      ...remoteMessagesObjectParsers,
      new RemoteLineParser([/create a (?:pull|merge) request/i, /\s(https?:\/\/\S+)$/], (result, [pullRequestUrl]) => {
        result.remoteMessages.pullRequestUrl = pullRequestUrl;
      }),
      new RemoteLineParser([/found (\d+) vulnerabilities.+\(([^)]+)\)/i, /\s(https?:\/\/\S+)$/], (result, [count, summary, url]) => {
        result.remoteMessages.vulnerabilities = {
          count: asNumber(count),
          summary,
          url
        };
      })
    ];
    RemoteMessageSummary = class {
      constructor() {
        this.all = [];
      }
    };
  }
});
function parsePullErrorResult(stdOut, stdErr) {
  const pullError = parseStringResponse(new PullFailedSummary(), errorParsers, [stdOut, stdErr]);
  return pullError.message && pullError;
}
var FILE_UPDATE_REGEX;
var SUMMARY_REGEX;
var ACTION_REGEX;
var parsers3;
var errorParsers;
var parsePullDetail;
var parsePullResult;
var init_parse_pull = __esm({
  "src/lib/parsers/parse-pull.ts"() {
    init_PullSummary();
    init_utils();
    init_parse_remote_messages();
    FILE_UPDATE_REGEX = /^\s*(.+?)\s+\|\s+\d+\s*(\+*)(-*)/;
    SUMMARY_REGEX = /(\d+)\D+((\d+)\D+\(\+\))?(\D+(\d+)\D+\(-\))?/;
    ACTION_REGEX = /^(create|delete) mode \d+ (.+)/;
    parsers3 = [
      new LineParser(FILE_UPDATE_REGEX, (result, [file, insertions, deletions]) => {
        result.files.push(file);
        if (insertions) {
          result.insertions[file] = insertions.length;
        }
        if (deletions) {
          result.deletions[file] = deletions.length;
        }
      }),
      new LineParser(SUMMARY_REGEX, (result, [changes, , insertions, , deletions]) => {
        if (insertions !== void 0 || deletions !== void 0) {
          result.summary.changes = +changes || 0;
          result.summary.insertions = +insertions || 0;
          result.summary.deletions = +deletions || 0;
          return true;
        }
        return false;
      }),
      new LineParser(ACTION_REGEX, (result, [action, file]) => {
        append(result.files, file);
        append(action === "create" ? result.created : result.deleted, file);
      })
    ];
    errorParsers = [
      new LineParser(/^from\s(.+)$/i, (result, [remote]) => void (result.remote = remote)),
      new LineParser(/^fatal:\s(.+)$/, (result, [message]) => void (result.message = message)),
      new LineParser(/([a-z0-9]+)\.\.([a-z0-9]+)\s+(\S+)\s+->\s+(\S+)$/, (result, [hashLocal, hashRemote, branchLocal, branchRemote]) => {
        result.branch.local = branchLocal;
        result.hash.local = hashLocal;
        result.branch.remote = branchRemote;
        result.hash.remote = hashRemote;
      })
    ];
    parsePullDetail = (stdOut, stdErr) => {
      return parseStringResponse(new PullSummary(), parsers3, [stdOut, stdErr]);
    };
    parsePullResult = (stdOut, stdErr) => {
      return Object.assign(new PullSummary(), parsePullDetail(stdOut, stdErr), parseRemoteMessages(stdOut, stdErr));
    };
  }
});
var parsers4;
var parseMergeResult;
var parseMergeDetail;
var init_parse_merge = __esm({
  "src/lib/parsers/parse-merge.ts"() {
    init_MergeSummary();
    init_utils();
    init_parse_pull();
    parsers4 = [
      new LineParser(/^Auto-merging\s+(.+)$/, (summary, [autoMerge]) => {
        summary.merges.push(autoMerge);
      }),
      new LineParser(/^CONFLICT\s+\((.+)\): Merge conflict in (.+)$/, (summary, [reason, file]) => {
        summary.conflicts.push(new MergeSummaryConflict(reason, file));
      }),
      new LineParser(/^CONFLICT\s+\((.+\/delete)\): (.+) deleted in (.+) and/, (summary, [reason, file, deleteRef]) => {
        summary.conflicts.push(new MergeSummaryConflict(reason, file, { deleteRef }));
      }),
      new LineParser(/^CONFLICT\s+\((.+)\):/, (summary, [reason]) => {
        summary.conflicts.push(new MergeSummaryConflict(reason, null));
      }),
      new LineParser(/^Automatic merge failed;\s+(.+)$/, (summary, [result]) => {
        summary.result = result;
      })
    ];
    parseMergeResult = (stdOut, stdErr) => {
      return Object.assign(parseMergeDetail(stdOut, stdErr), parsePullResult(stdOut, stdErr));
    };
    parseMergeDetail = (stdOut) => {
      return parseStringResponse(new MergeSummaryDetail(), parsers4, stdOut);
    };
  }
});
function mergeTask(customArgs) {
  if (!customArgs.length) {
    return configurationErrorTask("Git.merge requires at least one option");
  }
  return {
    commands: ["merge", ...customArgs],
    format: "utf-8",
    parser(stdOut, stdErr) {
      const merge = parseMergeResult(stdOut, stdErr);
      if (merge.failed) {
        throw new GitResponseError(merge);
      }
      return merge;
    }
  };
}
var init_merge = __esm({
  "src/lib/tasks/merge.ts"() {
    init_git_response_error();
    init_parse_merge();
    init_task();
  }
});
function pushResultPushedItem(local, remote, status) {
  const deleted = status.includes("deleted");
  const tag = status.includes("tag") || /^refs\/tags/.test(local);
  const alreadyUpdated = !status.includes("new");
  return {
    deleted,
    tag,
    branch: !tag,
    new: !alreadyUpdated,
    alreadyUpdated,
    local,
    remote
  };
}
var parsers5;
var parsePushResult;
var parsePushDetail;
var init_parse_push = __esm({
  "src/lib/parsers/parse-push.ts"() {
    init_utils();
    init_parse_remote_messages();
    parsers5 = [
      new LineParser(/^Pushing to (.+)$/, (result, [repo]) => {
        result.repo = repo;
      }),
      new LineParser(/^updating local tracking ref '(.+)'/, (result, [local]) => {
        result.ref = __spreadProps(__spreadValues({}, result.ref || {}), {
          local
        });
      }),
      new LineParser(/^[=*-]\s+([^:]+):(\S+)\s+\[(.+)]$/, (result, [local, remote, type]) => {
        result.pushed.push(pushResultPushedItem(local, remote, type));
      }),
      new LineParser(/^Branch '([^']+)' set up to track remote branch '([^']+)' from '([^']+)'/, (result, [local, remote, remoteName]) => {
        result.branch = __spreadProps(__spreadValues({}, result.branch || {}), {
          local,
          remote,
          remoteName
        });
      }),
      new LineParser(/^([^:]+):(\S+)\s+([a-z0-9]+)\.\.([a-z0-9]+)$/, (result, [local, remote, from, to]) => {
        result.update = {
          head: {
            local,
            remote
          },
          hash: {
            from,
            to
          }
        };
      })
    ];
    parsePushResult = (stdOut, stdErr) => {
      const pushDetail = parsePushDetail(stdOut, stdErr);
      const responseDetail = parseRemoteMessages(stdOut, stdErr);
      return __spreadValues(__spreadValues({}, pushDetail), responseDetail);
    };
    parsePushDetail = (stdOut, stdErr) => {
      return parseStringResponse({ pushed: [] }, parsers5, [stdOut, stdErr]);
    };
  }
});
var push_exports = {};
__export2(push_exports, {
  pushTagsTask: () => pushTagsTask,
  pushTask: () => pushTask
});
function pushTagsTask(ref = {}, customArgs) {
  append(customArgs, "--tags");
  return pushTask(ref, customArgs);
}
function pushTask(ref = {}, customArgs) {
  const commands = ["push", ...customArgs];
  if (ref.branch) {
    commands.splice(1, 0, ref.branch);
  }
  if (ref.remote) {
    commands.splice(1, 0, ref.remote);
  }
  remove(commands, "-v");
  append(commands, "--verbose");
  append(commands, "--porcelain");
  return {
    commands,
    format: "utf-8",
    parser: parsePushResult
  };
}
var init_push = __esm({
  "src/lib/tasks/push.ts"() {
    init_parse_push();
    init_utils();
  }
});
function show_default() {
  return {
    showBuffer() {
      const commands = ["show", ...getTrailingOptions(arguments, 1)];
      if (!commands.includes("--binary")) {
        commands.splice(1, 0, "--binary");
      }
      return this._runTask(straightThroughBufferTask(commands), trailingFunctionArgument(arguments));
    },
    show() {
      const commands = ["show", ...getTrailingOptions(arguments, 1)];
      return this._runTask(straightThroughStringTask(commands), trailingFunctionArgument(arguments));
    }
  };
}
var init_show = __esm({
  "src/lib/tasks/show.ts"() {
    init_utils();
    init_task();
  }
});
var fromPathRegex;
var FileStatusSummary;
var init_FileStatusSummary = __esm({
  "src/lib/responses/FileStatusSummary.ts"() {
    fromPathRegex = /^(.+) -> (.+)$/;
    FileStatusSummary = class {
      constructor(path2, index, working_dir) {
        this.path = path2;
        this.index = index;
        this.working_dir = working_dir;
        if (index + working_dir === "R") {
          const detail = fromPathRegex.exec(path2) || [null, path2, path2];
          this.from = detail[1] || "";
          this.path = detail[2] || "";
        }
      }
    };
  }
});
function renamedFile(line) {
  const [to, from] = line.split(NULL);
  return {
    from: from || to,
    to
  };
}
function parser2(indexX, indexY, handler) {
  return [`${indexX}${indexY}`, handler];
}
function conflicts(indexX, ...indexY) {
  return indexY.map((y) => parser2(indexX, y, (result, file) => append(result.conflicted, file)));
}
function splitLine(result, lineStr) {
  const trimmed2 = lineStr.trim();
  switch (" ") {
    case trimmed2.charAt(2):
      return data(trimmed2.charAt(0), trimmed2.charAt(1), trimmed2.substr(3));
    case trimmed2.charAt(1):
      return data(" ", trimmed2.charAt(0), trimmed2.substr(2));
    default:
      return;
  }
  function data(index, workingDir, path2) {
    const raw = `${index}${workingDir}`;
    const handler = parsers6.get(raw);
    if (handler) {
      handler(result, path2);
    }
    if (raw !== "##" && raw !== "!!") {
      result.files.push(new FileStatusSummary(path2.replace(/\0.+$/, ""), index, workingDir));
    }
  }
}
var StatusSummary;
var parsers6;
var parseStatusSummary;
var init_StatusSummary = __esm({
  "src/lib/responses/StatusSummary.ts"() {
    init_utils();
    init_FileStatusSummary();
    StatusSummary = class {
      constructor() {
        this.not_added = [];
        this.conflicted = [];
        this.created = [];
        this.deleted = [];
        this.ignored = void 0;
        this.modified = [];
        this.renamed = [];
        this.files = [];
        this.staged = [];
        this.ahead = 0;
        this.behind = 0;
        this.current = null;
        this.tracking = null;
        this.detached = false;
        this.isClean = () => {
          return !this.files.length;
        };
      }
    };
    parsers6 = new Map([
      parser2(" ", "A", (result, file) => append(result.created, file)),
      parser2(" ", "D", (result, file) => append(result.deleted, file)),
      parser2(" ", "M", (result, file) => append(result.modified, file)),
      parser2("A", " ", (result, file) => append(result.created, file) && append(result.staged, file)),
      parser2("A", "M", (result, file) => append(result.created, file) && append(result.staged, file) && append(result.modified, file)),
      parser2("D", " ", (result, file) => append(result.deleted, file) && append(result.staged, file)),
      parser2("M", " ", (result, file) => append(result.modified, file) && append(result.staged, file)),
      parser2("M", "M", (result, file) => append(result.modified, file) && append(result.staged, file)),
      parser2("R", " ", (result, file) => {
        append(result.renamed, renamedFile(file));
      }),
      parser2("R", "M", (result, file) => {
        const renamed = renamedFile(file);
        append(result.renamed, renamed);
        append(result.modified, renamed.to);
      }),
      parser2("!", "!", (_result, _file) => {
        append(_result.ignored = _result.ignored || [], _file);
      }),
      parser2("?", "?", (result, file) => append(result.not_added, file)),
      ...conflicts(
        "A",
        "A",
        "U"
        /* UNMERGED */
      ),
      ...conflicts(
        "D",
        "D",
        "U"
        /* UNMERGED */
      ),
      ...conflicts(
        "U",
        "A",
        "D",
        "U"
        /* UNMERGED */
      ),
      [
        "##",
        (result, line) => {
          const aheadReg = /ahead (\d+)/;
          const behindReg = /behind (\d+)/;
          const currentReg = /^(.+?(?=(?:\.{3}|\s|$)))/;
          const trackingReg = /\.{3}(\S*)/;
          const onEmptyBranchReg = /\son\s([\S]+)$/;
          let regexResult;
          regexResult = aheadReg.exec(line);
          result.ahead = regexResult && +regexResult[1] || 0;
          regexResult = behindReg.exec(line);
          result.behind = regexResult && +regexResult[1] || 0;
          regexResult = currentReg.exec(line);
          result.current = regexResult && regexResult[1];
          regexResult = trackingReg.exec(line);
          result.tracking = regexResult && regexResult[1];
          regexResult = onEmptyBranchReg.exec(line);
          result.current = regexResult && regexResult[1] || result.current;
          result.detached = /\(no branch\)/.test(line);
        }
      ]
    ]);
    parseStatusSummary = function(text) {
      const lines = text.split(NULL);
      const status = new StatusSummary();
      for (let i = 0, l = lines.length; i < l; ) {
        let line = lines[i++].trim();
        if (!line) {
          continue;
        }
        if (line.charAt(0) === "R") {
          line += NULL + (lines[i++] || "");
        }
        splitLine(status, line);
      }
      return status;
    };
  }
});
function statusTask(customArgs) {
  const commands = [
    "status",
    "--porcelain",
    "-b",
    "-u",
    "--null",
    ...customArgs.filter((arg) => !ignoredOptions.includes(arg))
  ];
  return {
    format: "utf-8",
    commands,
    parser(text) {
      return parseStatusSummary(text);
    }
  };
}
var ignoredOptions;
var init_status = __esm({
  "src/lib/tasks/status.ts"() {
    init_StatusSummary();
    ignoredOptions = ["--null", "-z"];
  }
});
function versionResponse(major = 0, minor = 0, patch = 0, agent = "", installed = true) {
  return Object.defineProperty({
    major,
    minor,
    patch,
    agent,
    installed
  }, "toString", {
    value() {
      return `${this.major}.${this.minor}.${this.patch}`;
    },
    configurable: false,
    enumerable: false
  });
}
function notInstalledResponse() {
  return versionResponse(0, 0, 0, "", false);
}
function version_default() {
  return {
    version() {
      return this._runTask({
        commands: ["--version"],
        format: "utf-8",
        parser: versionParser,
        onError(result, error, done, fail) {
          if (result.exitCode === -2) {
            return done(Buffer.from(NOT_INSTALLED));
          }
          fail(error);
        }
      });
    }
  };
}
function versionParser(stdOut) {
  if (stdOut === NOT_INSTALLED) {
    return notInstalledResponse();
  }
  return parseStringResponse(versionResponse(0, 0, 0, stdOut), parsers7, stdOut);
}
var NOT_INSTALLED;
var parsers7;
var init_version = __esm({
  "src/lib/tasks/version.ts"() {
    init_utils();
    NOT_INSTALLED = "installed=false";
    parsers7 = [
      new LineParser(/version (\d+)\.(\d+)\.(\d+)(?:\s*\((.+)\))?/, (result, [major, minor, patch, agent = ""]) => {
        Object.assign(result, versionResponse(asNumber(major), asNumber(minor), asNumber(patch), agent));
      }),
      new LineParser(/version (\d+)\.(\d+)\.(\D+)(.+)?$/, (result, [major, minor, patch, agent = ""]) => {
        Object.assign(result, versionResponse(asNumber(major), asNumber(minor), patch, agent));
      })
    ];
  }
});
var simple_git_api_exports = {};
__export2(simple_git_api_exports, {
  SimpleGitApi: () => SimpleGitApi
});
var SimpleGitApi;
var init_simple_git_api = __esm({
  "src/lib/simple-git-api.ts"() {
    init_task_callback();
    init_change_working_directory();
    init_checkout();
    init_commit();
    init_config();
    init_first_commit();
    init_grep();
    init_hash_object();
    init_init();
    init_log();
    init_merge();
    init_push();
    init_show();
    init_status();
    init_task();
    init_version();
    init_utils();
    SimpleGitApi = class {
      constructor(_executor) {
        this._executor = _executor;
      }
      _runTask(task, then) {
        const chain = this._executor.chain();
        const promise = chain.push(task);
        if (then) {
          taskCallback(task, promise, then);
        }
        return Object.create(this, {
          then: { value: promise.then.bind(promise) },
          catch: { value: promise.catch.bind(promise) },
          _executor: { value: chain }
        });
      }
      add(files) {
        return this._runTask(straightThroughStringTask(["add", ...asArray(files)]), trailingFunctionArgument(arguments));
      }
      cwd(directory) {
        const next = trailingFunctionArgument(arguments);
        if (typeof directory === "string") {
          return this._runTask(changeWorkingDirectoryTask(directory, this._executor), next);
        }
        if (typeof (directory == null ? void 0 : directory.path) === "string") {
          return this._runTask(changeWorkingDirectoryTask(directory.path, directory.root && this._executor || void 0), next);
        }
        return this._runTask(configurationErrorTask("Git.cwd: workingDirectory must be supplied as a string"), next);
      }
      hashObject(path2, write) {
        return this._runTask(hashObjectTask(path2, write === true), trailingFunctionArgument(arguments));
      }
      init(bare) {
        return this._runTask(initTask(bare === true, this._executor.cwd, getTrailingOptions(arguments)), trailingFunctionArgument(arguments));
      }
      merge() {
        return this._runTask(mergeTask(getTrailingOptions(arguments)), trailingFunctionArgument(arguments));
      }
      mergeFromTo(remote, branch) {
        if (!(filterString(remote) && filterString(branch))) {
          return this._runTask(configurationErrorTask(`Git.mergeFromTo requires that the 'remote' and 'branch' arguments are supplied as strings`));
        }
        return this._runTask(mergeTask([remote, branch, ...getTrailingOptions(arguments)]), trailingFunctionArgument(arguments, false));
      }
      outputHandler(handler) {
        this._executor.outputHandler = handler;
        return this;
      }
      push() {
        const task = pushTask({
          remote: filterType(arguments[0], filterString),
          branch: filterType(arguments[1], filterString)
        }, getTrailingOptions(arguments));
        return this._runTask(task, trailingFunctionArgument(arguments));
      }
      stash() {
        return this._runTask(straightThroughStringTask(["stash", ...getTrailingOptions(arguments)]), trailingFunctionArgument(arguments));
      }
      status() {
        return this._runTask(statusTask(getTrailingOptions(arguments)), trailingFunctionArgument(arguments));
      }
    };
    Object.assign(SimpleGitApi.prototype, checkout_default(), commit_default(), config_default(), first_commit_default(), grep_default(), log_default(), show_default(), version_default());
  }
});
var scheduler_exports = {};
__export2(scheduler_exports, {
  Scheduler: () => Scheduler
});
var createScheduledTask;
var Scheduler;
var init_scheduler = __esm({
  "src/lib/runners/scheduler.ts"() {
    init_utils();
    init_git_logger();
    createScheduledTask = (() => {
      let id = 0;
      return () => {
        id++;
        const { promise, done } = (0, import_promise_deferred.createDeferred)();
        return {
          promise,
          done,
          id
        };
      };
    })();
    Scheduler = class {
      constructor(concurrency = 2) {
        this.concurrency = concurrency;
        this.logger = createLogger("", "scheduler");
        this.pending = [];
        this.running = [];
        this.logger(`Constructed, concurrency=%s`, concurrency);
      }
      schedule() {
        if (!this.pending.length || this.running.length >= this.concurrency) {
          this.logger(`Schedule attempt ignored, pending=%s running=%s concurrency=%s`, this.pending.length, this.running.length, this.concurrency);
          return;
        }
        const task = append(this.running, this.pending.shift());
        this.logger(`Attempting id=%s`, task.id);
        task.done(() => {
          this.logger(`Completing id=`, task.id);
          remove(this.running, task);
          this.schedule();
        });
      }
      next() {
        const { promise, id } = append(this.pending, createScheduledTask());
        this.logger(`Scheduling id=%s`, id);
        this.schedule();
        return promise;
      }
    };
  }
});
var apply_patch_exports = {};
__export2(apply_patch_exports, {
  applyPatchTask: () => applyPatchTask
});
function applyPatchTask(patches, customArgs) {
  return straightThroughStringTask(["apply", ...customArgs, ...patches]);
}
var init_apply_patch = __esm({
  "src/lib/tasks/apply-patch.ts"() {
    init_task();
  }
});
function branchDeletionSuccess(branch, hash) {
  return {
    branch,
    hash,
    success: true
  };
}
function branchDeletionFailure(branch) {
  return {
    branch,
    hash: null,
    success: false
  };
}
var BranchDeletionBatch;
var init_BranchDeleteSummary = __esm({
  "src/lib/responses/BranchDeleteSummary.ts"() {
    BranchDeletionBatch = class {
      constructor() {
        this.all = [];
        this.branches = {};
        this.errors = [];
      }
      get success() {
        return !this.errors.length;
      }
    };
  }
});
function hasBranchDeletionError(data, processExitCode) {
  return processExitCode === 1 && deleteErrorRegex.test(data);
}
var deleteSuccessRegex;
var deleteErrorRegex;
var parsers8;
var parseBranchDeletions;
var init_parse_branch_delete = __esm({
  "src/lib/parsers/parse-branch-delete.ts"() {
    init_BranchDeleteSummary();
    init_utils();
    deleteSuccessRegex = /(\S+)\s+\(\S+\s([^)]+)\)/;
    deleteErrorRegex = /^error[^']+'([^']+)'/m;
    parsers8 = [
      new LineParser(deleteSuccessRegex, (result, [branch, hash]) => {
        const deletion = branchDeletionSuccess(branch, hash);
        result.all.push(deletion);
        result.branches[branch] = deletion;
      }),
      new LineParser(deleteErrorRegex, (result, [branch]) => {
        const deletion = branchDeletionFailure(branch);
        result.errors.push(deletion);
        result.all.push(deletion);
        result.branches[branch] = deletion;
      })
    ];
    parseBranchDeletions = (stdOut, stdErr) => {
      return parseStringResponse(new BranchDeletionBatch(), parsers8, [stdOut, stdErr]);
    };
  }
});
var BranchSummaryResult;
var init_BranchSummary = __esm({
  "src/lib/responses/BranchSummary.ts"() {
    BranchSummaryResult = class {
      constructor() {
        this.all = [];
        this.branches = {};
        this.current = "";
        this.detached = false;
      }
      push(status, detached, name, commit, label) {
        if (status === "*") {
          this.detached = detached;
          this.current = name;
        }
        this.all.push(name);
        this.branches[name] = {
          current: status === "*",
          linkedWorkTree: status === "+",
          name,
          commit,
          label
        };
      }
    };
  }
});
function branchStatus(input) {
  return input ? input.charAt(0) : "";
}
function parseBranchSummary(stdOut) {
  return parseStringResponse(new BranchSummaryResult(), parsers9, stdOut);
}
var parsers9;
var init_parse_branch = __esm({
  "src/lib/parsers/parse-branch.ts"() {
    init_BranchSummary();
    init_utils();
    parsers9 = [
      new LineParser(/^([*+]\s)?\((?:HEAD )?detached (?:from|at) (\S+)\)\s+([a-z0-9]+)\s(.*)$/, (result, [current, name, commit, label]) => {
        result.push(branchStatus(current), true, name, commit, label);
      }),
      new LineParser(/^([*+]\s)?(\S+)\s+([a-z0-9]+)\s?(.*)$/s, (result, [current, name, commit, label]) => {
        result.push(branchStatus(current), false, name, commit, label);
      })
    ];
  }
});
var branch_exports = {};
__export2(branch_exports, {
  branchLocalTask: () => branchLocalTask,
  branchTask: () => branchTask,
  containsDeleteBranchCommand: () => containsDeleteBranchCommand,
  deleteBranchTask: () => deleteBranchTask,
  deleteBranchesTask: () => deleteBranchesTask
});
function containsDeleteBranchCommand(commands) {
  const deleteCommands = ["-d", "-D", "--delete"];
  return commands.some((command) => deleteCommands.includes(command));
}
function branchTask(customArgs) {
  const isDelete = containsDeleteBranchCommand(customArgs);
  const commands = ["branch", ...customArgs];
  if (commands.length === 1) {
    commands.push("-a");
  }
  if (!commands.includes("-v")) {
    commands.splice(1, 0, "-v");
  }
  return {
    format: "utf-8",
    commands,
    parser(stdOut, stdErr) {
      if (isDelete) {
        return parseBranchDeletions(stdOut, stdErr).all[0];
      }
      return parseBranchSummary(stdOut);
    }
  };
}
function branchLocalTask() {
  const parser3 = parseBranchSummary;
  return {
    format: "utf-8",
    commands: ["branch", "-v"],
    parser: parser3
  };
}
function deleteBranchesTask(branches, forceDelete = false) {
  return {
    format: "utf-8",
    commands: ["branch", "-v", forceDelete ? "-D" : "-d", ...branches],
    parser(stdOut, stdErr) {
      return parseBranchDeletions(stdOut, stdErr);
    },
    onError({ exitCode, stdOut }, error, done, fail) {
      if (!hasBranchDeletionError(String(error), exitCode)) {
        return fail(error);
      }
      done(stdOut);
    }
  };
}
function deleteBranchTask(branch, forceDelete = false) {
  const task = {
    format: "utf-8",
    commands: ["branch", "-v", forceDelete ? "-D" : "-d", branch],
    parser(stdOut, stdErr) {
      return parseBranchDeletions(stdOut, stdErr).branches[branch];
    },
    onError({ exitCode, stdErr, stdOut }, error, _, fail) {
      if (!hasBranchDeletionError(String(error), exitCode)) {
        return fail(error);
      }
      throw new GitResponseError(task.parser(bufferToString(stdOut), bufferToString(stdErr)), String(error));
    }
  };
  return task;
}
var init_branch = __esm({
  "src/lib/tasks/branch.ts"() {
    init_git_response_error();
    init_parse_branch_delete();
    init_parse_branch();
    init_utils();
  }
});
var parseCheckIgnore;
var init_CheckIgnore = __esm({
  "src/lib/responses/CheckIgnore.ts"() {
    parseCheckIgnore = (text) => {
      return text.split(/\n/g).map((line) => line.trim()).filter((file) => !!file);
    };
  }
});
var check_ignore_exports = {};
__export2(check_ignore_exports, {
  checkIgnoreTask: () => checkIgnoreTask
});
function checkIgnoreTask(paths) {
  return {
    commands: ["check-ignore", ...paths],
    format: "utf-8",
    parser: parseCheckIgnore
  };
}
var init_check_ignore = __esm({
  "src/lib/tasks/check-ignore.ts"() {
    init_CheckIgnore();
  }
});
var clone_exports = {};
__export2(clone_exports, {
  cloneMirrorTask: () => cloneMirrorTask,
  cloneTask: () => cloneTask
});
function disallowedCommand(command) {
  return /^--upload-pack(=|$)/.test(command);
}
function cloneTask(repo, directory, customArgs) {
  const commands = ["clone", ...customArgs];
  filterString(repo) && commands.push(repo);
  filterString(directory) && commands.push(directory);
  const banned = commands.find(disallowedCommand);
  if (banned) {
    return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);
  }
  return straightThroughStringTask(commands);
}
function cloneMirrorTask(repo, directory, customArgs) {
  append(customArgs, "--mirror");
  return cloneTask(repo, directory, customArgs);
}
var init_clone = __esm({
  "src/lib/tasks/clone.ts"() {
    init_task();
    init_utils();
  }
});
function parseFetchResult(stdOut, stdErr) {
  const result = {
    raw: stdOut,
    remote: null,
    branches: [],
    tags: [],
    updated: [],
    deleted: []
  };
  return parseStringResponse(result, parsers10, [stdOut, stdErr]);
}
var parsers10;
var init_parse_fetch = __esm({
  "src/lib/parsers/parse-fetch.ts"() {
    init_utils();
    parsers10 = [
      new LineParser(/From (.+)$/, (result, [remote]) => {
        result.remote = remote;
      }),
      new LineParser(/\* \[new branch]\s+(\S+)\s*-> (.+)$/, (result, [name, tracking]) => {
        result.branches.push({
          name,
          tracking
        });
      }),
      new LineParser(/\* \[new tag]\s+(\S+)\s*-> (.+)$/, (result, [name, tracking]) => {
        result.tags.push({
          name,
          tracking
        });
      }),
      new LineParser(/- \[deleted]\s+\S+\s*-> (.+)$/, (result, [tracking]) => {
        result.deleted.push({
          tracking
        });
      }),
      new LineParser(/\s*([^.]+)\.\.(\S+)\s+(\S+)\s*-> (.+)$/, (result, [from, to, name, tracking]) => {
        result.updated.push({
          name,
          tracking,
          to,
          from
        });
      })
    ];
  }
});
var fetch_exports = {};
__export2(fetch_exports, {
  fetchTask: () => fetchTask
});
function disallowedCommand2(command) {
  return /^--upload-pack(=|$)/.test(command);
}
function fetchTask(remote, branch, customArgs) {
  const commands = ["fetch", ...customArgs];
  if (remote && branch) {
    commands.push(remote, branch);
  }
  const banned = commands.find(disallowedCommand2);
  if (banned) {
    return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);
  }
  return {
    commands,
    format: "utf-8",
    parser: parseFetchResult
  };
}
var init_fetch = __esm({
  "src/lib/tasks/fetch.ts"() {
    init_parse_fetch();
    init_task();
  }
});
function parseMoveResult(stdOut) {
  return parseStringResponse({ moves: [] }, parsers11, stdOut);
}
var parsers11;
var init_parse_move = __esm({
  "src/lib/parsers/parse-move.ts"() {
    init_utils();
    parsers11 = [
      new LineParser(/^Renaming (.+) to (.+)$/, (result, [from, to]) => {
        result.moves.push({ from, to });
      })
    ];
  }
});
var move_exports = {};
__export2(move_exports, {
  moveTask: () => moveTask
});
function moveTask(from, to) {
  return {
    commands: ["mv", "-v", ...asArray(from), to],
    format: "utf-8",
    parser: parseMoveResult
  };
}
var init_move = __esm({
  "src/lib/tasks/move.ts"() {
    init_parse_move();
    init_utils();
  }
});
var pull_exports = {};
__export2(pull_exports, {
  pullTask: () => pullTask
});
function pullTask(remote, branch, customArgs) {
  const commands = ["pull", ...customArgs];
  if (remote && branch) {
    commands.splice(1, 0, remote, branch);
  }
  return {
    commands,
    format: "utf-8",
    parser(stdOut, stdErr) {
      return parsePullResult(stdOut, stdErr);
    },
    onError(result, _error, _done, fail) {
      const pullError = parsePullErrorResult(bufferToString(result.stdOut), bufferToString(result.stdErr));
      if (pullError) {
        return fail(new GitResponseError(pullError));
      }
      fail(_error);
    }
  };
}
var init_pull = __esm({
  "src/lib/tasks/pull.ts"() {
    init_git_response_error();
    init_parse_pull();
    init_utils();
  }
});
function parseGetRemotes(text) {
  const remotes = {};
  forEach(text, ([name]) => remotes[name] = { name });
  return Object.values(remotes);
}
function parseGetRemotesVerbose(text) {
  const remotes = {};
  forEach(text, ([name, url, purpose]) => {
    if (!remotes.hasOwnProperty(name)) {
      remotes[name] = {
        name,
        refs: { fetch: "", push: "" }
      };
    }
    if (purpose && url) {
      remotes[name].refs[purpose.replace(/[^a-z]/g, "")] = url;
    }
  });
  return Object.values(remotes);
}
function forEach(text, handler) {
  forEachLineWithContent(text, (line) => handler(line.split(/\s+/)));
}
var init_GetRemoteSummary = __esm({
  "src/lib/responses/GetRemoteSummary.ts"() {
    init_utils();
  }
});
var remote_exports = {};
__export2(remote_exports, {
  addRemoteTask: () => addRemoteTask,
  getRemotesTask: () => getRemotesTask,
  listRemotesTask: () => listRemotesTask,
  remoteTask: () => remoteTask,
  removeRemoteTask: () => removeRemoteTask
});
function addRemoteTask(remoteName, remoteRepo, customArgs = []) {
  return straightThroughStringTask(["remote", "add", ...customArgs, remoteName, remoteRepo]);
}
function getRemotesTask(verbose) {
  const commands = ["remote"];
  if (verbose) {
    commands.push("-v");
  }
  return {
    commands,
    format: "utf-8",
    parser: verbose ? parseGetRemotesVerbose : parseGetRemotes
  };
}
function listRemotesTask(customArgs = []) {
  const commands = [...customArgs];
  if (commands[0] !== "ls-remote") {
    commands.unshift("ls-remote");
  }
  return straightThroughStringTask(commands);
}
function remoteTask(customArgs = []) {
  const commands = [...customArgs];
  if (commands[0] !== "remote") {
    commands.unshift("remote");
  }
  return straightThroughStringTask(commands);
}
function removeRemoteTask(remoteName) {
  return straightThroughStringTask(["remote", "remove", remoteName]);
}
var init_remote = __esm({
  "src/lib/tasks/remote.ts"() {
    init_GetRemoteSummary();
    init_task();
  }
});
var stash_list_exports = {};
__export2(stash_list_exports, {
  stashListTask: () => stashListTask
});
function stashListTask(opt = {}, customArgs) {
  const options = parseLogOptions(opt);
  const commands = ["stash", "list", ...options.commands, ...customArgs];
  const parser3 = createListLogSummaryParser(options.splitter, options.fields, logFormatFromCommand(commands));
  return validateLogFormatConfig(commands) || {
    commands,
    format: "utf-8",
    parser: parser3
  };
}
var init_stash_list = __esm({
  "src/lib/tasks/stash-list.ts"() {
    init_log_format();
    init_parse_list_log_summary();
    init_diff();
    init_log();
  }
});
var sub_module_exports = {};
__export2(sub_module_exports, {
  addSubModuleTask: () => addSubModuleTask,
  initSubModuleTask: () => initSubModuleTask,
  subModuleTask: () => subModuleTask,
  updateSubModuleTask: () => updateSubModuleTask
});
function addSubModuleTask(repo, path2) {
  return subModuleTask(["add", repo, path2]);
}
function initSubModuleTask(customArgs) {
  return subModuleTask(["init", ...customArgs]);
}
function subModuleTask(customArgs) {
  const commands = [...customArgs];
  if (commands[0] !== "submodule") {
    commands.unshift("submodule");
  }
  return straightThroughStringTask(commands);
}
function updateSubModuleTask(customArgs) {
  return subModuleTask(["update", ...customArgs]);
}
var init_sub_module = __esm({
  "src/lib/tasks/sub-module.ts"() {
    init_task();
  }
});
function singleSorted(a, b) {
  const aIsNum = isNaN(a);
  const bIsNum = isNaN(b);
  if (aIsNum !== bIsNum) {
    return aIsNum ? 1 : -1;
  }
  return aIsNum ? sorted(a, b) : 0;
}
function sorted(a, b) {
  return a === b ? 0 : a > b ? 1 : -1;
}
function trimmed(input) {
  return input.trim();
}
function toNumber(input) {
  if (typeof input === "string") {
    return parseInt(input.replace(/^\D+/g, ""), 10) || 0;
  }
  return 0;
}
var TagList;
var parseTagList;
var init_TagList = __esm({
  "src/lib/responses/TagList.ts"() {
    TagList = class {
      constructor(all, latest) {
        this.all = all;
        this.latest = latest;
      }
    };
    parseTagList = function(data, customSort = false) {
      const tags = data.split("\n").map(trimmed).filter(Boolean);
      if (!customSort) {
        tags.sort(function(tagA, tagB) {
          const partsA = tagA.split(".");
          const partsB = tagB.split(".");
          if (partsA.length === 1 || partsB.length === 1) {
            return singleSorted(toNumber(partsA[0]), toNumber(partsB[0]));
          }
          for (let i = 0, l = Math.max(partsA.length, partsB.length); i < l; i++) {
            const diff = sorted(toNumber(partsA[i]), toNumber(partsB[i]));
            if (diff) {
              return diff;
            }
          }
          return 0;
        });
      }
      const latest = customSort ? tags[0] : [...tags].reverse().find((tag) => tag.indexOf(".") >= 0);
      return new TagList(tags, latest);
    };
  }
});
var tag_exports = {};
__export2(tag_exports, {
  addAnnotatedTagTask: () => addAnnotatedTagTask,
  addTagTask: () => addTagTask,
  tagListTask: () => tagListTask
});
function tagListTask(customArgs = []) {
  const hasCustomSort = customArgs.some((option) => /^--sort=/.test(option));
  return {
    format: "utf-8",
    commands: ["tag", "-l", ...customArgs],
    parser(text) {
      return parseTagList(text, hasCustomSort);
    }
  };
}
function addTagTask(name) {
  return {
    format: "utf-8",
    commands: ["tag", name],
    parser() {
      return { name };
    }
  };
}
function addAnnotatedTagTask(name, tagMessage) {
  return {
    format: "utf-8",
    commands: ["tag", "-a", "-m", tagMessage, name],
    parser() {
      return { name };
    }
  };
}
var init_tag = __esm({
  "src/lib/tasks/tag.ts"() {
    init_TagList();
  }
});
var require_git = __commonJS2({
  "src/git.js"(exports, module2) {
    var { GitExecutor: GitExecutor2 } = (init_git_executor(), __toCommonJS2(git_executor_exports));
    var { SimpleGitApi: SimpleGitApi2 } = (init_simple_git_api(), __toCommonJS2(simple_git_api_exports));
    var { Scheduler: Scheduler2 } = (init_scheduler(), __toCommonJS2(scheduler_exports));
    var { configurationErrorTask: configurationErrorTask2 } = (init_task(), __toCommonJS2(task_exports));
    var {
      asArray: asArray2,
      filterArray: filterArray2,
      filterPrimitives: filterPrimitives2,
      filterString: filterString2,
      filterStringOrStringArray: filterStringOrStringArray2,
      filterType: filterType2,
      getTrailingOptions: getTrailingOptions2,
      trailingFunctionArgument: trailingFunctionArgument2,
      trailingOptionsArgument: trailingOptionsArgument2
    } = (init_utils(), __toCommonJS2(utils_exports));
    var { applyPatchTask: applyPatchTask2 } = (init_apply_patch(), __toCommonJS2(apply_patch_exports));
    var {
      branchTask: branchTask2,
      branchLocalTask: branchLocalTask2,
      deleteBranchesTask: deleteBranchesTask2,
      deleteBranchTask: deleteBranchTask2
    } = (init_branch(), __toCommonJS2(branch_exports));
    var { checkIgnoreTask: checkIgnoreTask2 } = (init_check_ignore(), __toCommonJS2(check_ignore_exports));
    var { checkIsRepoTask: checkIsRepoTask2 } = (init_check_is_repo(), __toCommonJS2(check_is_repo_exports));
    var { cloneTask: cloneTask2, cloneMirrorTask: cloneMirrorTask2 } = (init_clone(), __toCommonJS2(clone_exports));
    var { cleanWithOptionsTask: cleanWithOptionsTask2, isCleanOptionsArray: isCleanOptionsArray2 } = (init_clean(), __toCommonJS2(clean_exports));
    var { diffSummaryTask: diffSummaryTask2 } = (init_diff(), __toCommonJS2(diff_exports));
    var { fetchTask: fetchTask2 } = (init_fetch(), __toCommonJS2(fetch_exports));
    var { moveTask: moveTask2 } = (init_move(), __toCommonJS2(move_exports));
    var { pullTask: pullTask2 } = (init_pull(), __toCommonJS2(pull_exports));
    var { pushTagsTask: pushTagsTask2 } = (init_push(), __toCommonJS2(push_exports));
    var {
      addRemoteTask: addRemoteTask2,
      getRemotesTask: getRemotesTask2,
      listRemotesTask: listRemotesTask2,
      remoteTask: remoteTask2,
      removeRemoteTask: removeRemoteTask2
    } = (init_remote(), __toCommonJS2(remote_exports));
    var { getResetMode: getResetMode2, resetTask: resetTask2 } = (init_reset(), __toCommonJS2(reset_exports));
    var { stashListTask: stashListTask2 } = (init_stash_list(), __toCommonJS2(stash_list_exports));
    var {
      addSubModuleTask: addSubModuleTask2,
      initSubModuleTask: initSubModuleTask2,
      subModuleTask: subModuleTask2,
      updateSubModuleTask: updateSubModuleTask2
    } = (init_sub_module(), __toCommonJS2(sub_module_exports));
    var { addAnnotatedTagTask: addAnnotatedTagTask2, addTagTask: addTagTask2, tagListTask: tagListTask2 } = (init_tag(), __toCommonJS2(tag_exports));
    var { straightThroughBufferTask: straightThroughBufferTask2, straightThroughStringTask: straightThroughStringTask2 } = (init_task(), __toCommonJS2(task_exports));
    function Git22(options, plugins) {
      this._executor = new GitExecutor2(options.binary, options.baseDir, new Scheduler2(options.maxConcurrentProcesses), plugins);
      this._trimmed = options.trimmed;
    }
    (Git22.prototype = Object.create(SimpleGitApi2.prototype)).constructor = Git22;
    Git22.prototype.customBinary = function(command) {
      this._executor.binary = command;
      return this;
    };
    Git22.prototype.env = function(name, value) {
      if (arguments.length === 1 && typeof name === "object") {
        this._executor.env = name;
      } else {
        (this._executor.env = this._executor.env || {})[name] = value;
      }
      return this;
    };
    Git22.prototype.stashList = function(options) {
      return this._runTask(stashListTask2(trailingOptionsArgument2(arguments) || {}, filterArray2(options) && options || []), trailingFunctionArgument2(arguments));
    };
    function createCloneTask(api, task, repoPath, localPath) {
      if (typeof repoPath !== "string") {
        return configurationErrorTask2(`git.${api}() requires a string 'repoPath'`);
      }
      return task(repoPath, filterType2(localPath, filterString2), getTrailingOptions2(arguments));
    }
    Git22.prototype.clone = function() {
      return this._runTask(createCloneTask("clone", cloneTask2, ...arguments), trailingFunctionArgument2(arguments));
    };
    Git22.prototype.mirror = function() {
      return this._runTask(createCloneTask("mirror", cloneMirrorTask2, ...arguments), trailingFunctionArgument2(arguments));
    };
    Git22.prototype.mv = function(from, to) {
      return this._runTask(moveTask2(from, to), trailingFunctionArgument2(arguments));
    };
    Git22.prototype.checkoutLatestTag = function(then) {
      var git = this;
      return this.pull(function() {
        git.tags(function(err, tags) {
          git.checkout(tags.latest, then);
        });
      });
    };
    Git22.prototype.pull = function(remote, branch, options, then) {
      return this._runTask(pullTask2(filterType2(remote, filterString2), filterType2(branch, filterString2), getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
    };
    Git22.prototype.fetch = function(remote, branch) {
      return this._runTask(fetchTask2(filterType2(remote, filterString2), filterType2(branch, filterString2), getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
    };
    Git22.prototype.silent = function(silence) {
      console.warn("simple-git deprecation notice: git.silent: logging should be configured using the `debug` library / `DEBUG` environment variable, this will be an error in version 3");
      return this;
    };
    Git22.prototype.tags = function(options, then) {
      return this._runTask(tagListTask2(getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
    };
    Git22.prototype.rebase = function() {
      return this._runTask(straightThroughStringTask2(["rebase", ...getTrailingOptions2(arguments)]), trailingFunctionArgument2(arguments));
    };
    Git22.prototype.reset = function(mode) {
      return this._runTask(resetTask2(getResetMode2(mode), getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
    };
    Git22.prototype.revert = function(commit) {
      const next = trailingFunctionArgument2(arguments);
      if (typeof commit !== "string") {
        return this._runTask(configurationErrorTask2("Commit must be a string"), next);
      }
      return this._runTask(straightThroughStringTask2(["revert", ...getTrailingOptions2(arguments, 0, true), commit]), next);
    };
    Git22.prototype.addTag = function(name) {
      const task = typeof name === "string" ? addTagTask2(name) : configurationErrorTask2("Git.addTag requires a tag name");
      return this._runTask(task, trailingFunctionArgument2(arguments));
    };
    Git22.prototype.addAnnotatedTag = function(tagName, tagMessage) {
      return this._runTask(addAnnotatedTagTask2(tagName, tagMessage), trailingFunctionArgument2(arguments));
    };
    Git22.prototype.deleteLocalBranch = function(branchName, forceDelete, then) {
      return this._runTask(deleteBranchTask2(branchName, typeof forceDelete === "boolean" ? forceDelete : false), trailingFunctionArgument2(arguments));
    };
    Git22.prototype.deleteLocalBranches = function(branchNames, forceDelete, then) {
      return this._runTask(deleteBranchesTask2(branchNames, typeof forceDelete === "boolean" ? forceDelete : false), trailingFunctionArgument2(arguments));
    };
    Git22.prototype.branch = function(options, then) {
      return this._runTask(branchTask2(getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
    };
    Git22.prototype.branchLocal = function(then) {
      return this._runTask(branchLocalTask2(), trailingFunctionArgument2(arguments));
    };
    Git22.prototype.raw = function(commands) {
      const createRestCommands = !Array.isArray(commands);
      const command = [].slice.call(createRestCommands ? arguments : commands, 0);
      for (let i = 0; i < command.length && createRestCommands; i++) {
        if (!filterPrimitives2(command[i])) {
          command.splice(i, command.length - i);
          break;
        }
      }
      command.push(...getTrailingOptions2(arguments, 0, true));
      var next = trailingFunctionArgument2(arguments);
      if (!command.length) {
        return this._runTask(configurationErrorTask2("Raw: must supply one or more command to execute"), next);
      }
      return this._runTask(straightThroughStringTask2(command, this._trimmed), next);
    };
    Git22.prototype.submoduleAdd = function(repo, path2, then) {
      return this._runTask(addSubModuleTask2(repo, path2), trailingFunctionArgument2(arguments));
    };
    Git22.prototype.submoduleUpdate = function(args, then) {
      return this._runTask(updateSubModuleTask2(getTrailingOptions2(arguments, true)), trailingFunctionArgument2(arguments));
    };
    Git22.prototype.submoduleInit = function(args, then) {
      return this._runTask(initSubModuleTask2(getTrailingOptions2(arguments, true)), trailingFunctionArgument2(arguments));
    };
    Git22.prototype.subModule = function(options, then) {
      return this._runTask(subModuleTask2(getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
    };
    Git22.prototype.listRemote = function() {
      return this._runTask(listRemotesTask2(getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
    };
    Git22.prototype.addRemote = function(remoteName, remoteRepo, then) {
      return this._runTask(addRemoteTask2(remoteName, remoteRepo, getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
    };
    Git22.prototype.removeRemote = function(remoteName, then) {
      return this._runTask(removeRemoteTask2(remoteName), trailingFunctionArgument2(arguments));
    };
    Git22.prototype.getRemotes = function(verbose, then) {
      return this._runTask(getRemotesTask2(verbose === true), trailingFunctionArgument2(arguments));
    };
    Git22.prototype.remote = function(options, then) {
      return this._runTask(remoteTask2(getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
    };
    Git22.prototype.tag = function(options, then) {
      const command = getTrailingOptions2(arguments);
      if (command[0] !== "tag") {
        command.unshift("tag");
      }
      return this._runTask(straightThroughStringTask2(command), trailingFunctionArgument2(arguments));
    };
    Git22.prototype.updateServerInfo = function(then) {
      return this._runTask(straightThroughStringTask2(["update-server-info"]), trailingFunctionArgument2(arguments));
    };
    Git22.prototype.pushTags = function(remote, then) {
      const task = pushTagsTask2({ remote: filterType2(remote, filterString2) }, getTrailingOptions2(arguments));
      return this._runTask(task, trailingFunctionArgument2(arguments));
    };
    Git22.prototype.rm = function(files) {
      return this._runTask(straightThroughStringTask2(["rm", "-f", ...asArray2(files)]), trailingFunctionArgument2(arguments));
    };
    Git22.prototype.rmKeepLocal = function(files) {
      return this._runTask(straightThroughStringTask2(["rm", "--cached", ...asArray2(files)]), trailingFunctionArgument2(arguments));
    };
    Git22.prototype.catFile = function(options, then) {
      return this._catFile("utf-8", arguments);
    };
    Git22.prototype.binaryCatFile = function() {
      return this._catFile("buffer", arguments);
    };
    Git22.prototype._catFile = function(format, args) {
      var handler = trailingFunctionArgument2(args);
      var command = ["cat-file"];
      var options = args[0];
      if (typeof options === "string") {
        return this._runTask(configurationErrorTask2("Git.catFile: options must be supplied as an array of strings"), handler);
      }
      if (Array.isArray(options)) {
        command.push.apply(command, options);
      }
      const task = format === "buffer" ? straightThroughBufferTask2(command) : straightThroughStringTask2(command);
      return this._runTask(task, handler);
    };
    Git22.prototype.diff = function(options, then) {
      const task = filterString2(options) ? configurationErrorTask2("git.diff: supplying options as a single string is no longer supported, switch to an array of strings") : straightThroughStringTask2(["diff", ...getTrailingOptions2(arguments)]);
      return this._runTask(task, trailingFunctionArgument2(arguments));
    };
    Git22.prototype.diffSummary = function() {
      return this._runTask(diffSummaryTask2(getTrailingOptions2(arguments, 1)), trailingFunctionArgument2(arguments));
    };
    Git22.prototype.applyPatch = function(patches) {
      const task = !filterStringOrStringArray2(patches) ? configurationErrorTask2(`git.applyPatch requires one or more string patches as the first argument`) : applyPatchTask2(asArray2(patches), getTrailingOptions2([].slice.call(arguments, 1)));
      return this._runTask(task, trailingFunctionArgument2(arguments));
    };
    Git22.prototype.revparse = function() {
      const commands = ["rev-parse", ...getTrailingOptions2(arguments, true)];
      return this._runTask(straightThroughStringTask2(commands, true), trailingFunctionArgument2(arguments));
    };
    Git22.prototype.clean = function(mode, options, then) {
      const usingCleanOptionsArray = isCleanOptionsArray2(mode);
      const cleanMode = usingCleanOptionsArray && mode.join("") || filterType2(mode, filterString2) || "";
      const customArgs = getTrailingOptions2([].slice.call(arguments, usingCleanOptionsArray ? 1 : 0));
      return this._runTask(cleanWithOptionsTask2(cleanMode, customArgs), trailingFunctionArgument2(arguments));
    };
    Git22.prototype.exec = function(then) {
      const task = {
        commands: [],
        format: "utf-8",
        parser() {
          if (typeof then === "function") {
            then();
          }
        }
      };
      return this._runTask(task);
    };
    Git22.prototype.clearQueue = function() {
      return this;
    };
    Git22.prototype.checkIgnore = function(pathnames, then) {
      return this._runTask(checkIgnoreTask2(asArray2(filterType2(pathnames, filterStringOrStringArray2, []))), trailingFunctionArgument2(arguments));
    };
    Git22.prototype.checkIsRepo = function(checkType, then) {
      return this._runTask(checkIsRepoTask2(filterType2(checkType, filterString2)), trailingFunctionArgument2(arguments));
    };
    module2.exports = Git22;
  }
});
init_pathspec();
init_git_error();
var GitConstructError = class extends GitError {
  constructor(config, message) {
    super(void 0, message);
    this.config = config;
  }
};
init_git_error();
init_git_error();
var GitPluginError = class extends GitError {
  constructor(task, plugin, message) {
    super(task, message);
    this.task = task;
    this.plugin = plugin;
    Object.setPrototypeOf(this, new.target.prototype);
  }
};
init_git_response_error();
init_task_configuration_error();
init_check_is_repo();
init_clean();
init_config();
init_diff_name_status();
init_grep();
init_reset();
function abortPlugin(signal) {
  if (!signal) {
    return;
  }
  const onSpawnAfter = {
    type: "spawn.after",
    action(_data, context) {
      function kill() {
        context.kill(new GitPluginError(void 0, "abort", "Abort signal received"));
      }
      signal.addEventListener("abort", kill);
      context.spawned.on("close", () => signal.removeEventListener("abort", kill));
    }
  };
  const onSpawnBefore = {
    type: "spawn.before",
    action(_data, context) {
      if (signal.aborted) {
        context.kill(new GitPluginError(void 0, "abort", "Abort already signaled"));
      }
    }
  };
  return [onSpawnBefore, onSpawnAfter];
}
function isConfigSwitch(arg) {
  return typeof arg === "string" && arg.trim().toLowerCase() === "-c";
}
function preventProtocolOverride(arg, next) {
  if (!isConfigSwitch(arg)) {
    return;
  }
  if (!/^\s*protocol(.[a-z]+)?.allow/.test(next)) {
    return;
  }
  throw new GitPluginError(void 0, "unsafe", "Configuring protocol.allow is not permitted without enabling allowUnsafeExtProtocol");
}
function preventUploadPack(arg, method) {
  if (/^\s*--(upload|receive)-pack/.test(arg)) {
    throw new GitPluginError(void 0, "unsafe", `Use of --upload-pack or --receive-pack is not permitted without enabling allowUnsafePack`);
  }
  if (method === "clone" && /^\s*-u\b/.test(arg)) {
    throw new GitPluginError(void 0, "unsafe", `Use of clone with option -u is not permitted without enabling allowUnsafePack`);
  }
  if (method === "push" && /^\s*--exec\b/.test(arg)) {
    throw new GitPluginError(void 0, "unsafe", `Use of push with option --exec is not permitted without enabling allowUnsafePack`);
  }
}
function blockUnsafeOperationsPlugin({
  allowUnsafeProtocolOverride = false,
  allowUnsafePack = false
} = {}) {
  return {
    type: "spawn.args",
    action(args, context) {
      args.forEach((current, index) => {
        const next = index < args.length ? args[index + 1] : "";
        allowUnsafeProtocolOverride || preventProtocolOverride(current, next);
        allowUnsafePack || preventUploadPack(current, context.method);
      });
      return args;
    }
  };
}
init_utils();
function commandConfigPrefixingPlugin(configuration) {
  const prefix = prefixedArray(configuration, "-c");
  return {
    type: "spawn.args",
    action(data) {
      return [...prefix, ...data];
    }
  };
}
init_utils();
var never = (0, import_promise_deferred2.deferred)().promise;
function completionDetectionPlugin({
  onClose = true,
  onExit = 50
} = {}) {
  function createEvents() {
    let exitCode = -1;
    const events = {
      close: (0, import_promise_deferred2.deferred)(),
      closeTimeout: (0, import_promise_deferred2.deferred)(),
      exit: (0, import_promise_deferred2.deferred)(),
      exitTimeout: (0, import_promise_deferred2.deferred)()
    };
    const result = Promise.race([
      onClose === false ? never : events.closeTimeout.promise,
      onExit === false ? never : events.exitTimeout.promise
    ]);
    configureTimeout(onClose, events.close, events.closeTimeout);
    configureTimeout(onExit, events.exit, events.exitTimeout);
    return {
      close(code) {
        exitCode = code;
        events.close.done();
      },
      exit(code) {
        exitCode = code;
        events.exit.done();
      },
      get exitCode() {
        return exitCode;
      },
      result
    };
  }
  function configureTimeout(flag, event, timeout) {
    if (flag === false) {
      return;
    }
    (flag === true ? event.promise : event.promise.then(() => delay(flag))).then(timeout.done);
  }
  return {
    type: "spawn.after",
    action(_0, _1) {
      return __async(this, arguments, function* (_data, { spawned, close }) {
        var _a2, _b;
        const events = createEvents();
        let deferClose = true;
        let quickClose = () => void (deferClose = false);
        (_a2 = spawned.stdout) == null ? void 0 : _a2.on("data", quickClose);
        (_b = spawned.stderr) == null ? void 0 : _b.on("data", quickClose);
        spawned.on("error", quickClose);
        spawned.on("close", (code) => events.close(code));
        spawned.on("exit", (code) => events.exit(code));
        try {
          yield events.result;
          if (deferClose) {
            yield delay(50);
          }
          close(events.exitCode);
        } catch (err) {
          close(events.exitCode, err);
        }
      });
    }
  };
}
init_git_error();
function isTaskError(result) {
  return !!(result.exitCode && result.stdErr.length);
}
function getErrorMessage(result) {
  return Buffer.concat([...result.stdOut, ...result.stdErr]);
}
function errorDetectionHandler(overwrite = false, isError = isTaskError, errorMessage = getErrorMessage) {
  return (error, result) => {
    if (!overwrite && error || !isError(result)) {
      return error;
    }
    return errorMessage(result);
  };
}
function errorDetectionPlugin(config) {
  return {
    type: "task.error",
    action(data, context) {
      const error = config(data.error, {
        stdErr: context.stdErr,
        stdOut: context.stdOut,
        exitCode: context.exitCode
      });
      if (Buffer.isBuffer(error)) {
        return { error: new GitError(void 0, error.toString("utf-8")) };
      }
      return {
        error
      };
    }
  };
}
init_utils();
var PluginStore = class {
  constructor() {
    this.plugins = /* @__PURE__ */ new Set();
  }
  add(plugin) {
    const plugins = [];
    asArray(plugin).forEach((plugin2) => plugin2 && this.plugins.add(append(plugins, plugin2)));
    return () => {
      plugins.forEach((plugin2) => this.plugins.delete(plugin2));
    };
  }
  exec(type, data, context) {
    let output = data;
    const contextual = Object.freeze(Object.create(context));
    for (const plugin of this.plugins) {
      if (plugin.type === type) {
        output = plugin.action(output, contextual);
      }
    }
    return output;
  }
};
init_utils();
function progressMonitorPlugin(progress) {
  const progressCommand = "--progress";
  const progressMethods = ["checkout", "clone", "fetch", "pull", "push"];
  const onProgress = {
    type: "spawn.after",
    action(_data, context) {
      var _a2;
      if (!context.commands.includes(progressCommand)) {
        return;
      }
      (_a2 = context.spawned.stderr) == null ? void 0 : _a2.on("data", (chunk) => {
        const message = /^([\s\S]+?):\s*(\d+)% \((\d+)\/(\d+)\)/.exec(chunk.toString("utf8"));
        if (!message) {
          return;
        }
        progress({
          method: context.method,
          stage: progressEventStage(message[1]),
          progress: asNumber(message[2]),
          processed: asNumber(message[3]),
          total: asNumber(message[4])
        });
      });
    }
  };
  const onArgs = {
    type: "spawn.args",
    action(args, context) {
      if (!progressMethods.includes(context.method)) {
        return args;
      }
      return including(args, progressCommand);
    }
  };
  return [onArgs, onProgress];
}
function progressEventStage(input) {
  return String(input.toLowerCase().split(" ", 1)) || "unknown";
}
init_utils();
function spawnOptionsPlugin(spawnOptions) {
  const options = pick(spawnOptions, ["uid", "gid"]);
  return {
    type: "spawn.options",
    action(data) {
      return __spreadValues(__spreadValues({}, options), data);
    }
  };
}
function timeoutPlugin({
  block,
  stdErr = true,
  stdOut = true
}) {
  if (block > 0) {
    return {
      type: "spawn.after",
      action(_data, context) {
        var _a2, _b;
        let timeout;
        function wait() {
          timeout && clearTimeout(timeout);
          timeout = setTimeout(kill, block);
        }
        function stop() {
          var _a3, _b2;
          (_a3 = context.spawned.stdout) == null ? void 0 : _a3.off("data", wait);
          (_b2 = context.spawned.stderr) == null ? void 0 : _b2.off("data", wait);
          context.spawned.off("exit", stop);
          context.spawned.off("close", stop);
          timeout && clearTimeout(timeout);
        }
        function kill() {
          stop();
          context.kill(new GitPluginError(void 0, "timeout", `block timeout reached`));
        }
        stdOut && ((_a2 = context.spawned.stdout) == null ? void 0 : _a2.on("data", wait));
        stdErr && ((_b = context.spawned.stderr) == null ? void 0 : _b.on("data", wait));
        context.spawned.on("exit", stop);
        context.spawned.on("close", stop);
        wait();
      }
    };
  }
}
init_pathspec();
function suffixPathsPlugin() {
  return {
    type: "spawn.args",
    action(data) {
      const prefix = [];
      let suffix;
      function append2(args) {
        (suffix = suffix || []).push(...args);
      }
      for (let i = 0; i < data.length; i++) {
        const param = data[i];
        if (isPathSpec(param)) {
          append2(toPaths(param));
          continue;
        }
        if (param === "--") {
          append2(data.slice(i + 1).flatMap((item) => isPathSpec(item) && toPaths(item) || item));
          break;
        }
        prefix.push(param);
      }
      return !suffix ? prefix : [...prefix, "--", ...suffix.map(String)];
    }
  };
}
init_utils();
var Git = require_git();
function gitInstanceFactory(baseDir, options) {
  const plugins = new PluginStore();
  const config = createInstanceConfig(baseDir && (typeof baseDir === "string" ? { baseDir } : baseDir) || {}, options);
  if (!folderExists(config.baseDir)) {
    throw new GitConstructError(config, `Cannot use simple-git on a directory that does not exist`);
  }
  if (Array.isArray(config.config)) {
    plugins.add(commandConfigPrefixingPlugin(config.config));
  }
  plugins.add(blockUnsafeOperationsPlugin(config.unsafe));
  plugins.add(suffixPathsPlugin());
  plugins.add(completionDetectionPlugin(config.completion));
  config.abort && plugins.add(abortPlugin(config.abort));
  config.progress && plugins.add(progressMonitorPlugin(config.progress));
  config.timeout && plugins.add(timeoutPlugin(config.timeout));
  config.spawnOptions && plugins.add(spawnOptionsPlugin(config.spawnOptions));
  plugins.add(errorDetectionPlugin(errorDetectionHandler(true)));
  config.errors && plugins.add(errorDetectionPlugin(config.errors));
  return new Git(config, plugins);
}
init_git_response_error();
var esm_default = gitInstanceFactory;

// src/git/git.ts
var DEFAULT_GIT_OPTIONS = {
  binary: "git",
  trimmed: true
};
var Git2 = class {
  constructor(baseDir) {
    this._instance = null;
    this.REMOTE_NAME = "origin";
    this.branch = null;
    this.instance = esm_default({
      ...DEFAULT_GIT_OPTIONS,
      baseDir
    }).init();
    this.instance.status().then((status) => {
      this.branch = status.current;
    }).catch((err) => {
      console.log(err);
    });
  }
  get instance() {
    if (!this._instance) {
      throw new Error("Git instance is not instantiated");
    }
    return this._instance;
  }
  set instance(inst) {
    this._instance = inst;
  }
  getBranch() {
    return this.branch;
  }
  async getRemote() {
    var _a2, _b;
    const remotes = await this.instance.getRemotes(true);
    if (remotes.length > 0) {
      return (_b = (_a2 = remotes.find((remote) => remote.name === this.REMOTE_NAME)) == null ? void 0 : _a2.refs.push) != null ? _b : null;
    } else {
      return null;
    }
  }
  addRemote(repo) {
    return this.getRemote().then((remote) => {
      if (remote !== null) {
        this.instance.removeRemote(this.REMOTE_NAME);
      }
    }).then(() => this.instance.addRemote(this.REMOTE_NAME, repo));
  }
  addAllAndCommit(msg) {
    return this.instance.add("*").commit(msg);
  }
  addAllAndCommitAndPush(msg) {
    return this.addAllAndCommit(msg).then((res) => {
      if (res.commit) {
        return this.push();
      } else {
        return null;
      }
    }).catch((err) => {
      throw new Error(err.message);
    });
  }
  pull() {
    var _a2;
    return this.instance.pull(this.REMOTE_NAME, (_a2 = this.getBranch()) != null ? _a2 : void 0).catch((err) => {
      if (err.message !== "couldn't find remote ref master") {
        throw new Error(err.message);
      }
    });
  }
  push() {
    var _a2;
    return this.instance.push(this.REMOTE_NAME, (_a2 = this.getBranch()) != null ? _a2 : void 0, ["--set-upstream"]).catch((err) => {
      throw new Error(err.message);
    });
  }
  status() {
    this.instance.status().then((status) => console.log(status));
  }
};

// src/settings-tab.ts
var import_obsidian7 = require("obsidian");
var SettingsTab = class extends import_obsidian7.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian7.Setting(containerEl).setName("Remote repository url").setDesc(
      "Enter your remote repository url (or change it to push to a different url)"
    ).addText(
      (text) => {
        var _a2;
        return text.setPlaceholder("Remote repository url").setValue((_a2 = this.plugin.settings.gitRemote) != null ? _a2 : "").onChange(async (value) => {
          this.plugin.settings.gitRemote = value;
          await this.plugin.saveSettings();
          if (this.plugin.settings.gitRemote) {
            this.plugin.git.addRemote(this.plugin.settings.gitRemote);
          }
        });
      }
    );
  }
};

// src/utils/utils.ts
var import_obsidian8 = require("obsidian");
var getVaultPath = (app) => {
  if (app.vault.adapter instanceof import_obsidian8.FileSystemAdapter) {
    return app.vault.adapter.getBasePath();
  }
  throw new Error(
    "Unable to get vault base path as vault is not within a valid file system"
  );
};

// src/main.ts
var GitPlugin = class extends import_obsidian9.Plugin {
  get menuModal() {
    return new GitMenuModal(
      this.app,
      this.settings.gitRemote ? null : this.initRemoteModal,
      this.commitModal,
      this.syncModal
    );
  }
  get initRemoteModal() {
    return new GitInitRemote(this.app, (repo) => {
      this.git.addRemote(repo).then(() => {
        new import_obsidian9.Notice(`Added remote origin "${repo}"`);
        this.updateRemoteRepository(repo);
      }).catch((err) => new import_obsidian9.Notice(err));
    });
  }
  get commitModal() {
    return new GitCommitModal(this.app, (msg, sync) => {
      if (sync) {
        this.git.addAllAndCommitAndPush(msg).then((res) => {
          if (res && (res.update || res.pushed.length > 0 && res.pushed[0].new === true)) {
            new import_obsidian9.Notice(`Committed and pushed new changes to remote branch`);
          } else {
            new import_obsidian9.Notice(`No changes to commit`);
          }
        }).catch((err) => new import_obsidian9.Notice(err));
      } else {
        this.git.addAllAndCommit(msg).then((res) => {
          if (res.commit) {
            new import_obsidian9.Notice(`Committed "${msg}"`);
          } else {
            new import_obsidian9.Notice(`No changes to commit`);
          }
        }).catch((err) => new import_obsidian9.Notice(err));
      }
    });
  }
  get syncModal() {
    return new GitSyncModal(this.app, () => {
      this.git.push().then((res) => {
        if (res.update || res.pushed.length > 0 && res.pushed[0].new === true) {
          new import_obsidian9.Notice(`Pushed new changes to remote branch`);
        } else {
          new import_obsidian9.Notice("No changes to push");
        }
      }).catch((err) => {
        this.openDebugModal(err, "ERROR");
        new import_obsidian9.Notice(err);
      });
    });
  }
  async onload() {
    try {
      this.git = new Git2(getVaultPath(this.app));
      await this.loadSettings();
      this.addSettingsPage();
      this.addMenuRibbonIcon();
      this.addOpenInitModalCommand();
      this.addSyncCommand();
      this.addOpenCommitModalCommand();
      this.addStatusBarIndication();
      if (IS_DEBUG_MODE) {
        this.addOpenFolderRibbonIcon();
        this.addDeleteGitFolderRibbonIcon();
      }
    } catch (err) {
      this.openDebugModal(err, "ERROR");
      new import_obsidian9.Notice(err);
    }
  }
  addMenuRibbonIcon() {
    this.addRibbonIcon("git-compare-arrows", "Open git menu", () => {
      this.menuModal.open();
    });
  }
  addOpenInitModalCommand() {
    this.addCommand({
      id: "init",
      name: "Init repository",
      checkCallback: (checking) => {
        if (!this.settings.gitRemote) {
          if (!checking) {
            this.initRemoteModal.open();
          }
          return true;
        }
      }
    });
  }
  addOpenCommitModalCommand() {
    this.addCommand({
      id: "commit",
      name: "Commit changes",
      callback: () => {
        this.commitModal.open();
      }
    });
  }
  addSyncCommand() {
    this.addCommand({
      id: "sync",
      name: "Sync with remote repository",
      callback: () => {
        this.syncModal.open();
      }
    });
  }
  addStatusBarIndication() {
    const statusBarItemEl = this.addStatusBarItem();
    statusBarItemEl.setText("Git integration active");
    this.git.status();
  }
  addSettingsPage() {
    this.addSettingTab(new SettingsTab(this.app, this));
  }
  openDebugModal(content, mode = "DEBUG") {
    if (IS_DEBUG_MODE && content) {
      switch (mode) {
        case "ERROR": {
          new ErrorModal(this.app, content).open();
          break;
        }
        default: {
          new DebugModal(this.app, content).open();
        }
      }
    }
  }
  /**
   * Open vault base folder.
   */
  addOpenFolderRibbonIcon() {
    this.addRibbonIcon("folder-open", "Open folder in file explorer", () => {
      openFolder(getVaultPath(this.app));
    });
  }
  /**
   * Delete .git folder
   */
  addDeleteGitFolderRibbonIcon() {
    this.addRibbonIcon("trash", "Delete .git folder", () => {
      new DeleteGitFolderModal(this.app, () => {
        deleteGitFolder(getVaultPath(this.app));
        this.updateRemoteRepository();
      }).open();
    });
  }
  updateRemoteRepository(repo) {
    this.settings.gitRemote = repo != null ? repo : "";
    this.saveSettings();
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    const gitRemote = await this.git.getRemote();
    if (gitRemote && !this.settings.gitRemote) {
      this.updateRemoteRepository(gitRemote);
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzIiwgIm5vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsICJub2RlX21vZHVsZXMvQGt3c2l0ZXMvZmlsZS1leGlzdHMvc3JjL2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9Aa3dzaXRlcy9maWxlLWV4aXN0cy9pbmRleC50cyIsICJub2RlX21vZHVsZXMvQGt3c2l0ZXMvcHJvbWlzZS1kZWZlcnJlZC9zcmMvaW5kZXgudHMiLCAic3JjL21haW4udHMiLCAic3JjL2NvbXBvbmVudHMvZ2l0LWNvbW1pdC5tb2RhbC50cyIsICJzcmMvY29tcG9uZW50cy9naXQtaW5pdC5tb2RhbC50cyIsICJzcmMvY29tcG9uZW50cy9naXQtbWVudS5tb2RhbC50cyIsICJzcmMvY29tcG9uZW50cy9naXQtc3luYy5tb2RhbC50cyIsICJzcmMvY29uZmlnL2NvbmZpZy50cyIsICJzcmMvZGVidWcvZGVidWcubW9kYWwudHMiLCAic3JjL2RlYnVnL2RlbGV0ZS1naXQtZm9sZGVyLm1vZGFsLnRzIiwgInNyYy9kZWJ1Zy9lcnJvci5tb2RhbC50cyIsICJzcmMvZGVidWcvdXRpbHMvZGVsZXRlLWZvbGRlci50cyIsICJzcmMvZGVidWcvdXRpbHMvb3Blbi1mb2xkZXIudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9hcmdzL3BhdGhzcGVjLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvZXJyb3JzL2dpdC1lcnJvci50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL2Vycm9ycy9naXQtcmVzcG9uc2UtZXJyb3IudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9lcnJvcnMvdGFzay1jb25maWd1cmF0aW9uLWVycm9yLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdXRpbHMvdXRpbC50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3V0aWxzL2FyZ3VtZW50LWZpbHRlcnMudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi91dGlscy9leGl0LWNvZGVzLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdXRpbHMvZ2l0LW91dHB1dC1zdHJlYW1zLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdXRpbHMvbGluZS1wYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi91dGlscy9zaW1wbGUtZ2l0LW9wdGlvbnMudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi91dGlscy90YXNrLW9wdGlvbnMudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi91dGlscy90YXNrLXBhcnNlci50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3V0aWxzL2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvY2hlY2staXMtcmVwby50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Jlc3BvbnNlcy9DbGVhblN1bW1hcnkudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy90YXNrLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvY2xlYW4udHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9yZXNwb25zZXMvQ29uZmlnTGlzdC50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL2NvbmZpZy50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL2RpZmYtbmFtZS1zdGF0dXMudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9ncmVwLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvcmVzZXQudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9naXQtbG9nZ2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcnVubmVycy90YXNrcy1wZW5kaW5nLXF1ZXVlLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcnVubmVycy9naXQtZXhlY3V0b3ItY2hhaW4udHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9ydW5uZXJzL2dpdC1leGVjdXRvci50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2stY2FsbGJhY2sudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9jaGFuZ2Utd29ya2luZy1kaXJlY3RvcnkudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9jaGVja291dC50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BhcnNlcnMvcGFyc2UtY29tbWl0LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvY29tbWl0LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvZmlyc3QtY29tbWl0LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvaGFzaC1vYmplY3QudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9yZXNwb25zZXMvSW5pdFN1bW1hcnkudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9pbml0LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvYXJncy9sb2ctZm9ybWF0LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcmVzcG9uc2VzL0RpZmZTdW1tYXJ5LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcGFyc2Vycy9wYXJzZS1kaWZmLXN1bW1hcnkudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9wYXJzZXJzL3BhcnNlLWxpc3QtbG9nLXN1bW1hcnkudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9kaWZmLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvbG9nLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcmVzcG9uc2VzL01lcmdlU3VtbWFyeS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Jlc3BvbnNlcy9QdWxsU3VtbWFyeS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BhcnNlcnMvcGFyc2UtcmVtb3RlLW9iamVjdHMudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9wYXJzZXJzL3BhcnNlLXJlbW90ZS1tZXNzYWdlcy50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BhcnNlcnMvcGFyc2UtcHVsbC50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BhcnNlcnMvcGFyc2UtbWVyZ2UudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9tZXJnZS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BhcnNlcnMvcGFyc2UtcHVzaC50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL3B1c2gudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9zaG93LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcmVzcG9uc2VzL0ZpbGVTdGF0dXNTdW1tYXJ5LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcmVzcG9uc2VzL1N0YXR1c1N1bW1hcnkudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9zdGF0dXMudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy92ZXJzaW9uLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvc2ltcGxlLWdpdC1hcGkudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9ydW5uZXJzL3NjaGVkdWxlci50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL2FwcGx5LXBhdGNoLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcmVzcG9uc2VzL0JyYW5jaERlbGV0ZVN1bW1hcnkudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9wYXJzZXJzL3BhcnNlLWJyYW5jaC1kZWxldGUudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9yZXNwb25zZXMvQnJhbmNoU3VtbWFyeS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BhcnNlcnMvcGFyc2UtYnJhbmNoLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvYnJhbmNoLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcmVzcG9uc2VzL0NoZWNrSWdub3JlLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvY2hlY2staWdub3JlLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvY2xvbmUudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9wYXJzZXJzL3BhcnNlLWZldGNoLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvZmV0Y2gudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9wYXJzZXJzL3BhcnNlLW1vdmUudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9tb3ZlLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvcHVsbC50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Jlc3BvbnNlcy9HZXRSZW1vdGVTdW1tYXJ5LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvcmVtb3RlLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3Mvc3Rhc2gtbGlzdC50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL3N1Yi1tb2R1bGUudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9yZXNwb25zZXMvVGFnTGlzdC50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL3RhZy50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvZ2l0LmpzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvYXBpLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvZXJyb3JzL2dpdC1jb25zdHJ1Y3QtZXJyb3IudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9lcnJvcnMvZ2l0LXBsdWdpbi1lcnJvci50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BsdWdpbnMvYWJvcnQtcGx1Z2luLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcGx1Z2lucy9ibG9jay11bnNhZmUtb3BlcmF0aW9ucy1wbHVnaW4udHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9wbHVnaW5zL2NvbW1hbmQtY29uZmlnLXByZWZpeGluZy1wbHVnaW4udHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9wbHVnaW5zL2NvbXBsZXRpb24tZGV0ZWN0aW9uLnBsdWdpbi50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BsdWdpbnMvZXJyb3ItZGV0ZWN0aW9uLnBsdWdpbi50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BsdWdpbnMvcGx1Z2luLXN0b3JlLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcGx1Z2lucy9wcm9ncmVzcy1tb25pdG9yLXBsdWdpbi50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BsdWdpbnMvc3Bhd24tb3B0aW9ucy1wbHVnaW4udHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9wbHVnaW5zL3RpbW91dC1wbHVnaW4udHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9wbHVnaW5zL3N1ZmZpeC1wYXRocy5wbHVnaW4udHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9naXQtZmFjdG9yeS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3J1bm5lcnMvcHJvbWlzZS13cmFwcGVkLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9lc20ubWpzIiwgInNyYy9naXQvZ2l0LnRzIiwgInNyYy9zZXR0aW5ncy10YWIudHMiLCAic3JjL3V0aWxzL3V0aWxzLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHcgPSBkICogNztcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsKSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oLT8oPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHdlZWtzP3x3fHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICd3ZWVrcyc6XG4gICAgY2FzZSAnd2Vlayc6XG4gICAgY2FzZSAndyc6XG4gICAgICByZXR1cm4gbiAqIHc7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGQsICdkYXknKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBoLCAnaG91cicpO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIG0sICdtaW51dGUnKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBzLCAnc2Vjb25kJyk7XG4gIH1cbiAgcmV0dXJuIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBtc0FicywgbiwgbmFtZSkge1xuICB2YXIgaXNQbHVyYWwgPSBtc0FicyA+PSBuICogMS41O1xuICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG4pICsgJyAnICsgbmFtZSArIChpc1BsdXJhbCA/ICdzJyA6ICcnKTtcbn1cbiIsICJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5mdW5jdGlvbiBzZXR1cChlbnYpIHtcblx0Y3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuZGVmYXVsdCA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5jb2VyY2UgPSBjb2VyY2U7XG5cdGNyZWF0ZURlYnVnLmRpc2FibGUgPSBkaXNhYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGUgPSBlbmFibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZWQgPSBlbmFibGVkO1xuXHRjcmVhdGVEZWJ1Zy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cdGNyZWF0ZURlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuXG5cdE9iamVjdC5rZXlzKGVudikuZm9yRWFjaChrZXkgPT4ge1xuXHRcdGNyZWF0ZURlYnVnW2tleV0gPSBlbnZba2V5XTtcblx0fSk7XG5cblx0LyoqXG5cdCogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG5cdCovXG5cblx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHQvKipcblx0KiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG5cdCpcblx0KiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG5cdCovXG5cdGNyZWF0ZURlYnVnLmZvcm1hdHRlcnMgPSB7fTtcblxuXHQvKipcblx0KiBTZWxlY3RzIGEgY29sb3IgZm9yIGEgZGVidWcgbmFtZXNwYWNlXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBUaGUgbmFtZXNwYWNlIHN0cmluZyBmb3IgdGhlIGRlYnVnIGluc3RhbmNlIHRvIGJlIGNvbG9yZWRcblx0KiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfSBBbiBBTlNJIGNvbG9yIGNvZGUgZm9yIHRoZSBnaXZlbiBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG5cdFx0bGV0IGhhc2ggPSAwO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0aGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcblx0XHR9XG5cblx0XHRyZXR1cm4gY3JlYXRlRGVidWcuY29sb3JzW01hdGguYWJzKGhhc2gpICUgY3JlYXRlRGVidWcuY29sb3JzLmxlbmd0aF07XG5cdH1cblx0Y3JlYXRlRGVidWcuc2VsZWN0Q29sb3IgPSBzZWxlY3RDb2xvcjtcblxuXHQvKipcblx0KiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblx0XHRsZXQgcHJldlRpbWU7XG5cdFx0bGV0IGVuYWJsZU92ZXJyaWRlID0gbnVsbDtcblx0XHRsZXQgbmFtZXNwYWNlc0NhY2hlO1xuXHRcdGxldCBlbmFibGVkQ2FjaGU7XG5cblx0XHRmdW5jdGlvbiBkZWJ1ZyguLi5hcmdzKSB7XG5cdFx0XHQvLyBEaXNhYmxlZD9cblx0XHRcdGlmICghZGVidWcuZW5hYmxlZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNlbGYgPSBkZWJ1ZztcblxuXHRcdFx0Ly8gU2V0IGBkaWZmYCB0aW1lc3RhbXBcblx0XHRcdGNvbnN0IGN1cnIgPSBOdW1iZXIobmV3IERhdGUoKSk7XG5cdFx0XHRjb25zdCBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG5cdFx0XHRzZWxmLmRpZmYgPSBtcztcblx0XHRcdHNlbGYucHJldiA9IHByZXZUaW1lO1xuXHRcdFx0c2VsZi5jdXJyID0gY3Vycjtcblx0XHRcdHByZXZUaW1lID0gY3VycjtcblxuXHRcdFx0YXJnc1swXSA9IGNyZWF0ZURlYnVnLmNvZXJjZShhcmdzWzBdKTtcblxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzWzBdICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHQvLyBBbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuXHRcdFx0XHRhcmdzLnVuc2hpZnQoJyVPJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG5cdFx0XHRsZXQgaW5kZXggPSAwO1xuXHRcdFx0YXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIChtYXRjaCwgZm9ybWF0KSA9PiB7XG5cdFx0XHRcdC8vIElmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcblx0XHRcdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRcdFx0cmV0dXJuICclJztcblx0XHRcdFx0fVxuXHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRjb25zdCBmb3JtYXR0ZXIgPSBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG5cdFx0XHRcdGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0Y29uc3QgdmFsID0gYXJnc1tpbmRleF07XG5cdFx0XHRcdFx0bWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG5cdFx0XHRcdFx0Ly8gTm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuXHRcdFx0XHRcdGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdFx0XHRpbmRleC0tO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaDtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBBcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuXHRcdFx0Y3JlYXRlRGVidWcuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG5cdFx0XHRjb25zdCBsb2dGbiA9IHNlbGYubG9nIHx8IGNyZWF0ZURlYnVnLmxvZztcblx0XHRcdGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXHRcdH1cblxuXHRcdGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblx0XHRkZWJ1Zy51c2VDb2xvcnMgPSBjcmVhdGVEZWJ1Zy51c2VDb2xvcnMoKTtcblx0XHRkZWJ1Zy5jb2xvciA9IGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG5cdFx0ZGVidWcuZXh0ZW5kID0gZXh0ZW5kO1xuXHRcdGRlYnVnLmRlc3Ryb3kgPSBjcmVhdGVEZWJ1Zy5kZXN0cm95OyAvLyBYWFggVGVtcG9yYXJ5LiBXaWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZWJ1ZywgJ2VuYWJsZWQnLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcblx0XHRcdGdldDogKCkgPT4ge1xuXHRcdFx0XHRpZiAoZW5hYmxlT3ZlcnJpZGUgIT09IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm4gZW5hYmxlT3ZlcnJpZGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG5hbWVzcGFjZXNDYWNoZSAhPT0gY3JlYXRlRGVidWcubmFtZXNwYWNlcykge1xuXHRcdFx0XHRcdG5hbWVzcGFjZXNDYWNoZSA9IGNyZWF0ZURlYnVnLm5hbWVzcGFjZXM7XG5cdFx0XHRcdFx0ZW5hYmxlZENhY2hlID0gY3JlYXRlRGVidWcuZW5hYmxlZChuYW1lc3BhY2UpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVuYWJsZWRDYWNoZTtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IHYgPT4ge1xuXHRcdFx0XHRlbmFibGVPdmVycmlkZSA9IHY7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBFbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuXHRcdGlmICh0eXBlb2YgY3JlYXRlRGVidWcuaW5pdCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Y3JlYXRlRGVidWcuaW5pdChkZWJ1Zyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRlYnVnO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXh0ZW5kKG5hbWVzcGFjZSwgZGVsaW1pdGVyKSB7XG5cdFx0Y29uc3QgbmV3RGVidWcgPSBjcmVhdGVEZWJ1Zyh0aGlzLm5hbWVzcGFjZSArICh0eXBlb2YgZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/ICc6JyA6IGRlbGltaXRlcikgKyBuYW1lc3BhY2UpO1xuXHRcdG5ld0RlYnVnLmxvZyA9IHRoaXMubG9nO1xuXHRcdHJldHVybiBuZXdEZWJ1Zztcblx0fVxuXG5cdC8qKlxuXHQqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcblx0KiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuXHRcdGNyZWF0ZURlYnVnLnNhdmUobmFtZXNwYWNlcyk7XG5cdFx0Y3JlYXRlRGVidWcubmFtZXNwYWNlcyA9IG5hbWVzcGFjZXM7XG5cblx0XHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRcdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0XHRsZXQgaTtcblx0XHRjb25zdCBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG5cdFx0Y29uc3QgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoIXNwbGl0W2ldKSB7XG5cdFx0XHRcdC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcblxuXHRcdFx0aWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zbGljZSgxKSArICckJykpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0KiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cblx0KlxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGRpc2FibGUoKSB7XG5cdFx0Y29uc3QgbmFtZXNwYWNlcyA9IFtcblx0XHRcdC4uLmNyZWF0ZURlYnVnLm5hbWVzLm1hcCh0b05hbWVzcGFjZSksXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5za2lwcy5tYXAodG9OYW1lc3BhY2UpLm1hcChuYW1lc3BhY2UgPT4gJy0nICsgbmFtZXNwYWNlKVxuXHRcdF0uam9pbignLCcpO1xuXHRcdGNyZWF0ZURlYnVnLmVuYWJsZSgnJyk7XG5cdFx0cmV0dXJuIG5hbWVzcGFjZXM7XG5cdH1cblxuXHQvKipcblx0KiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuXHQqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG5cdFx0aWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRsZXQgaTtcblx0XHRsZXQgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCogQ29udmVydCByZWdleHAgdG8gbmFtZXNwYWNlXG5cdCpcblx0KiBAcGFyYW0ge1JlZ0V4cH0gcmVneGVwXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gdG9OYW1lc3BhY2UocmVnZXhwKSB7XG5cdFx0cmV0dXJuIHJlZ2V4cC50b1N0cmluZygpXG5cdFx0XHQuc3Vic3RyaW5nKDIsIHJlZ2V4cC50b1N0cmluZygpLmxlbmd0aCAtIDIpXG5cdFx0XHQucmVwbGFjZSgvXFwuXFwqXFw/JC8sICcqJyk7XG5cdH1cblxuXHQvKipcblx0KiBDb2VyY2UgYHZhbGAuXG5cdCpcblx0KiBAcGFyYW0ge01peGVkfSB2YWxcblx0KiBAcmV0dXJuIHtNaXhlZH1cblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuXHRcdGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdFx0cmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxuXG5cdC8qKlxuXHQqIFhYWCBETyBOT1QgVVNFLiBUaGlzIGlzIGEgdGVtcG9yYXJ5IHN0dWIgZnVuY3Rpb24uXG5cdCogWFhYIEl0IFdJTEwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXHQqL1xuXHRmdW5jdGlvbiBkZXN0cm95KCkge1xuXHRcdGNvbnNvbGUud2FybignSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLicpO1xuXHR9XG5cblx0Y3JlYXRlRGVidWcuZW5hYmxlKGNyZWF0ZURlYnVnLmxvYWQoKSk7XG5cblx0cmV0dXJuIGNyZWF0ZURlYnVnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldHVwO1xuIiwgIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuZXhwb3J0cy5kZXN0cm95ID0gKCgpID0+IHtcblx0bGV0IHdhcm5lZCA9IGZhbHNlO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKCF3YXJuZWQpIHtcblx0XHRcdHdhcm5lZCA9IHRydWU7XG5cdFx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0XHR9XG5cdH07XG59KSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcblx0JyMwMDAwQ0MnLFxuXHQnIzAwMDBGRicsXG5cdCcjMDAzM0NDJyxcblx0JyMwMDMzRkYnLFxuXHQnIzAwNjZDQycsXG5cdCcjMDA2NkZGJyxcblx0JyMwMDk5Q0MnLFxuXHQnIzAwOTlGRicsXG5cdCcjMDBDQzAwJyxcblx0JyMwMENDMzMnLFxuXHQnIzAwQ0M2NicsXG5cdCcjMDBDQzk5Jyxcblx0JyMwMENDQ0MnLFxuXHQnIzAwQ0NGRicsXG5cdCcjMzMwMENDJyxcblx0JyMzMzAwRkYnLFxuXHQnIzMzMzNDQycsXG5cdCcjMzMzM0ZGJyxcblx0JyMzMzY2Q0MnLFxuXHQnIzMzNjZGRicsXG5cdCcjMzM5OUNDJyxcblx0JyMzMzk5RkYnLFxuXHQnIzMzQ0MwMCcsXG5cdCcjMzNDQzMzJyxcblx0JyMzM0NDNjYnLFxuXHQnIzMzQ0M5OScsXG5cdCcjMzNDQ0NDJyxcblx0JyMzM0NDRkYnLFxuXHQnIzY2MDBDQycsXG5cdCcjNjYwMEZGJyxcblx0JyM2NjMzQ0MnLFxuXHQnIzY2MzNGRicsXG5cdCcjNjZDQzAwJyxcblx0JyM2NkNDMzMnLFxuXHQnIzk5MDBDQycsXG5cdCcjOTkwMEZGJyxcblx0JyM5OTMzQ0MnLFxuXHQnIzk5MzNGRicsXG5cdCcjOTlDQzAwJyxcblx0JyM5OUNDMzMnLFxuXHQnI0NDMDAwMCcsXG5cdCcjQ0MwMDMzJyxcblx0JyNDQzAwNjYnLFxuXHQnI0NDMDA5OScsXG5cdCcjQ0MwMENDJyxcblx0JyNDQzAwRkYnLFxuXHQnI0NDMzMwMCcsXG5cdCcjQ0MzMzMzJyxcblx0JyNDQzMzNjYnLFxuXHQnI0NDMzM5OScsXG5cdCcjQ0MzM0NDJyxcblx0JyNDQzMzRkYnLFxuXHQnI0NDNjYwMCcsXG5cdCcjQ0M2NjMzJyxcblx0JyNDQzk5MDAnLFxuXHQnI0NDOTkzMycsXG5cdCcjQ0NDQzAwJyxcblx0JyNDQ0NDMzMnLFxuXHQnI0ZGMDAwMCcsXG5cdCcjRkYwMDMzJyxcblx0JyNGRjAwNjYnLFxuXHQnI0ZGMDA5OScsXG5cdCcjRkYwMENDJyxcblx0JyNGRjAwRkYnLFxuXHQnI0ZGMzMwMCcsXG5cdCcjRkYzMzMzJyxcblx0JyNGRjMzNjYnLFxuXHQnI0ZGMzM5OScsXG5cdCcjRkYzM0NDJyxcblx0JyNGRjMzRkYnLFxuXHQnI0ZGNjYwMCcsXG5cdCcjRkY2NjMzJyxcblx0JyNGRjk5MDAnLFxuXHQnI0ZGOTkzMycsXG5cdCcjRkZDQzAwJyxcblx0JyNGRkNDMzMnXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG5cdC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcblx0Ly8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2Vcblx0Ly8gZXhwbGljaXRseVxuXHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgKHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicgfHwgd2luZG93LnByb2Nlc3MuX19ud2pzKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuXHRpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvLyBJcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuXHQvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuXHRyZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcblx0XHQvLyBJcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG5cdFx0KHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcblx0XHQvLyBJcyBmaXJlZm94ID49IHYzMT9cblx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcblx0XHQvLyBEb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcblx0YXJnc1swXSA9ICh0aGlzLnVzZUNvbG9ycyA/ICclYycgOiAnJykgK1xuXHRcdHRoaXMubmFtZXNwYWNlICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnICVjJyA6ICcgJykgK1xuXHRcdGFyZ3NbMF0gK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICclYyAnIDogJyAnKSArXG5cdFx0JysnICsgbW9kdWxlLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuXHRpZiAoIXRoaXMudXNlQ29sb3JzKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Y29uc3QgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG5cdGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpO1xuXG5cdC8vIFRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG5cdC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cblx0Ly8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG5cdGxldCBpbmRleCA9IDA7XG5cdGxldCBsYXN0QyA9IDA7XG5cdGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBtYXRjaCA9PiB7XG5cdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGluZGV4Kys7XG5cdFx0aWYgKG1hdGNoID09PSAnJWMnKSB7XG5cdFx0XHQvLyBXZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcblx0XHRcdC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG5cdFx0XHRsYXN0QyA9IGluZGV4O1xuXHRcdH1cblx0fSk7XG5cblx0YXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUuZGVidWcoKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKiBJZiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGF2YWlsYWJsZSwgZmFsbHMgYmFja1xuICogdG8gYGNvbnNvbGUubG9nYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5leHBvcnRzLmxvZyA9IGNvbnNvbGUuZGVidWcgfHwgY29uc29sZS5sb2cgfHwgKCgpID0+IHt9KTtcblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuXHR0cnkge1xuXHRcdGlmIChuYW1lc3BhY2VzKSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2Uuc2V0SXRlbSgnZGVidWcnLCBuYW1lc3BhY2VzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBsb2FkKCkge1xuXHRsZXQgcjtcblx0dHJ5IHtcblx0XHRyID0gZXhwb3J0cy5zdG9yYWdlLmdldEl0ZW0oJ2RlYnVnJyk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG5cblx0Ly8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuXHRpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcblx0XHRyID0gcHJvY2Vzcy5lbnYuREVCVUc7XG5cdH1cblxuXHRyZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG5cdHRyeSB7XG5cdFx0Ly8gVFZNTEtpdCAoQXBwbGUgVFYgSlMgUnVudGltZSkgZG9lcyBub3QgaGF2ZSBhIHdpbmRvdyBvYmplY3QsIGp1c3QgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dFxuXHRcdC8vIFRoZSBCcm93c2VyIGFsc28gaGFzIGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHQuXG5cdFx0cmV0dXJuIGxvY2FsU3RvcmFnZTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbW1vbicpKGV4cG9ydHMpO1xuXG5jb25zdCB7Zm9ybWF0dGVyc30gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24gKHYpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0cmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVycm9yLm1lc3NhZ2U7XG5cdH1cbn07XG4iLCBudWxsLCBudWxsLCBudWxsLCAiaW1wb3J0IHsgTm90aWNlLCBQbHVnaW4gfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHsgQ29tbWl0UmVzdWx0LCBQdXNoUmVzdWx0IH0gZnJvbSBcInNpbXBsZS1naXRcIjtcclxuaW1wb3J0IHsgR2l0Q29tbWl0TW9kYWwgfSBmcm9tIFwiLi9jb21wb25lbnRzL2dpdC1jb21taXQubW9kYWxcIjtcclxuaW1wb3J0IHsgR2l0SW5pdFJlbW90ZSB9IGZyb20gXCIuL2NvbXBvbmVudHMvZ2l0LWluaXQubW9kYWxcIjtcclxuaW1wb3J0IHsgR2l0TWVudU1vZGFsIH0gZnJvbSBcIi4vY29tcG9uZW50cy9naXQtbWVudS5tb2RhbFwiO1xyXG5pbXBvcnQgeyBHaXRTeW5jTW9kYWwgfSBmcm9tIFwiLi9jb21wb25lbnRzL2dpdC1zeW5jLm1vZGFsXCI7XHJcbmltcG9ydCB7IERFRkFVTFRfU0VUVElOR1MsIElTX0RFQlVHX01PREUgfSBmcm9tIFwiLi9jb25maWcvY29uZmlnXCI7XHJcbmltcG9ydCB7IEdpdFBsdWdpblNldHRpbmdzIH0gZnJvbSBcIi4vY29uZmlnL3BsdWdpbi1zZXR0aW5ncy5tb2RlbFwiO1xyXG5pbXBvcnQgeyBEZWJ1Z01vZGFsIH0gZnJvbSBcIi4vZGVidWcvZGVidWcubW9kYWxcIjtcclxuaW1wb3J0IHsgRGVsZXRlR2l0Rm9sZGVyTW9kYWwgfSBmcm9tIFwiLi9kZWJ1Zy9kZWxldGUtZ2l0LWZvbGRlci5tb2RhbFwiO1xyXG5pbXBvcnQgeyBFcnJvck1vZGFsIH0gZnJvbSBcIi4vZGVidWcvZXJyb3IubW9kYWxcIjtcclxuaW1wb3J0IHsgZGVsZXRlR2l0Rm9sZGVyIH0gZnJvbSBcIi4vZGVidWcvdXRpbHMvZGVsZXRlLWZvbGRlclwiO1xyXG5pbXBvcnQgeyBvcGVuRm9sZGVyIH0gZnJvbSBcIi4vZGVidWcvdXRpbHMvb3Blbi1mb2xkZXJcIjtcclxuaW1wb3J0IHsgR2l0IH0gZnJvbSBcIi4vZ2l0L2dpdFwiO1xyXG5pbXBvcnQgeyBTZXR0aW5nc1RhYiB9IGZyb20gXCIuL3NldHRpbmdzLXRhYlwiO1xyXG5pbXBvcnQgeyBnZXRWYXVsdFBhdGggfSBmcm9tIFwiLi91dGlscy91dGlsc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2l0UGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcclxuICBzZXR0aW5nczogR2l0UGx1Z2luU2V0dGluZ3M7XHJcbiAgZ2l0OiBHaXQ7XHJcblxyXG4gIGdldCBtZW51TW9kYWwoKTogR2l0TWVudU1vZGFsIHtcclxuICAgIHJldHVybiBuZXcgR2l0TWVudU1vZGFsKFxyXG4gICAgICB0aGlzLmFwcCxcclxuICAgICAgdGhpcy5zZXR0aW5ncy5naXRSZW1vdGUgPyBudWxsIDogdGhpcy5pbml0UmVtb3RlTW9kYWwsXHJcbiAgICAgIHRoaXMuY29tbWl0TW9kYWwsXHJcbiAgICAgIHRoaXMuc3luY01vZGFsXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGluaXRSZW1vdGVNb2RhbCgpOiBHaXRJbml0UmVtb3RlIHtcclxuICAgIHJldHVybiBuZXcgR2l0SW5pdFJlbW90ZSh0aGlzLmFwcCwgKHJlcG86IHN0cmluZykgPT4ge1xyXG4gICAgICB0aGlzLmdpdFxyXG4gICAgICAgIC5hZGRSZW1vdGUocmVwbylcclxuICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICBuZXcgTm90aWNlKGBBZGRlZCByZW1vdGUgb3JpZ2luIFwiJHtyZXBvfVwiYCk7XHJcbiAgICAgICAgICB0aGlzLnVwZGF0ZVJlbW90ZVJlcG9zaXRvcnkocmVwbyk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuY2F0Y2goKGVycikgPT4gbmV3IE5vdGljZShlcnIpKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGNvbW1pdE1vZGFsKCk6IEdpdENvbW1pdE1vZGFsIHtcclxuICAgIHJldHVybiBuZXcgR2l0Q29tbWl0TW9kYWwodGhpcy5hcHAsIChtc2c6IHN0cmluZywgc3luYzogYm9vbGVhbikgPT4ge1xyXG4gICAgICBpZiAoc3luYykge1xyXG4gICAgICAgIHRoaXMuZ2l0XHJcbiAgICAgICAgICAuYWRkQWxsQW5kQ29tbWl0QW5kUHVzaChtc2cpXHJcbiAgICAgICAgICAudGhlbigocmVzOiBQdXNoUmVzdWx0IHwgbnVsbCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgcmVzICYmXHJcbiAgICAgICAgICAgICAgKHJlcy51cGRhdGUgfHxcclxuICAgICAgICAgICAgICAgIChyZXMucHVzaGVkLmxlbmd0aCA+IDAgJiYgcmVzLnB1c2hlZFswXS5uZXcgPT09IHRydWUpKVxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICBuZXcgTm90aWNlKGBDb21taXR0ZWQgYW5kIHB1c2hlZCBuZXcgY2hhbmdlcyB0byByZW1vdGUgYnJhbmNoYCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgbmV3IE5vdGljZShgTm8gY2hhbmdlcyB0byBjb21taXRgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSlcclxuICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiBuZXcgTm90aWNlKGVycikpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuZ2l0XHJcbiAgICAgICAgICAuYWRkQWxsQW5kQ29tbWl0KG1zZylcclxuICAgICAgICAgIC50aGVuKChyZXM6IENvbW1pdFJlc3VsdCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAocmVzLmNvbW1pdCkge1xyXG4gICAgICAgICAgICAgIG5ldyBOb3RpY2UoYENvbW1pdHRlZCBcIiR7bXNnfVwiYCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgbmV3IE5vdGljZShgTm8gY2hhbmdlcyB0byBjb21taXRgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSlcclxuICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiBuZXcgTm90aWNlKGVycikpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGdldCBzeW5jTW9kYWwoKTogR2l0U3luY01vZGFsIHtcclxuICAgIHJldHVybiBuZXcgR2l0U3luY01vZGFsKHRoaXMuYXBwLCAoKSA9PiB7XHJcbiAgICAgIC8vIHRoaXMgc3luYyB3aWxsIHRha2UgYSB3aGlsZVxyXG4gICAgICB0aGlzLmdpdFxyXG4gICAgICAgIC5wdXNoKClcclxuICAgICAgICAudGhlbigocmVzKSA9PiB7XHJcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhyZXMpO1xyXG4gICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICByZXMudXBkYXRlIHx8XHJcbiAgICAgICAgICAgIChyZXMucHVzaGVkLmxlbmd0aCA+IDAgJiYgcmVzLnB1c2hlZFswXS5uZXcgPT09IHRydWUpXHJcbiAgICAgICAgICApIHtcclxuICAgICAgICAgICAgbmV3IE5vdGljZShgUHVzaGVkIG5ldyBjaGFuZ2VzIHRvIHJlbW90ZSBicmFuY2hgKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJObyBjaGFuZ2VzIHRvIHB1c2hcIik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xyXG4gICAgICAgICAgdGhpcy5vcGVuRGVidWdNb2RhbChlcnIsIFwiRVJST1JcIik7XHJcbiAgICAgICAgICBuZXcgTm90aWNlKGVycik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIC8vIHRoaXMuZ2l0XHJcbiAgICAgIC8vICAgLnB1bGwoKVxyXG4gICAgICAvLyAgIC50aGVuKCgpID0+IHtcclxuICAgICAgLy8gICAgIHRoaXMuZ2l0LnB1c2goKTtcclxuICAgICAgLy8gICAgIG5ldyBOb3RpY2UoYFN5bmNlZCB3aXRoIHJlbW90ZSBicmFuY2hgKTtcclxuICAgICAgLy8gICB9KVxyXG4gICAgICAvLyAgIC5jYXRjaCgoZXJyOiBzdHJpbmcpID0+IHtcclxuICAgICAgLy8gICAgIHRoaXMub3BlbkRlYnVnTW9kYWwoZXJyLCBcIkVSUk9SXCIpO1xyXG4gICAgICAvLyAgICAgbmV3IE5vdGljZShlcnIpO1xyXG4gICAgICAvLyAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBvbmxvYWQoKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICB0aGlzLmdpdCA9IG5ldyBHaXQoZ2V0VmF1bHRQYXRoKHRoaXMuYXBwKSk7XHJcblxyXG4gICAgICBhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xyXG5cclxuICAgICAgdGhpcy5hZGRTZXR0aW5nc1BhZ2UoKTtcclxuICAgICAgdGhpcy5hZGRNZW51UmliYm9uSWNvbigpO1xyXG4gICAgICB0aGlzLmFkZE9wZW5Jbml0TW9kYWxDb21tYW5kKCk7XHJcbiAgICAgIHRoaXMuYWRkU3luY0NvbW1hbmQoKTtcclxuICAgICAgdGhpcy5hZGRPcGVuQ29tbWl0TW9kYWxDb21tYW5kKCk7XHJcbiAgICAgIHRoaXMuYWRkU3RhdHVzQmFySW5kaWNhdGlvbigpO1xyXG5cclxuICAgICAgaWYgKElTX0RFQlVHX01PREUpIHtcclxuICAgICAgICB0aGlzLmFkZE9wZW5Gb2xkZXJSaWJib25JY29uKCk7XHJcbiAgICAgICAgdGhpcy5hZGREZWxldGVHaXRGb2xkZXJSaWJib25JY29uKCk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICB0aGlzLm9wZW5EZWJ1Z01vZGFsKGVyciwgXCJFUlJPUlwiKTtcclxuICAgICAgbmV3IE5vdGljZShlcnIpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYWRkTWVudVJpYmJvbkljb24oKTogdm9pZCB7XHJcbiAgICB0aGlzLmFkZFJpYmJvbkljb24oXCJnaXQtY29tcGFyZS1hcnJvd3NcIiwgXCJPcGVuIGdpdCBtZW51XCIsICgpID0+IHtcclxuICAgICAgdGhpcy5tZW51TW9kYWwub3BlbigpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBhZGRPcGVuSW5pdE1vZGFsQ29tbWFuZCgpOiB2b2lkIHtcclxuICAgIHRoaXMuYWRkQ29tbWFuZCh7XHJcbiAgICAgIGlkOiBcImluaXRcIixcclxuICAgICAgbmFtZTogXCJJbml0IHJlcG9zaXRvcnlcIixcclxuICAgICAgY2hlY2tDYWxsYmFjazogKGNoZWNraW5nOiBib29sZWFuKSA9PiB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLmdpdFJlbW90ZSkge1xyXG4gICAgICAgICAgaWYgKCFjaGVja2luZykge1xyXG4gICAgICAgICAgICB0aGlzLmluaXRSZW1vdGVNb2RhbC5vcGVuKCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBhZGRPcGVuQ29tbWl0TW9kYWxDb21tYW5kKCk6IHZvaWQge1xyXG4gICAgdGhpcy5hZGRDb21tYW5kKHtcclxuICAgICAgaWQ6IFwiY29tbWl0XCIsXHJcbiAgICAgIG5hbWU6IFwiQ29tbWl0IGNoYW5nZXNcIixcclxuICAgICAgY2FsbGJhY2s6ICgpID0+IHtcclxuICAgICAgICB0aGlzLmNvbW1pdE1vZGFsLm9wZW4oKTtcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgYWRkU3luY0NvbW1hbmQoKTogdm9pZCB7XHJcbiAgICB0aGlzLmFkZENvbW1hbmQoe1xyXG4gICAgICBpZDogXCJzeW5jXCIsXHJcbiAgICAgIG5hbWU6IFwiU3luYyB3aXRoIHJlbW90ZSByZXBvc2l0b3J5XCIsXHJcbiAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5zeW5jTW9kYWwub3BlbigpO1xyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBhZGRTdGF0dXNCYXJJbmRpY2F0aW9uKCk6IHZvaWQge1xyXG4gICAgLy8gVGhpcyBhZGRzIGEgc3RhdHVzIGJhciBpdGVtIHRvIHRoZSBib3R0b20gb2YgdGhlIGFwcC4gRG9lcyBub3Qgd29yayBvbiBtb2JpbGUgYXBwcy5cclxuICAgIGNvbnN0IHN0YXR1c0Jhckl0ZW1FbCA9IHRoaXMuYWRkU3RhdHVzQmFySXRlbSgpO1xyXG4gICAgc3RhdHVzQmFySXRlbUVsLnNldFRleHQoXCJHaXQgaW50ZWdyYXRpb24gYWN0aXZlXCIpO1xyXG4gICAgdGhpcy5naXQuc3RhdHVzKCk7XHJcbiAgfVxyXG5cclxuICBhZGRTZXR0aW5nc1BhZ2UoKTogdm9pZCB7XHJcbiAgICB0aGlzLmFkZFNldHRpbmdUYWIobmV3IFNldHRpbmdzVGFiKHRoaXMuYXBwLCB0aGlzKSk7XHJcbiAgfVxyXG5cclxuICBvcGVuRGVidWdNb2RhbChcclxuICAgIGNvbnRlbnQ6IHN0cmluZyB8IG51bGwsXHJcbiAgICBtb2RlOiBcIkVSUk9SXCIgfCBcIkRFQlVHXCIgPSBcIkRFQlVHXCJcclxuICApOiB2b2lkIHtcclxuICAgIGlmIChJU19ERUJVR19NT0RFICYmIGNvbnRlbnQpIHtcclxuICAgICAgc3dpdGNoIChtb2RlKSB7XHJcbiAgICAgICAgY2FzZSBcIkVSUk9SXCI6IHtcclxuICAgICAgICAgIG5ldyBFcnJvck1vZGFsKHRoaXMuYXBwLCBjb250ZW50KS5vcGVuKCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVmYXVsdDoge1xyXG4gICAgICAgICAgbmV3IERlYnVnTW9kYWwodGhpcy5hcHAsIGNvbnRlbnQpLm9wZW4oKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE9wZW4gdmF1bHQgYmFzZSBmb2xkZXIuXHJcbiAgICovXHJcbiAgYWRkT3BlbkZvbGRlclJpYmJvbkljb24oKTogdm9pZCB7XHJcbiAgICB0aGlzLmFkZFJpYmJvbkljb24oXCJmb2xkZXItb3BlblwiLCBcIk9wZW4gZm9sZGVyIGluIGZpbGUgZXhwbG9yZXJcIiwgKCkgPT4ge1xyXG4gICAgICBvcGVuRm9sZGVyKGdldFZhdWx0UGF0aCh0aGlzLmFwcCkpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZWxldGUgLmdpdCBmb2xkZXJcclxuICAgKi9cclxuICBhZGREZWxldGVHaXRGb2xkZXJSaWJib25JY29uKCk6IHZvaWQge1xyXG4gICAgdGhpcy5hZGRSaWJib25JY29uKFwidHJhc2hcIiwgXCJEZWxldGUgLmdpdCBmb2xkZXJcIiwgKCkgPT4ge1xyXG4gICAgICBuZXcgRGVsZXRlR2l0Rm9sZGVyTW9kYWwodGhpcy5hcHAsICgpID0+IHtcclxuICAgICAgICBkZWxldGVHaXRGb2xkZXIoZ2V0VmF1bHRQYXRoKHRoaXMuYXBwKSk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVSZW1vdGVSZXBvc2l0b3J5KCk7XHJcbiAgICAgIH0pLm9wZW4oKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlUmVtb3RlUmVwb3NpdG9yeShyZXBvPzogc3RyaW5nIHwgbnVsbCk6IHZvaWQge1xyXG4gICAgdGhpcy5zZXR0aW5ncy5naXRSZW1vdGUgPSByZXBvID8/IFwiXCI7XHJcbiAgICB0aGlzLnNhdmVTZXR0aW5ncygpO1xyXG4gIH1cclxuXHJcbiAgb251bmxvYWQoKSB7fVxyXG5cclxuICBhc3luYyBsb2FkU2V0dGluZ3MoKSB7XHJcbiAgICB0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9TRVRUSU5HUywgYXdhaXQgdGhpcy5sb2FkRGF0YSgpKTtcclxuXHJcbiAgICBjb25zdCBnaXRSZW1vdGUgPSBhd2FpdCB0aGlzLmdpdC5nZXRSZW1vdGUoKTtcclxuICAgIGlmIChnaXRSZW1vdGUgJiYgIXRoaXMuc2V0dGluZ3MuZ2l0UmVtb3RlKSB7XHJcbiAgICAgIHRoaXMudXBkYXRlUmVtb3RlUmVwb3NpdG9yeShnaXRSZW1vdGUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgc2F2ZVNldHRpbmdzKCkge1xyXG4gICAgYXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcclxuICB9XHJcbn1cclxuIiwgImltcG9ydCB7XHJcbiAgQXBwLFxyXG4gIEJ1dHRvbkNvbXBvbmVudCxcclxuICBNb2RhbCxcclxuICBTZXR0aW5nLFxyXG4gIFRleHRBcmVhQ29tcG9uZW50LFxyXG59IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIEdpdENvbW1pdE1vZGFsIGV4dGVuZHMgTW9kYWwge1xyXG4gIG1zZzogc3RyaW5nO1xyXG4gIGNvbW1pdDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gIHN5bmM6IGJvb2xlYW4gPSBmYWxzZTtcclxuICBvbkNvbXBsZXRlQ2FsbGJhY2s6IChtc2c6IHN0cmluZywgc3luYzogYm9vbGVhbikgPT4gdm9pZDtcclxuXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBhcHA6IEFwcCxcclxuICAgIG9uQ29tcGxldGVDYWxsYmFjazogKG1zZzogc3RyaW5nLCBzeW5jOiBib29sZWFuKSA9PiB2b2lkXHJcbiAgKSB7XHJcbiAgICBzdXBlcihhcHApO1xyXG4gICAgdGhpcy5vbkNvbXBsZXRlQ2FsbGJhY2sgPSBvbkNvbXBsZXRlQ2FsbGJhY2s7XHJcbiAgfVxyXG5cclxuICBvbk9wZW4oKTogdm9pZCB7XHJcbiAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcclxuXHJcbiAgICBjb250ZW50RWwuY3JlYXRlRWwoXCJoMVwiLCB7IHRleHQ6IFwiR2l0IGNvbW1pdFwiIH0pO1xyXG5cclxuICAgIG5ldyBTZXR0aW5nKGNvbnRlbnRFbClcclxuICAgICAgLnNldE5hbWUoXCJDb21taXQgbWVzc2FnZVwiKVxyXG4gICAgICAuYWRkVGV4dEFyZWEoKGNvbXA6IFRleHRBcmVhQ29tcG9uZW50KSA9PiB7XHJcbiAgICAgICAgY29tcC5zZXRQbGFjZWhvbGRlcihcIkVudGVyIGNvbW1pdCBtZXNzYWdlLi4uXCIpO1xyXG4gICAgICAgIGNvbXAub25DaGFuZ2UoKHZhbHVlKSA9PiAodGhpcy5tc2cgPSB2YWx1ZSkpO1xyXG4gICAgICB9KVxyXG4gICAgICAuc2V0Q2xhc3MoXCJtb2RhbC1zZXR0aW5nLWl0ZW0tdy10ZXh0LWFyZWFcIik7XHJcblxyXG4gICAgY29uc3QgYnV0dG9ucyA9IG5ldyBTZXR0aW5nKGNvbnRlbnRFbClcclxuICAgICAgLmFkZEJ1dHRvbigoYnRuOiBCdXR0b25Db21wb25lbnQpID0+XHJcbiAgICAgICAgYnRuLnNldEJ1dHRvblRleHQoXCJDYW5jZWxcIikub25DbGljaygoKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgfSlcclxuICAgICAgKVxyXG4gICAgICAuYWRkQnV0dG9uKChidG46IEJ1dHRvbkNvbXBvbmVudCkgPT5cclxuICAgICAgICBidG5cclxuICAgICAgICAgIC5zZXRCdXR0b25UZXh0KFwiQ29tbWl0XCIpXHJcbiAgICAgICAgICAuc2V0Q2xhc3MoXCJiZy10aGVtZVwiKVxyXG4gICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5tc2cgJiYgdGhpcy5tc2cudHJpbSgpLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICB0aGlzLmNvbW1pdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KVxyXG4gICAgICApO1xyXG5cclxuICAgIC8vIHNldHVwIHN5bmMgY2hlY2tib3hcclxuICAgIGNvbnN0IGNoZWNrYm94Q29udGFpbmVyOiBIVE1MRGl2RWxlbWVudCA9IGNvbnRlbnRFbC5jcmVhdGVEaXYoe1xyXG4gICAgICBjbHM6IFwiY2hlY2tib3gtY29udGFpbmVyLXctdGV4dFwiLFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgY2hlY2tib3g6IEhUTUxJbnB1dEVsZW1lbnQgPSBjb250ZW50RWwuY3JlYXRlRWwoXCJpbnB1dFwiLCB7XHJcbiAgICAgIHR5cGU6IFwiY2hlY2tib3hcIixcclxuICAgICAgYXR0cjoge1xyXG4gICAgICAgIGlkOiBcInN5bmMtY2hlY2tib3hcIixcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG5cclxuICAgIGNoZWNrYm94LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgKCkgPT4ge1xyXG4gICAgICB0aGlzLnN5bmMgPSBjaGVja2JveC5jaGVja2VkO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgY2hlY2tib3hUZXh0OiBIVE1MTGFiZWxFbGVtZW50ID0gY29udGVudEVsLmNyZWF0ZUVsKFwibGFiZWxcIiwge1xyXG4gICAgICB0ZXh0OiBcIkF1dG9tYXRpY2FsbHkgcHVzaCB0byByZW1vdGUgcmVwb3NpdG9yeVwiLFxyXG4gICAgICBjbHM6IFwiZm9udC1zbWFsbFwiLFxyXG4gICAgICBhdHRyOiB7XHJcbiAgICAgICAgZm9yOiBcInN5bmMtY2hlY2tib3hcIixcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG5cclxuICAgIGNoZWNrYm94Q29udGFpbmVyLmFwcGVuZENoaWxkKGNoZWNrYm94KTtcclxuICAgIGNoZWNrYm94Q29udGFpbmVyLmFwcGVuZENoaWxkKGNoZWNrYm94VGV4dCk7XHJcblxyXG4gICAgYnV0dG9ucy5jb250cm9sRWwuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFwiYWZ0ZXJiZWdpblwiLCBjaGVja2JveENvbnRhaW5lcik7XHJcbiAgfVxyXG5cclxuICBvbkNsb3NlKCkge1xyXG4gICAgY29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XHJcbiAgICBjb250ZW50RWwuZW1wdHkoKTtcclxuICAgIGlmICh0aGlzLmNvbW1pdCkge1xyXG4gICAgICB0aGlzLm9uQ29tcGxldGVDYWxsYmFjayh0aGlzLm1zZywgdGhpcy5zeW5jKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuIiwgImltcG9ydCB7IEFwcCwgTW9kYWwsIFNldHRpbmcgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBHaXRJbml0UmVtb3RlIGV4dGVuZHMgTW9kYWwge1xyXG4gIHJlcG86IHN0cmluZztcclxuICBhZGRSZW1vdGU6IGJvb2xlYW4gPSBmYWxzZTtcclxuICBvbkNvbXBsZXRlQ2FsbGJhY2s6IChyZXBvOiBzdHJpbmcpID0+IHZvaWQ7XHJcblxyXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBvbkNvbXBsZXRlQ2FsbGJhY2s6IChyZXBvOiBzdHJpbmcpID0+IHZvaWQpIHtcclxuICAgIHN1cGVyKGFwcCk7XHJcbiAgICB0aGlzLm9uQ29tcGxldGVDYWxsYmFjayA9IG9uQ29tcGxldGVDYWxsYmFjaztcclxuICB9XHJcblxyXG4gIG9uT3BlbigpIHtcclxuICAgIGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xyXG5cclxuICAgIGNvbnRlbnRFbC5jcmVhdGVFbChcImgxXCIsIHsgdGV4dDogXCJHaXQgaW5pdCByZW1vdGVcIiB9KTtcclxuXHJcbiAgICBuZXcgU2V0dGluZyhjb250ZW50RWwpXHJcbiAgICAgIC5zZXROYW1lKFwiUmVtb3RlIHJlcG9zaXRvcnkgdXJsXCIpXHJcbiAgICAgIC5hZGRUZXh0KCh0ZXh0KSA9PlxyXG4gICAgICAgIHRleHRcclxuICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcihcIkVudGVyIHJlcG9zaXRvcnkgdXJsLi4uXCIpXHJcbiAgICAgICAgICAub25DaGFuZ2UoKHZhbHVlKSA9PiAodGhpcy5yZXBvID0gdmFsdWUpKVxyXG4gICAgICApO1xyXG5cclxuICAgIG5ldyBTZXR0aW5nKGNvbnRlbnRFbCkuYWRkQnV0dG9uKChidG4pID0+XHJcbiAgICAgIGJ0blxyXG4gICAgICAgIC5zZXRCdXR0b25UZXh0KFwiSW5pdGlhbGl6ZVwiKVxyXG4gICAgICAgIC5zZXRDbGFzcyhcImJnLXRoZW1lXCIpXHJcbiAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xyXG4gICAgICAgICAgaWYgKHRoaXMucmVwbykge1xyXG4gICAgICAgICAgICB0aGlzLmFkZFJlbW90ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIG9uQ2xvc2UoKSB7XHJcbiAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcclxuICAgIGNvbnRlbnRFbC5lbXB0eSgpO1xyXG4gICAgaWYgKHRoaXMuYWRkUmVtb3RlKSB7XHJcbiAgICAgIHRoaXMub25Db21wbGV0ZUNhbGxiYWNrKHRoaXMucmVwbyk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsICJpbXBvcnQgeyBBcHAsIE1vZGFsLCBTZXR0aW5nIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCB7IEdpdENvbW1pdE1vZGFsIH0gZnJvbSBcIi4vZ2l0LWNvbW1pdC5tb2RhbFwiO1xyXG5pbXBvcnQgeyBHaXRJbml0UmVtb3RlIH0gZnJvbSBcIi4vZ2l0LWluaXQubW9kYWxcIjtcclxuaW1wb3J0IHsgR2l0U3luY01vZGFsIH0gZnJvbSBcIi4vZ2l0LXN5bmMubW9kYWxcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBHaXRNZW51TW9kYWwgZXh0ZW5kcyBNb2RhbCB7XHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBhcHA6IEFwcCxcclxuICAgIHByaXZhdGUgZ2l0SW5pdE1vZGFsOiBHaXRJbml0UmVtb3RlIHwgbnVsbCxcclxuICAgIHByaXZhdGUgZ2l0Q29tbWl0TW9kYWw6IEdpdENvbW1pdE1vZGFsLFxyXG4gICAgcHJpdmF0ZSBnaXRTeW5jTW9kYWw6IEdpdFN5bmNNb2RhbFxyXG4gICkge1xyXG4gICAgc3VwZXIoYXBwKTtcclxuICB9XHJcblxyXG4gIG9uT3BlbigpOiB2b2lkIHtcclxuICAgIGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xyXG4gICAgY29udGVudEVsLmNyZWF0ZUVsKFwiaDFcIiwgeyB0ZXh0OiBcIkdpdCBtZW51XCIgfSk7XHJcblxyXG4gICAgaWYgKHRoaXMuZ2l0SW5pdE1vZGFsICE9PSBudWxsKSB7XHJcbiAgICAgIG5ldyBTZXR0aW5nKGNvbnRlbnRFbClcclxuICAgICAgICAuc2V0Q2xhc3MoXCJzZXR0aW5nLWl0ZW0td2l0aG91dC1pbmZvXCIpXHJcbiAgICAgICAgLmFkZEJ1dHRvbigoYnV0dG9uKSA9PiB7XHJcbiAgICAgICAgICBidXR0b24uc2V0QnV0dG9uVGV4dChcIkdpdCBpbml0XCIpO1xyXG4gICAgICAgICAgYnV0dG9uLnNldENsYXNzKFwidy0xMDBcIikuc2V0Q2xhc3MoXCJmb250LW1lZGl1bVwiKTtcclxuICAgICAgICAgIGJ1dHRvbi5vbkNsaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5naXRJbml0TW9kYWwhLm9wZW4oKTtcclxuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBuZXcgU2V0dGluZyhjb250ZW50RWwpXHJcbiAgICAgIC5zZXRDbGFzcyhcInNldHRpbmctaXRlbS13aXRob3V0LWluZm9cIilcclxuICAgICAgLmFkZEJ1dHRvbigoYnV0dG9uKSA9PiB7XHJcbiAgICAgICAgYnV0dG9uLnNldEJ1dHRvblRleHQoXCJHaXQgY29tbWl0XCIpO1xyXG4gICAgICAgIGJ1dHRvbi5zZXRDbGFzcyhcInctMTAwXCIpLnNldENsYXNzKFwiZm9udC1tZWRpdW1cIik7XHJcbiAgICAgICAgYnV0dG9uLm9uQ2xpY2soKCkgPT4ge1xyXG4gICAgICAgICAgdGhpcy5naXRDb21taXRNb2RhbC5vcGVuKCk7XHJcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pXHJcbiAgICAgIC5hZGRCdXR0b24oKGJ1dHRvbikgPT4ge1xyXG4gICAgICAgIGJ1dHRvbi5zZXRCdXR0b25UZXh0KFwiR2l0IHN5bmNcIik7XHJcbiAgICAgICAgYnV0dG9uLnNldENsYXNzKFwidy0xMDBcIikuc2V0Q2xhc3MoXCJmb250LW1lZGl1bVwiKTtcclxuICAgICAgICBidXR0b24ub25DbGljaygoKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLmdpdFN5bmNNb2RhbC5vcGVuKCk7XHJcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgb25DbG9zZSgpOiB2b2lkIHtcclxuICAgIGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xyXG4gICAgY29udGVudEVsLmVtcHR5KCk7XHJcbiAgfVxyXG59XHJcbiIsICJpbXBvcnQgeyBBcHAsIE1vZGFsLCBTZXR0aW5nIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgR2l0U3luY01vZGFsIGV4dGVuZHMgTW9kYWwge1xyXG4gIG9uQ29tcGxldGVDYWxsYmFjazogKCkgPT4gdm9pZDtcclxuXHJcbiAgY29uc3RydWN0b3IoYXBwOiBBcHAsIG9uQ29tcGxldGVDYWxsYmFjazogKCkgPT4gdm9pZCkge1xyXG4gICAgc3VwZXIoYXBwKTtcclxuICAgIHRoaXMub25Db21wbGV0ZUNhbGxiYWNrID0gb25Db21wbGV0ZUNhbGxiYWNrO1xyXG4gIH1cclxuXHJcbiAgb25PcGVuKCkge1xyXG4gICAgY29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XHJcblxyXG4gICAgY29udGVudEVsLmNyZWF0ZUVsKFwiaDFcIiwgeyB0ZXh0OiBcIkdpdCBzeW5jP1wiIH0pO1xyXG4gICAgY29udGVudEVsLmNyZWF0ZUVsKFwic3BhblwiLCB7XHJcbiAgICAgIHRleHQ6IFwiVGhpcyB3aWxsIHN5bmMgd2l0aCB0aGUgcmVtb3RlIGJyYW5jaC5cIixcclxuICAgIH0pO1xyXG5cclxuICAgIG5ldyBTZXR0aW5nKGNvbnRlbnRFbClcclxuICAgICAgLnNldEhlYWRpbmcoKVxyXG4gICAgICAuYWRkQnV0dG9uKChidG4pID0+XHJcbiAgICAgICAgYnRuLnNldEJ1dHRvblRleHQoXCJDYW5jZWxcIikub25DbGljaygoKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgfSlcclxuICAgICAgKVxyXG4gICAgICAuYWRkQnV0dG9uKChidG4pID0+IHtcclxuICAgICAgICBidG5cclxuICAgICAgICAgIC5zZXRCdXR0b25UZXh0KFwiU3luY1wiKVxyXG4gICAgICAgICAgLnNldENsYXNzKFwiYmctdGhlbWVcIilcclxuICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5vbkNvbXBsZXRlQ2FsbGJhY2soKTtcclxuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgb25DbG9zZSgpIHtcclxuICAgIGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xyXG4gICAgY29udGVudEVsLmVtcHR5KCk7XHJcbiAgfVxyXG59XHJcbiIsICJpbXBvcnQgeyBHaXRQbHVnaW5TZXR0aW5ncyB9IGZyb20gXCIuL3BsdWdpbi1zZXR0aW5ncy5tb2RlbFwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IERFRkFVTFRfU0VUVElOR1M6IEdpdFBsdWdpblNldHRpbmdzID0ge1xyXG4gIGdpdFJlbW90ZTogbnVsbCxcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBJU19ERUJVR19NT0RFID0gdHJ1ZTtcclxuIiwgImltcG9ydCB7IEFwcCwgTW9kYWwgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBEZWJ1Z01vZGFsIGV4dGVuZHMgTW9kYWwge1xyXG4gIGNvbnRlbnRzOiBzdHJpbmc7XHJcbiAgaGVhZGluZzogc3RyaW5nID0gXCJHaXQgSW50ZWdyYXRpb24gUGx1Z2luIGRlYnVnIG1lc3NhZ2U6XCI7XHJcblxyXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBjb250ZW50czogc3RyaW5nKSB7XHJcbiAgICBzdXBlcihhcHApO1xyXG4gICAgdGhpcy5jb250ZW50cyA9IGNvbnRlbnRzO1xyXG4gIH1cclxuXHJcbiAgb25PcGVuKCk6IHZvaWQge1xyXG4gICAgY29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XHJcblxyXG4gICAgY29udGVudEVsLmNyZWF0ZUVsKFwiaDFcIiwge1xyXG4gICAgICB0ZXh0OiB0aGlzLmhlYWRpbmcsXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb250ZW50RWwuY3JlYXRlRWwoXCJzcGFuXCIsIHsgdGV4dDogdGhpcy5jb250ZW50cyB9KTtcclxuICB9XHJcbn1cclxuIiwgImltcG9ydCB7IEFwcCwgTW9kYWwsIFNldHRpbmcgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBEZWxldGVHaXRGb2xkZXJNb2RhbCBleHRlbmRzIE1vZGFsIHtcclxuICBvbkNvbXBsZXRlQ2FsbGJhY2s6ICgpID0+IHZvaWQ7XHJcblxyXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBvbkNvbXBsZXRlQ2FsbGJhY2s6ICgpID0+IHZvaWQpIHtcclxuICAgIHN1cGVyKGFwcCk7XHJcbiAgICB0aGlzLm9uQ29tcGxldGVDYWxsYmFjayA9IG9uQ29tcGxldGVDYWxsYmFjaztcclxuICB9XHJcblxyXG4gIG9uT3BlbigpOiB2b2lkIHtcclxuICAgIGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xyXG5cclxuICAgIGNvbnRlbnRFbC5jcmVhdGVFbChcImgxXCIsIHtcclxuICAgICAgdGV4dDogXCJBcmUgeW91IHN1cmUgdG8gZGVsZXRlIC5naXQgZm9sZGVyP1wiLFxyXG4gICAgfSk7XHJcblxyXG4gICAgbmV3IFNldHRpbmcoY29udGVudEVsKVxyXG4gICAgICAuc2V0Q2xhc3MoXCJzZXR0aW5nLWl0ZW0td2l0aG91dC1pbmZvXCIpXHJcbiAgICAgIC5hZGRCdXR0b24oKGJ0bikgPT5cclxuICAgICAgICBidG4uc2V0QnV0dG9uVGV4dChcIkNhbmNlbFwiKS5vbkNsaWNrKCgpID0+IHtcclxuICAgICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgICAgICB9KVxyXG4gICAgICApXHJcbiAgICAgIC5hZGRCdXR0b24oKGJ0bikgPT4ge1xyXG4gICAgICAgIGJ0blxyXG4gICAgICAgICAgLnNldEJ1dHRvblRleHQoXCJEZWxldGVcIilcclxuICAgICAgICAgIC5zZXRDbGFzcyhcImJnLXRoZW1lXCIpXHJcbiAgICAgICAgICAub25DbGljaygoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMub25Db21wbGV0ZUNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICB9XHJcbn1cclxuIiwgImltcG9ydCB7IEFwcCB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgeyBEZWJ1Z01vZGFsIH0gZnJvbSBcIi4vZGVidWcubW9kYWxcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBFcnJvck1vZGFsIGV4dGVuZHMgRGVidWdNb2RhbCB7XHJcbiAgY29udGVudHM6IHN0cmluZztcclxuXHJcbiAgY29uc3RydWN0b3IoYXBwOiBBcHAsIGNvbnRlbnRzOiBzdHJpbmcpIHtcclxuICAgIHN1cGVyKGFwcCwgY29udGVudHMpO1xyXG4gICAgdGhpcy5oZWFkaW5nID0gXCJHaXQgSW50ZWdyYXRpb24gUGx1Z2luIHJhbiBpbnRvIGFuIGVycm9yOlwiO1xyXG4gIH1cclxufVxyXG4iLCAiaW1wb3J0ICogYXMgZnMgZnJvbSBcImZzXCI7XHJcbmltcG9ydCAqIGFzIHBhdGggZnJvbSBcInBhdGhcIjtcclxuXHJcbmNvbnN0IGRlbGV0ZUZvbGRlciA9IChmb2xkZXJQYXRoOiBzdHJpbmcpID0+IHtcclxuICBmcy5ybShmb2xkZXJQYXRoLCB7IHJlY3Vyc2l2ZTogdHJ1ZSwgZm9yY2U6IHRydWUgfSwgKCkgPT4ge30pO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGRlbGV0ZUdpdEZvbGRlciA9IChmb2xkZXJQYXRoOiBzdHJpbmcpID0+IHtcclxuICBkZWxldGVGb2xkZXIocGF0aC5yZXNvbHZlKGZvbGRlclBhdGgsIFwiLmdpdFwiKSk7XHJcbn07XHJcbiIsICJpbXBvcnQgKiBhcyBjaGlsZFByb2Nlc3MgZnJvbSBcImNoaWxkX3Byb2Nlc3NcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBvcGVuRm9sZGVyID0gKHBhdGg6IHN0cmluZykgPT4ge1xyXG4gIGNoaWxkUHJvY2Vzcy5leGVjKGBzdGFydCBcIlwiIFwiJHtwYXRofVwiYCk7XHJcbn07XHJcbiIsICJjb25zdCBjYWNoZSA9IG5ldyBXZWFrTWFwPFN0cmluZywgc3RyaW5nW10+KCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXRoc3BlYyguLi5wYXRoczogc3RyaW5nW10pIHtcbiAgIGNvbnN0IGtleSA9IG5ldyBTdHJpbmcocGF0aHMpO1xuICAgY2FjaGUuc2V0KGtleSwgcGF0aHMpO1xuXG4gICByZXR1cm4ga2V5IGFzIHN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUGF0aFNwZWMocGF0aDogc3RyaW5nIHwgdW5rbm93bik6IHBhdGggaXMgc3RyaW5nIHtcbiAgIHJldHVybiBwYXRoIGluc3RhbmNlb2YgU3RyaW5nICYmIGNhY2hlLmhhcyhwYXRoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvUGF0aHMocGF0aFNwZWM6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgIHJldHVybiBjYWNoZS5nZXQocGF0aFNwZWMpIHx8IFtdO1xufVxuIiwgImltcG9ydCB0eXBlIHsgU2ltcGxlR2l0VGFzayB9IGZyb20gJy4uL3R5cGVzJztcblxuLyoqXG4gKiBUaGUgYEdpdEVycm9yYCBpcyB0aHJvd24gd2hlbiB0aGUgdW5kZXJseWluZyBgZ2l0YCBwcm9jZXNzIHRocm93cyBhXG4gKiBmYXRhbCBleGNlcHRpb24gKGVnIGFuIGBFTk9FTlRgIGV4Y2VwdGlvbiB3aGVuIGF0dGVtcHRpbmcgdG8gdXNlIGFcbiAqIG5vbi13cml0YWJsZSBkaXJlY3RvcnkgYXMgdGhlIHJvb3QgZm9yIHlvdXIgcmVwbyksIGFuZCBhY3RzIGFzIHRoZVxuICogYmFzZSBjbGFzcyBmb3IgbW9yZSBzcGVjaWZpYyBlcnJvcnMgdGhyb3duIGJ5IHRoZSBwYXJzaW5nIG9mIHRoZVxuICogZ2l0IHJlc3BvbnNlIG9yIGVycm9ycyBpbiB0aGUgY29uZmlndXJhdGlvbiBvZiB0aGUgdGFzayBhYm91dCB0b1xuICogYmUgcnVuLlxuICpcbiAqIFdoZW4gYW4gZXhjZXB0aW9uIGlzIHRocm93biwgcGVuZGluZyB0YXNrcyBpbiB0aGUgc2FtZSBpbnN0YW5jZSB3aWxsXG4gKiBub3QgYmUgZXhlY3V0ZWQuIFRoZSByZWNvbW1lbmRlZCB3YXkgdG8gcnVuIGEgc2VyaWVzIG9mIHRhc2tzIHRoYXRcbiAqIGNhbiBpbmRlcGVuZGVudGx5IGZhaWwgd2l0aG91dCBuZWVkaW5nIHRvIHByZXZlbnQgZnV0dXJlIHRhc2tzIGZyb21cbiAqIHJ1bm5pbmcgaXMgdG8gY2F0Y2ggdGhlbSBpbmRpdmlkdWFsbHk6XG4gKlxuICogYGBgdHlwZXNjcmlwdFxuIGltcG9ydCB7IGdpdFAsIFNpbXBsZUdpdCwgR2l0RXJyb3IsIFB1bGxSZXN1bHQgfSBmcm9tICdzaW1wbGUtZ2l0JztcblxuIGZ1bmN0aW9uIGNhdGNoVGFzayAoZTogR2l0RXJyb3IpIHtcbiAgIHJldHVybiBlLlxuIH1cblxuIGNvbnN0IGdpdCA9IGdpdFAocmVwb1dvcmtpbmdEaXIpO1xuIGNvbnN0IHB1bGxlZDogUHVsbFJlc3VsdCB8IEdpdEVycm9yID0gYXdhaXQgZ2l0LnB1bGwoKS5jYXRjaChjYXRjaFRhc2spO1xuIGNvbnN0IHB1c2hlZDogc3RyaW5nIHwgR2l0RXJyb3IgPSBhd2FpdCBnaXQucHVzaFRhZ3MoKS5jYXRjaChjYXRjaFRhc2spO1xuIGBgYFxuICovXG5leHBvcnQgY2xhc3MgR2l0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICBjb25zdHJ1Y3RvcihcbiAgICAgIHB1YmxpYyB0YXNrPzogU2ltcGxlR2l0VGFzazxhbnk+LFxuICAgICAgbWVzc2FnZT86IHN0cmluZ1xuICAgKSB7XG4gICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7XG4gICB9XG59XG4iLCAiaW1wb3J0IHsgR2l0RXJyb3IgfSBmcm9tICcuL2dpdC1lcnJvcic7XG5cbi8qKlxuICogVGhlIGBHaXRSZXNwb25zZUVycm9yYCBpcyB0aGUgd3JhcHBlciBmb3IgYSBwYXJzZWQgcmVzcG9uc2UgdGhhdCBpcyB0cmVhdGVkIGFzXG4gKiBhIGZhdGFsIGVycm9yLCBmb3IgZXhhbXBsZSBhdHRlbXB0aW5nIGEgYG1lcmdlYCBjYW4gbGVhdmUgdGhlIHJlcG8gaW4gYSBjb3JydXB0ZWRcbiAqIHN0YXRlIHdoZW4gdGhlcmUgYXJlIGNvbmZsaWN0cyBzbyB0aGUgdGFzayB3aWxsIHJlamVjdCByYXRoZXIgdGhhbiByZXNvbHZlLlxuICpcbiAqIEZvciBleGFtcGxlLCBjYXRjaGluZyB0aGUgbWVyZ2UgY29uZmxpY3QgZXhjZXB0aW9uOlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiBpbXBvcnQgeyBnaXRQLCBTaW1wbGVHaXQsIEdpdFJlc3BvbnNlRXJyb3IsIE1lcmdlU3VtbWFyeSB9IGZyb20gJ3NpbXBsZS1naXQnO1xuXG4gY29uc3QgZ2l0ID0gZ2l0UChyZXBvUm9vdCk7XG4gY29uc3QgbWVyZ2VPcHRpb25zOiBzdHJpbmdbXSA9IFsnLS1uby1mZicsICdvdGhlci1icmFuY2gnXTtcbiBjb25zdCBtZXJnZVN1bW1hcnk6IE1lcmdlU3VtbWFyeSA9IGF3YWl0IGdpdC5tZXJnZShtZXJnZU9wdGlvbnMpXG4gICAgICAuY2F0Y2goKGU6IEdpdFJlc3BvbnNlRXJyb3I8TWVyZ2VTdW1tYXJ5PikgPT4gZS5naXQpO1xuXG4gaWYgKG1lcmdlU3VtbWFyeS5mYWlsZWQpIHtcbiAgIC8vIGRlYWwgd2l0aCB0aGUgZXJyb3JcbiB9XG4gYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBHaXRSZXNwb25zZUVycm9yPFQgPSBhbnk+IGV4dGVuZHMgR2l0RXJyb3Ige1xuICAgY29uc3RydWN0b3IoXG4gICAgICAvKipcbiAgICAgICAqIGAuZ2l0YCBhY2Nlc3MgdGhlIHBhcnNlZCByZXNwb25zZSB0aGF0IGlzIHRyZWF0ZWQgYXMgYmVpbmcgYW4gZXJyb3JcbiAgICAgICAqL1xuICAgICAgcHVibGljIHJlYWRvbmx5IGdpdDogVCxcbiAgICAgIG1lc3NhZ2U/OiBzdHJpbmdcbiAgICkge1xuICAgICAgc3VwZXIodW5kZWZpbmVkLCBtZXNzYWdlIHx8IFN0cmluZyhnaXQpKTtcbiAgIH1cbn1cbiIsICJpbXBvcnQgeyBHaXRFcnJvciB9IGZyb20gJy4vZ2l0LWVycm9yJztcblxuLyoqXG4gKiBUaGUgYFRhc2tDb25maWd1cmF0aW9uRXJyb3JgIGlzIHRocm93biB3aGVuIGEgY29tbWFuZCB3YXMgaW5jb3JyZWN0bHlcbiAqIGNvbmZpZ3VyZWQuIEFuIGVycm9yIG9mIHRoaXMga2luZCBtZWFucyB0aGF0IG5vIGF0dGVtcHQgd2FzIG1hZGUgdG9cbiAqIHJ1biB5b3VyIGNvbW1hbmQgdGhyb3VnaCB0aGUgdW5kZXJseWluZyBgZ2l0YCBiaW5hcnkuXG4gKlxuICogQ2hlY2sgdGhlIGAubWVzc2FnZWAgcHJvcGVydHkgZm9yIG1vcmUgZGV0YWlsIG9uIHdoeSB5b3VyIGNvbmZpZ3VyYXRpb25cbiAqIHJlc3VsdGVkIGluIGFuIGVycm9yLlxuICovXG5leHBvcnQgY2xhc3MgVGFza0NvbmZpZ3VyYXRpb25FcnJvciBleHRlbmRzIEdpdEVycm9yIHtcbiAgIGNvbnN0cnVjdG9yKG1lc3NhZ2U/OiBzdHJpbmcpIHtcbiAgICAgIHN1cGVyKHVuZGVmaW5lZCwgbWVzc2FnZSk7XG4gICB9XG59XG4iLCAiaW1wb3J0IHsgZXhpc3RzLCBGT0xERVIgfSBmcm9tICdAa3dzaXRlcy9maWxlLWV4aXN0cyc7XG5pbXBvcnQgeyBNYXliZSB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGNvbnN0IE5VTEwgPSAnXFwwJztcblxuZXhwb3J0IGNvbnN0IE5PT1A6ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZCA9ICgpID0+IHt9O1xuXG4vKipcbiAqIFJldHVybnMgZWl0aGVyIHRoZSBzb3VyY2UgYXJndW1lbnQgd2hlbiBpdCBpcyBhIGBGdW5jdGlvbmAsIG9yIHRoZSBkZWZhdWx0XG4gKiBgTk9PUGAgZnVuY3Rpb24gY29uc3RhbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzRnVuY3Rpb248VCBleHRlbmRzICgpID0+IGFueT4oc291cmNlOiBUIHwgYW55KTogVCB7XG4gICByZXR1cm4gdHlwZW9mIHNvdXJjZSA9PT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZSA6IE5PT1A7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzdXBwbGllZCBhcmd1bWVudCBpcyBib3RoIGEgZnVuY3Rpb24sIGFuZCBpcyBub3RcbiAqIHRoZSBgTk9PUGAgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1VzZXJGdW5jdGlvbjxUIGV4dGVuZHMgRnVuY3Rpb24+KHNvdXJjZTogVCB8IGFueSk6IHNvdXJjZSBpcyBUIHtcbiAgIHJldHVybiB0eXBlb2Ygc291cmNlID09PSAnZnVuY3Rpb24nICYmIHNvdXJjZSAhPT0gTk9PUDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0T24oaW5wdXQ6IHN0cmluZywgY2hhcjogc3RyaW5nKTogW3N0cmluZywgc3RyaW5nXSB7XG4gICBjb25zdCBpbmRleCA9IGlucHV0LmluZGV4T2YoY2hhcik7XG4gICBpZiAoaW5kZXggPD0gMCkge1xuICAgICAgcmV0dXJuIFtpbnB1dCwgJyddO1xuICAgfVxuXG4gICByZXR1cm4gW2lucHV0LnN1YnN0cigwLCBpbmRleCksIGlucHV0LnN1YnN0cihpbmRleCArIDEpXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0PFQgZXh0ZW5kcyBhbnlbXT4oaW5wdXQ6IFQsIG9mZnNldD86IG51bWJlcik6IE1heWJlPFRbbnVtYmVyXT47XG5leHBvcnQgZnVuY3Rpb24gZmlyc3Q8VCBleHRlbmRzIElBcmd1bWVudHM+KGlucHV0OiBULCBvZmZzZXQ/OiBudW1iZXIpOiBNYXliZTx1bmtub3duPjtcbmV4cG9ydCBmdW5jdGlvbiBmaXJzdChpbnB1dDogYW55W10gfCBJQXJndW1lbnRzLCBvZmZzZXQgPSAwKTogTWF5YmU8dW5rbm93bj4ge1xuICAgcmV0dXJuIGlzQXJyYXlMaWtlKGlucHV0KSAmJiBpbnB1dC5sZW5ndGggPiBvZmZzZXQgPyBpbnB1dFtvZmZzZXRdIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGFzdDxUIGV4dGVuZHMgYW55W10+KGlucHV0OiBULCBvZmZzZXQ/OiBudW1iZXIpOiBNYXliZTxUW251bWJlcl0+O1xuZXhwb3J0IGZ1bmN0aW9uIGxhc3Q8VCBleHRlbmRzIElBcmd1bWVudHM+KGlucHV0OiBULCBvZmZzZXQ/OiBudW1iZXIpOiBNYXliZTx1bmtub3duPjtcbmV4cG9ydCBmdW5jdGlvbiBsYXN0PFQ+KGlucHV0OiBULCBvZmZzZXQ/OiBudW1iZXIpOiBNYXliZTx1bmtub3duPjtcbmV4cG9ydCBmdW5jdGlvbiBsYXN0KGlucHV0OiB1bmtub3duLCBvZmZzZXQgPSAwKSB7XG4gICBpZiAoaXNBcnJheUxpa2UoaW5wdXQpICYmIGlucHV0Lmxlbmd0aCA+IG9mZnNldCkge1xuICAgICAgcmV0dXJuIGlucHV0W2lucHV0Lmxlbmd0aCAtIDEgLSBvZmZzZXRdO1xuICAgfVxufVxuXG50eXBlIEFycmF5TGlrZTxUID0gYW55PiA9IFRbXSB8IElBcmd1bWVudHMgfCB7IFtpbmRleDogbnVtYmVyXTogVDsgbGVuZ3RoOiBudW1iZXIgfTtcblxuZnVuY3Rpb24gaXNBcnJheUxpa2UoaW5wdXQ6IGFueSk6IGlucHV0IGlzIEFycmF5TGlrZSB7XG4gICByZXR1cm4gISEoaW5wdXQgJiYgdHlwZW9mIGlucHV0Lmxlbmd0aCA9PT0gJ251bWJlcicpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9MaW5lc1dpdGhDb250ZW50KGlucHV0ID0gJycsIHRyaW1tZWQgPSB0cnVlLCBzZXBhcmF0b3IgPSAnXFxuJyk6IHN0cmluZ1tdIHtcbiAgIHJldHVybiBpbnB1dC5zcGxpdChzZXBhcmF0b3IpLnJlZHVjZSgob3V0cHV0LCBsaW5lKSA9PiB7XG4gICAgICBjb25zdCBsaW5lQ29udGVudCA9IHRyaW1tZWQgPyBsaW5lLnRyaW0oKSA6IGxpbmU7XG4gICAgICBpZiAobGluZUNvbnRlbnQpIHtcbiAgICAgICAgIG91dHB1dC5wdXNoKGxpbmVDb250ZW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICB9LCBbXSBhcyBzdHJpbmdbXSk7XG59XG5cbnR5cGUgTGluZVdpdGhDb250ZW50Q2FsbGJhY2s8VCA9IHZvaWQ+ID0gKGxpbmU6IHN0cmluZykgPT4gVDtcblxuZXhwb3J0IGZ1bmN0aW9uIGZvckVhY2hMaW5lV2l0aENvbnRlbnQ8VD4oXG4gICBpbnB1dDogc3RyaW5nLFxuICAgY2FsbGJhY2s6IExpbmVXaXRoQ29udGVudENhbGxiYWNrPFQ+XG4pOiBUW10ge1xuICAgcmV0dXJuIHRvTGluZXNXaXRoQ29udGVudChpbnB1dCwgdHJ1ZSkubWFwKChsaW5lKSA9PiBjYWxsYmFjayhsaW5lKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb2xkZXJFeGlzdHMocGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICByZXR1cm4gZXhpc3RzKHBhdGgsIEZPTERFUik7XG59XG5cbi8qKlxuICogQWRkcyBgaXRlbWAgaW50byB0aGUgYHRhcmdldGAgYEFycmF5YCBvciBgU2V0YCB3aGVuIGl0IGlzIG5vdCBhbHJlYWR5IHByZXNlbnQgYW5kIHJldHVybnMgdGhlIGBpdGVtYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZDxUPih0YXJnZXQ6IFRbXSB8IFNldDxUPiwgaXRlbTogVCk6IHR5cGVvZiBpdGVtIHtcbiAgIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkpIHtcbiAgICAgIGlmICghdGFyZ2V0LmluY2x1ZGVzKGl0ZW0pKSB7XG4gICAgICAgICB0YXJnZXQucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQuYWRkKGl0ZW0pO1xuICAgfVxuICAgcmV0dXJuIGl0ZW07XG59XG5cbi8qKlxuICogQWRkcyBgaXRlbWAgaW50byB0aGUgYHRhcmdldGAgYEFycmF5YCB3aGVuIGl0IGlzIG5vdCBhbHJlYWR5IHByZXNlbnQgYW5kIHJldHVybnMgdGhlIGB0YXJnZXRgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5jbHVkaW5nPFQ+KHRhcmdldDogVFtdLCBpdGVtOiBUKTogdHlwZW9mIHRhcmdldCB7XG4gICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmICF0YXJnZXQuaW5jbHVkZXMoaXRlbSkpIHtcbiAgICAgIHRhcmdldC5wdXNoKGl0ZW0pO1xuICAgfVxuXG4gICByZXR1cm4gdGFyZ2V0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlPFQ+KHRhcmdldDogU2V0PFQ+IHwgVFtdLCBpdGVtOiBUKTogVCB7XG4gICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICBjb25zdCBpbmRleCA9IHRhcmdldC5pbmRleE9mKGl0ZW0pO1xuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgIHRhcmdldC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldC5kZWxldGUoaXRlbSk7XG4gICB9XG4gICByZXR1cm4gaXRlbTtcbn1cblxuZXhwb3J0IGNvbnN0IG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykgYXMgKFxuICAgaW5wdXQ6IGFueVxuKSA9PiBzdHJpbmc7XG5cbmV4cG9ydCBmdW5jdGlvbiBhc0FycmF5PFQ+KHNvdXJjZTogVCB8IFRbXSk6IFRbXSB7XG4gICByZXR1cm4gQXJyYXkuaXNBcnJheShzb3VyY2UpID8gc291cmNlIDogW3NvdXJjZV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc1N0cmluZ0FycmF5PFQ+KHNvdXJjZTogVCB8IFRbXSk6IHN0cmluZ1tdIHtcbiAgIHJldHVybiBhc0FycmF5KHNvdXJjZSkubWFwKFN0cmluZyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc051bWJlcihzb3VyY2U6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQsIG9uTmFOID0gMCkge1xuICAgaWYgKHNvdXJjZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gb25OYU47XG4gICB9XG5cbiAgIGNvbnN0IG51bSA9IHBhcnNlSW50KHNvdXJjZSwgMTApO1xuICAgcmV0dXJuIGlzTmFOKG51bSkgPyBvbk5hTiA6IG51bTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByZWZpeGVkQXJyYXk8VD4oaW5wdXQ6IFRbXSwgcHJlZml4OiBUKTogVFtdIHtcbiAgIGNvbnN0IG91dHB1dDogVFtdID0gW107XG4gICBmb3IgKGxldCBpID0gMCwgbWF4ID0gaW5wdXQubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgIG91dHB1dC5wdXNoKHByZWZpeCwgaW5wdXRbaV0pO1xuICAgfVxuICAgcmV0dXJuIG91dHB1dDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1ZmZlclRvU3RyaW5nKGlucHV0OiBCdWZmZXIgfCBCdWZmZXJbXSk6IHN0cmluZyB7XG4gICByZXR1cm4gKEFycmF5LmlzQXJyYXkoaW5wdXQpID8gQnVmZmVyLmNvbmNhdChpbnB1dCkgOiBpbnB1dCkudG9TdHJpbmcoJ3V0Zi04Jyk7XG59XG5cbi8qKlxuICogR2V0IGEgbmV3IG9iamVjdCBmcm9tIGEgc291cmNlIG9iamVjdCB3aXRoIG9ubHkgdGhlIGxpc3RlZCBwcm9wZXJ0aWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGljayhzb3VyY2U6IFJlY29yZDxzdHJpbmcsIGFueT4sIHByb3BlcnRpZXM6IHN0cmluZ1tdKSB7XG4gICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgIHt9LFxuICAgICAgLi4ucHJvcGVydGllcy5tYXAoKHByb3BlcnR5KSA9PiAocHJvcGVydHkgaW4gc291cmNlID8geyBbcHJvcGVydHldOiBzb3VyY2VbcHJvcGVydHldIH0gOiB7fSkpXG4gICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVsYXkoZHVyYXRpb24gPSAwKTogUHJvbWlzZTx2b2lkPiB7XG4gICByZXR1cm4gbmV3IFByb21pc2UoKGRvbmUpID0+IHNldFRpbWVvdXQoZG9uZSwgZHVyYXRpb24pKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9yVm9pZDxUPihpbnB1dDogVCB8IGZhbHNlKSB7XG4gICBpZiAoaW5wdXQgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgfVxuICAgcmV0dXJuIGlucHV0O1xufVxuIiwgImltcG9ydCB7IE1heWJlLCBPcHRpb25zLCBQcmltaXRpdmVzIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgb2JqZWN0VG9TdHJpbmcgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgaXNQYXRoU3BlYyB9IGZyb20gJy4uL2FyZ3MvcGF0aHNwZWMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEFyZ3VtZW50RmlsdGVyUHJlZGljYXRlPFQ+IHtcbiAgIChpbnB1dDogYW55KTogaW5wdXQgaXMgVDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlclR5cGU8VCwgSz4oXG4gICBpbnB1dDogSyxcbiAgIGZpbHRlcjogQXJndW1lbnRGaWx0ZXJQcmVkaWNhdGU8VD5cbik6IEsgZXh0ZW5kcyBUID8gVCA6IHVuZGVmaW5lZDtcbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJUeXBlPFQsIEs+KGlucHV0OiBLLCBmaWx0ZXI6IEFyZ3VtZW50RmlsdGVyUHJlZGljYXRlPFQ+LCBkZWY6IFQpOiBUO1xuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlclR5cGU8VCwgSz4oaW5wdXQ6IEssIGZpbHRlcjogQXJndW1lbnRGaWx0ZXJQcmVkaWNhdGU8VD4sIGRlZj86IFQpOiBNYXliZTxUPiB7XG4gICBpZiAoZmlsdGVyKGlucHV0KSkge1xuICAgICAgcmV0dXJuIGlucHV0O1xuICAgfVxuICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gZGVmIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgY29uc3QgZmlsdGVyQXJyYXk6IEFyZ3VtZW50RmlsdGVyUHJlZGljYXRlPEFycmF5PGFueT4+ID0gKGlucHV0KTogaW5wdXQgaXMgQXJyYXk8YW55PiA9PiB7XG4gICByZXR1cm4gQXJyYXkuaXNBcnJheShpbnB1dCk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyUHJpbWl0aXZlcyhcbiAgIGlucHV0OiB1bmtub3duLFxuICAgb21pdD86IEFycmF5PCdib29sZWFuJyB8ICdzdHJpbmcnIHwgJ251bWJlcic+XG4pOiBpbnB1dCBpcyBQcmltaXRpdmVzIHtcbiAgIGNvbnN0IHR5cGUgPSBpc1BhdGhTcGVjKGlucHV0KSA/ICdzdHJpbmcnIDogdHlwZW9mIGlucHV0O1xuXG4gICByZXR1cm4gKFxuICAgICAgL251bWJlcnxzdHJpbmd8Ym9vbGVhbi8udGVzdCh0eXBlKSAmJlxuICAgICAgKCFvbWl0IHx8ICFvbWl0LmluY2x1ZGVzKHR5cGUgYXMgJ2Jvb2xlYW4nIHwgJ3N0cmluZycgfCAnbnVtYmVyJykpXG4gICApO1xufVxuXG5leHBvcnQgY29uc3QgZmlsdGVyU3RyaW5nOiBBcmd1bWVudEZpbHRlclByZWRpY2F0ZTxzdHJpbmc+ID0gKGlucHV0KTogaW5wdXQgaXMgc3RyaW5nID0+IHtcbiAgIHJldHVybiB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnO1xufTtcblxuZXhwb3J0IGNvbnN0IGZpbHRlclN0cmluZ0FycmF5OiBBcmd1bWVudEZpbHRlclByZWRpY2F0ZTxzdHJpbmdbXT4gPSAoaW5wdXQpOiBpbnB1dCBpcyBzdHJpbmdbXSA9PiB7XG4gICByZXR1cm4gQXJyYXkuaXNBcnJheShpbnB1dCkgJiYgaW5wdXQuZXZlcnkoZmlsdGVyU3RyaW5nKTtcbn07XG5cbmV4cG9ydCBjb25zdCBmaWx0ZXJTdHJpbmdPclN0cmluZ0FycmF5OiBBcmd1bWVudEZpbHRlclByZWRpY2F0ZTxzdHJpbmcgfCBzdHJpbmdbXT4gPSAoXG4gICBpbnB1dFxuKTogaW5wdXQgaXMgc3RyaW5nIHwgc3RyaW5nW10gPT4ge1xuICAgcmV0dXJuIGZpbHRlclN0cmluZyhpbnB1dCkgfHwgKEFycmF5LmlzQXJyYXkoaW5wdXQpICYmIGlucHV0LmV2ZXJ5KGZpbHRlclN0cmluZykpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlclBsYWluT2JqZWN0PFQgZXh0ZW5kcyBPcHRpb25zPihpbnB1dDogVCB8IHVua25vd24pOiBpbnB1dCBpcyBUO1xuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlclBsYWluT2JqZWN0PFQgZXh0ZW5kcyBPYmplY3Q+KGlucHV0OiBUIHwgdW5rbm93bik6IGlucHV0IGlzIFQge1xuICAgcmV0dXJuICEhaW5wdXQgJiYgb2JqZWN0VG9TdHJpbmcoaW5wdXQpID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlckZ1bmN0aW9uKGlucHV0OiB1bmtub3duKTogaW5wdXQgaXMgRnVuY3Rpb24ge1xuICAgcmV0dXJuIHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZXhwb3J0IGNvbnN0IGZpbHRlckhhc0xlbmd0aDogQXJndW1lbnRGaWx0ZXJQcmVkaWNhdGU8eyBsZW5ndGg6IG51bWJlciB9PiA9IChcbiAgIGlucHV0XG4pOiBpbnB1dCBpcyB7IGxlbmd0aDogbnVtYmVyIH0gPT4ge1xuICAgaWYgKGlucHV0ID09IG51bGwgfHwgJ251bWJlcnxib29sZWFufGZ1bmN0aW9uJy5pbmNsdWRlcyh0eXBlb2YgaW5wdXQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICB9XG4gICByZXR1cm4gQXJyYXkuaXNBcnJheShpbnB1dCkgfHwgdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgaW5wdXQubGVuZ3RoID09PSAnbnVtYmVyJztcbn07XG4iLCAiLyoqXG4gKiBLbm93biBwcm9jZXNzIGV4aXQgY29kZXMgdXNlZCBieSB0aGUgdGFzayBwYXJzZXJzIHRvIGRldGVybWluZSB3aGV0aGVyIGFuIGVycm9yXG4gKiB3YXMgb25lIHRoZXkgY2FuIGF1dG9tYXRpY2FsbHkgaGFuZGxlXG4gKi9cbmV4cG9ydCBlbnVtIEV4aXRDb2RlcyB7XG4gICBTVUNDRVNTLFxuICAgRVJST1IsXG4gICBOT1RfRk9VTkQgPSAtMixcbiAgIFVOQ0xFQU4gPSAxMjgsXG59XG4iLCAiaW1wb3J0IHsgVGFza1Jlc3BvbnNlRm9ybWF0IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgR2l0T3V0cHV0U3RyZWFtczxUIGV4dGVuZHMgVGFza1Jlc3BvbnNlRm9ybWF0ID0gQnVmZmVyPiB7XG4gICBjb25zdHJ1Y3RvcihcbiAgICAgIHB1YmxpYyByZWFkb25seSBzdGRPdXQ6IFQsXG4gICAgICBwdWJsaWMgcmVhZG9ubHkgc3RkRXJyOiBUXG4gICApIHt9XG5cbiAgIGFzU3RyaW5ncygpOiBHaXRPdXRwdXRTdHJlYW1zPHN0cmluZz4ge1xuICAgICAgcmV0dXJuIG5ldyBHaXRPdXRwdXRTdHJlYW1zKHRoaXMuc3RkT3V0LnRvU3RyaW5nKCd1dGY4JyksIHRoaXMuc3RkRXJyLnRvU3RyaW5nKCd1dGY4JykpO1xuICAgfVxufVxuIiwgImV4cG9ydCBjbGFzcyBMaW5lUGFyc2VyPFQ+IHtcbiAgIHByb3RlY3RlZCBtYXRjaGVzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICBwcml2YXRlIF9yZWdFeHA6IFJlZ0V4cFtdO1xuXG4gICBjb25zdHJ1Y3RvcihcbiAgICAgIHJlZ0V4cDogUmVnRXhwIHwgUmVnRXhwW10sXG4gICAgICB1c2VNYXRjaGVzPzogKHRhcmdldDogVCwgbWF0Y2g6IHN0cmluZ1tdKSA9PiBib29sZWFuIHwgdm9pZFxuICAgKSB7XG4gICAgICB0aGlzLl9yZWdFeHAgPSBBcnJheS5pc0FycmF5KHJlZ0V4cCkgPyByZWdFeHAgOiBbcmVnRXhwXTtcbiAgICAgIGlmICh1c2VNYXRjaGVzKSB7XG4gICAgICAgICB0aGlzLnVzZU1hdGNoZXMgPSB1c2VNYXRjaGVzO1xuICAgICAgfVxuICAgfVxuXG4gICBwYXJzZSA9IChsaW5lOiAob2Zmc2V0OiBudW1iZXIpID0+IHN0cmluZyB8IHVuZGVmaW5lZCwgdGFyZ2V0OiBUKTogYm9vbGVhbiA9PiB7XG4gICAgICB0aGlzLnJlc2V0TWF0Y2hlcygpO1xuXG4gICAgICBpZiAoIXRoaXMuX3JlZ0V4cC5ldmVyeSgocmVnLCBpbmRleCkgPT4gdGhpcy5hZGRNYXRjaChyZWcsIGluZGV4LCBsaW5lKGluZGV4KSkpKSB7XG4gICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnVzZU1hdGNoZXModGFyZ2V0LCB0aGlzLnByZXBhcmVNYXRjaGVzKCkpICE9PSBmYWxzZTtcbiAgIH07XG5cbiAgIC8vIEB0cy1pZ25vcmVcbiAgIHByb3RlY3RlZCB1c2VNYXRjaGVzKHRhcmdldDogVCwgbWF0Y2g6IHN0cmluZ1tdKTogYm9vbGVhbiB8IHZvaWQge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBMaW5lUGFyc2VyOnVzZU1hdGNoZXMgbm90IGltcGxlbWVudGVkYCk7XG4gICB9XG5cbiAgIHByb3RlY3RlZCByZXNldE1hdGNoZXMoKSB7XG4gICAgICB0aGlzLm1hdGNoZXMubGVuZ3RoID0gMDtcbiAgIH1cblxuICAgcHJvdGVjdGVkIHByZXBhcmVNYXRjaGVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWF0Y2hlcztcbiAgIH1cblxuICAgcHJvdGVjdGVkIGFkZE1hdGNoKHJlZzogUmVnRXhwLCBpbmRleDogbnVtYmVyLCBsaW5lPzogc3RyaW5nKSB7XG4gICAgICBjb25zdCBtYXRjaGVkID0gbGluZSAmJiByZWcuZXhlYyhsaW5lKTtcbiAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICB0aGlzLnB1c2hNYXRjaChpbmRleCwgbWF0Y2hlZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAhIW1hdGNoZWQ7XG4gICB9XG5cbiAgIHByb3RlY3RlZCBwdXNoTWF0Y2goX2luZGV4OiBudW1iZXIsIG1hdGNoZWQ6IHN0cmluZ1tdKSB7XG4gICAgICB0aGlzLm1hdGNoZXMucHVzaCguLi5tYXRjaGVkLnNsaWNlKDEpKTtcbiAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJlbW90ZUxpbmVQYXJzZXI8VD4gZXh0ZW5kcyBMaW5lUGFyc2VyPFQ+IHtcbiAgIHByb3RlY3RlZCBhZGRNYXRjaChyZWc6IFJlZ0V4cCwgaW5kZXg6IG51bWJlciwgbGluZT86IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIC9ecmVtb3RlOlxccy8udGVzdChTdHJpbmcobGluZSkpICYmIHN1cGVyLmFkZE1hdGNoKHJlZywgaW5kZXgsIGxpbmUpO1xuICAgfVxuXG4gICBwcm90ZWN0ZWQgcHVzaE1hdGNoKGluZGV4OiBudW1iZXIsIG1hdGNoZWQ6IHN0cmluZ1tdKSB7XG4gICAgICBpZiAoaW5kZXggPiAwIHx8IG1hdGNoZWQubGVuZ3RoID4gMSkge1xuICAgICAgICAgc3VwZXIucHVzaE1hdGNoKGluZGV4LCBtYXRjaGVkKTtcbiAgICAgIH1cbiAgIH1cbn1cbiIsICJpbXBvcnQgeyBTaW1wbGVHaXRPcHRpb25zIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5jb25zdCBkZWZhdWx0T3B0aW9uczogT21pdDxTaW1wbGVHaXRPcHRpb25zLCAnYmFzZURpcic+ID0ge1xuICAgYmluYXJ5OiAnZ2l0JyxcbiAgIG1heENvbmN1cnJlbnRQcm9jZXNzZXM6IDUsXG4gICBjb25maWc6IFtdLFxuICAgdHJpbW1lZDogZmFsc2UsXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VDb25maWcoXG4gICAuLi5vcHRpb25zOiBBcnJheTxQYXJ0aWFsPFNpbXBsZUdpdE9wdGlvbnM+IHwgdW5kZWZpbmVkPlxuKTogU2ltcGxlR2l0T3B0aW9ucyB7XG4gICBjb25zdCBiYXNlRGlyID0gcHJvY2Vzcy5jd2QoKTtcbiAgIGNvbnN0IGNvbmZpZzogU2ltcGxlR2l0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICB7IGJhc2VEaXIsIC4uLmRlZmF1bHRPcHRpb25zIH0sXG4gICAgICAuLi5vcHRpb25zLmZpbHRlcigobykgPT4gdHlwZW9mIG8gPT09ICdvYmplY3QnICYmIG8pXG4gICApO1xuXG4gICBjb25maWcuYmFzZURpciA9IGNvbmZpZy5iYXNlRGlyIHx8IGJhc2VEaXI7XG4gICBjb25maWcudHJpbW1lZCA9IGNvbmZpZy50cmltbWVkID09PSB0cnVlO1xuXG4gICByZXR1cm4gY29uZmlnO1xufVxuIiwgImltcG9ydCB7XG4gICBmaWx0ZXJBcnJheSxcbiAgIGZpbHRlckZ1bmN0aW9uLFxuICAgZmlsdGVyUGxhaW5PYmplY3QsXG4gICBmaWx0ZXJQcmltaXRpdmVzLFxuICAgZmlsdGVyVHlwZSxcbn0gZnJvbSAnLi9hcmd1bWVudC1maWx0ZXJzJztcbmltcG9ydCB7IGFzRnVuY3Rpb24sIGlzVXNlckZ1bmN0aW9uLCBsYXN0IH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCB7IE1heWJlLCBPcHRpb25zLCBPcHRpb25zVmFsdWVzIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgaXNQYXRoU3BlYyB9IGZyb20gJy4uL2FyZ3MvcGF0aHNwZWMnO1xuXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kVGFza09wdGlvbnM8VCBleHRlbmRzIE9wdGlvbnMgPSBPcHRpb25zPihcbiAgIG9wdGlvbnM6IE1heWJlPFQ+LFxuICAgY29tbWFuZHM6IHN0cmluZ1tdID0gW11cbik6IHN0cmluZ1tdIHtcbiAgIGlmICghZmlsdGVyUGxhaW5PYmplY3Q8T3B0aW9ucz4ob3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBjb21tYW5kcztcbiAgIH1cblxuICAgcmV0dXJuIE9iamVjdC5rZXlzKG9wdGlvbnMpLnJlZHVjZSgoY29tbWFuZHM6IHN0cmluZ1tdLCBrZXk6IHN0cmluZykgPT4ge1xuICAgICAgY29uc3QgdmFsdWU6IE9wdGlvbnNWYWx1ZXMgPSBvcHRpb25zW2tleV07XG5cbiAgICAgIGlmIChpc1BhdGhTcGVjKHZhbHVlKSkge1xuICAgICAgICAgY29tbWFuZHMucHVzaCh2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGZpbHRlclByaW1pdGl2ZXModmFsdWUsIFsnYm9vbGVhbiddKSkge1xuICAgICAgICAgY29tbWFuZHMucHVzaChrZXkgKyAnPScgKyB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgY29tbWFuZHMucHVzaChrZXkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29tbWFuZHM7XG4gICB9LCBjb21tYW5kcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUcmFpbGluZ09wdGlvbnMoXG4gICBhcmdzOiBJQXJndW1lbnRzLFxuICAgaW5pdGlhbFByaW1pdGl2ZSA9IDAsXG4gICBvYmplY3RPbmx5ID0gZmFsc2Vcbik6IHN0cmluZ1tdIHtcbiAgIGNvbnN0IGNvbW1hbmQ6IHN0cmluZ1tdID0gW107XG5cbiAgIGZvciAobGV0IGkgPSAwLCBtYXggPSBpbml0aWFsUHJpbWl0aXZlIDwgMCA/IGFyZ3MubGVuZ3RoIDogaW5pdGlhbFByaW1pdGl2ZTsgaSA8IG1heDsgaSsrKSB7XG4gICAgICBpZiAoJ3N0cmluZ3xudW1iZXInLmluY2x1ZGVzKHR5cGVvZiBhcmdzW2ldKSkge1xuICAgICAgICAgY29tbWFuZC5wdXNoKFN0cmluZyhhcmdzW2ldKSk7XG4gICAgICB9XG4gICB9XG5cbiAgIGFwcGVuZFRhc2tPcHRpb25zKHRyYWlsaW5nT3B0aW9uc0FyZ3VtZW50KGFyZ3MpLCBjb21tYW5kKTtcbiAgIGlmICghb2JqZWN0T25seSkge1xuICAgICAgY29tbWFuZC5wdXNoKC4uLnRyYWlsaW5nQXJyYXlBcmd1bWVudChhcmdzKSk7XG4gICB9XG5cbiAgIHJldHVybiBjb21tYW5kO1xufVxuXG5mdW5jdGlvbiB0cmFpbGluZ0FycmF5QXJndW1lbnQoYXJnczogSUFyZ3VtZW50cykge1xuICAgY29uc3QgaGFzVHJhaWxpbmdDYWxsYmFjayA9IHR5cGVvZiBsYXN0KGFyZ3MpID09PSAnZnVuY3Rpb24nO1xuICAgcmV0dXJuIGZpbHRlclR5cGUobGFzdChhcmdzLCBoYXNUcmFpbGluZ0NhbGxiYWNrID8gMSA6IDApLCBmaWx0ZXJBcnJheSwgW10pO1xufVxuXG4vKipcbiAqIEdpdmVuIGFueSBudW1iZXIgb2YgYXJndW1lbnRzLCByZXR1cm5zIHRoZSB0cmFpbGluZyBvcHRpb25zIGFyZ3VtZW50LCBpZ25vcmluZyBhIHRyYWlsaW5nIGZ1bmN0aW9uIGFyZ3VtZW50XG4gKiBpZiB0aGVyZSBpcyBvbmUuIFdoZW4gbm90IGZvdW5kLCB0aGUgcmV0dXJuIHZhbHVlIGlzIG51bGwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFpbGluZ09wdGlvbnNBcmd1bWVudChhcmdzOiBJQXJndW1lbnRzKTogTWF5YmU8T3B0aW9ucz4ge1xuICAgY29uc3QgaGFzVHJhaWxpbmdDYWxsYmFjayA9IGZpbHRlckZ1bmN0aW9uKGxhc3QoYXJncykpO1xuICAgcmV0dXJuIGZpbHRlclR5cGUobGFzdChhcmdzLCBoYXNUcmFpbGluZ0NhbGxiYWNrID8gMSA6IDApLCBmaWx0ZXJQbGFpbk9iamVjdCk7XG59XG5cbi8qKlxuICogUmV0dXJucyBlaXRoZXIgdGhlIHNvdXJjZSBhcmd1bWVudCB3aGVuIGl0IGlzIGEgYEZ1bmN0aW9uYCwgb3IgdGhlIGRlZmF1bHRcbiAqIGBOT09QYCBmdW5jdGlvbiBjb25zdGFudFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KFxuICAgYXJnczogdW5rbm93bltdIHwgSUFyZ3VtZW50cyB8IHVua25vd24sXG4gICBpbmNsdWRlTm9vcCA9IHRydWVcbik6IE1heWJlPCguLi5hcmdzOiBhbnlbXSkgPT4gdW5rbm93bj4ge1xuICAgY29uc3QgY2FsbGJhY2sgPSBhc0Z1bmN0aW9uKGxhc3QoYXJncykpO1xuICAgcmV0dXJuIGluY2x1ZGVOb29wIHx8IGlzVXNlckZ1bmN0aW9uKGNhbGxiYWNrKSA/IGNhbGxiYWNrIDogdW5kZWZpbmVkO1xufVxuIiwgImltcG9ydCB0eXBlIHsgTWF5YmVBcnJheSwgVGFza1BhcnNlciwgVGFza1Jlc3BvbnNlRm9ybWF0IH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgR2l0T3V0cHV0U3RyZWFtcyB9IGZyb20gJy4vZ2l0LW91dHB1dC1zdHJlYW1zJztcbmltcG9ydCB7IExpbmVQYXJzZXIgfSBmcm9tICcuL2xpbmUtcGFyc2VyJztcbmltcG9ydCB7IGFzQXJyYXksIHRvTGluZXNXaXRoQ29udGVudCB9IGZyb20gJy4vdXRpbCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxsVGFza1BhcnNlcjxJTlBVVCBleHRlbmRzIFRhc2tSZXNwb25zZUZvcm1hdCwgUkVTUE9OU0U+KFxuICAgcGFyc2VyOiBUYXNrUGFyc2VyPElOUFVULCBSRVNQT05TRT4sXG4gICBzdHJlYW1zOiBHaXRPdXRwdXRTdHJlYW1zPElOUFVUPlxuKSB7XG4gICByZXR1cm4gcGFyc2VyKHN0cmVhbXMuc3RkT3V0LCBzdHJlYW1zLnN0ZEVycik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVN0cmluZ1Jlc3BvbnNlPFQ+KFxuICAgcmVzdWx0OiBULFxuICAgcGFyc2VyczogTGluZVBhcnNlcjxUPltdLFxuICAgdGV4dHM6IE1heWJlQXJyYXk8c3RyaW5nPixcbiAgIHRyaW0gPSB0cnVlXG4pOiBUIHtcbiAgIGFzQXJyYXkodGV4dHMpLmZvckVhY2goKHRleHQpID0+IHtcbiAgICAgIGZvciAobGV0IGxpbmVzID0gdG9MaW5lc1dpdGhDb250ZW50KHRleHQsIHRyaW0pLCBpID0gMCwgbWF4ID0gbGluZXMubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgICAgIGNvbnN0IGxpbmUgPSAob2Zmc2V0ID0gMCkgPT4ge1xuICAgICAgICAgICAgaWYgKGkgKyBvZmZzZXQgPj0gbWF4KSB7XG4gICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGluZXNbaSArIG9mZnNldF07XG4gICAgICAgICB9O1xuXG4gICAgICAgICBwYXJzZXJzLnNvbWUoKHsgcGFyc2UgfSkgPT4gcGFyc2UobGluZSwgcmVzdWx0KSk7XG4gICAgICB9XG4gICB9KTtcblxuICAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsICJleHBvcnQgKiBmcm9tICcuL2FyZ3VtZW50LWZpbHRlcnMnO1xuZXhwb3J0ICogZnJvbSAnLi9leGl0LWNvZGVzJztcbmV4cG9ydCAqIGZyb20gJy4vZ2l0LW91dHB1dC1zdHJlYW1zJztcbmV4cG9ydCAqIGZyb20gJy4vbGluZS1wYXJzZXInO1xuZXhwb3J0ICogZnJvbSAnLi9zaW1wbGUtZ2l0LW9wdGlvbnMnO1xuZXhwb3J0ICogZnJvbSAnLi90YXNrLW9wdGlvbnMnO1xuZXhwb3J0ICogZnJvbSAnLi90YXNrLXBhcnNlcic7XG5leHBvcnQgKiBmcm9tICcuL3V0aWwnO1xuIiwgImltcG9ydCB7IEV4aXRDb2RlcyB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IE1heWJlLCBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgZW51bSBDaGVja1JlcG9BY3Rpb25zIHtcbiAgIEJBUkUgPSAnYmFyZScsXG4gICBJTl9UUkVFID0gJ3RyZWUnLFxuICAgSVNfUkVQT19ST09UID0gJ3Jvb3QnLFxufVxuXG5jb25zdCBvbkVycm9yOiBTdHJpbmdUYXNrPGJvb2xlYW4+WydvbkVycm9yJ10gPSAoeyBleGl0Q29kZSB9LCBlcnJvciwgZG9uZSwgZmFpbCkgPT4ge1xuICAgaWYgKGV4aXRDb2RlID09PSBFeGl0Q29kZXMuVU5DTEVBTiAmJiBpc05vdFJlcG9NZXNzYWdlKGVycm9yKSkge1xuICAgICAgcmV0dXJuIGRvbmUoQnVmZmVyLmZyb20oJ2ZhbHNlJykpO1xuICAgfVxuXG4gICBmYWlsKGVycm9yKTtcbn07XG5cbmNvbnN0IHBhcnNlcjogU3RyaW5nVGFzazxib29sZWFuPlsncGFyc2VyJ10gPSAodGV4dCkgPT4ge1xuICAgcmV0dXJuIHRleHQudHJpbSgpID09PSAndHJ1ZSc7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tJc1JlcG9UYXNrKGFjdGlvbjogTWF5YmU8Q2hlY2tSZXBvQWN0aW9ucz4pOiBTdHJpbmdUYXNrPGJvb2xlYW4+IHtcbiAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICBjYXNlIENoZWNrUmVwb0FjdGlvbnMuQkFSRTpcbiAgICAgICAgIHJldHVybiBjaGVja0lzQmFyZVJlcG9UYXNrKCk7XG4gICAgICBjYXNlIENoZWNrUmVwb0FjdGlvbnMuSVNfUkVQT19ST09UOlxuICAgICAgICAgcmV0dXJuIGNoZWNrSXNSZXBvUm9vdFRhc2soKTtcbiAgIH1cblxuICAgY29uc3QgY29tbWFuZHMgPSBbJ3Jldi1wYXJzZScsICctLWlzLWluc2lkZS13b3JrLXRyZWUnXTtcblxuICAgcmV0dXJuIHtcbiAgICAgIGNvbW1hbmRzLFxuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgb25FcnJvcixcbiAgICAgIHBhcnNlcixcbiAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0lzUmVwb1Jvb3RUYXNrKCk6IFN0cmluZ1Rhc2s8Ym9vbGVhbj4ge1xuICAgY29uc3QgY29tbWFuZHMgPSBbJ3Jldi1wYXJzZScsICctLWdpdC1kaXInXTtcblxuICAgcmV0dXJuIHtcbiAgICAgIGNvbW1hbmRzLFxuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgb25FcnJvcixcbiAgICAgIHBhcnNlcihwYXRoKSB7XG4gICAgICAgICByZXR1cm4gL15cXC4oZ2l0KT8kLy50ZXN0KHBhdGgudHJpbSgpKTtcbiAgICAgIH0sXG4gICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tJc0JhcmVSZXBvVGFzaygpOiBTdHJpbmdUYXNrPGJvb2xlYW4+IHtcbiAgIGNvbnN0IGNvbW1hbmRzID0gWydyZXYtcGFyc2UnLCAnLS1pcy1iYXJlLXJlcG9zaXRvcnknXTtcblxuICAgcmV0dXJuIHtcbiAgICAgIGNvbW1hbmRzLFxuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgb25FcnJvcixcbiAgICAgIHBhcnNlcixcbiAgIH07XG59XG5cbmZ1bmN0aW9uIGlzTm90UmVwb01lc3NhZ2UoZXJyb3I6IEVycm9yKTogYm9vbGVhbiB7XG4gICByZXR1cm4gLyhOb3QgYSBnaXQgcmVwb3NpdG9yeXxLZWluIEdpdC1SZXBvc2l0b3J5KS9pLnRlc3QoU3RyaW5nKGVycm9yKSk7XG59XG4iLCAiaW1wb3J0IHsgQ2xlYW5TdW1tYXJ5IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyB0b0xpbmVzV2l0aENvbnRlbnQgfSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBjbGFzcyBDbGVhblJlc3BvbnNlIGltcGxlbWVudHMgQ2xlYW5TdW1tYXJ5IHtcbiAgIHB1YmxpYyBwYXRoczogc3RyaW5nW10gPSBbXTtcbiAgIHB1YmxpYyBmaWxlczogc3RyaW5nW10gPSBbXTtcbiAgIHB1YmxpYyBmb2xkZXJzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgZHJ5UnVuOiBib29sZWFuKSB7fVxufVxuXG5jb25zdCByZW1vdmFsUmVnZXhwID0gL15bYS16XStcXHMqL2k7XG5jb25zdCBkcnlSdW5SZW1vdmFsUmVnZXhwID0gL15bYS16XStcXHMrW2Etel0rXFxzKi9pO1xuY29uc3QgaXNGb2xkZXJSZWdleHAgPSAvXFwvJC87XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGVhblN1bW1hcnlQYXJzZXIoZHJ5UnVuOiBib29sZWFuLCB0ZXh0OiBzdHJpbmcpOiBDbGVhblN1bW1hcnkge1xuICAgY29uc3Qgc3VtbWFyeSA9IG5ldyBDbGVhblJlc3BvbnNlKGRyeVJ1bik7XG4gICBjb25zdCByZWdleHAgPSBkcnlSdW4gPyBkcnlSdW5SZW1vdmFsUmVnZXhwIDogcmVtb3ZhbFJlZ2V4cDtcblxuICAgdG9MaW5lc1dpdGhDb250ZW50KHRleHQpLmZvckVhY2goKGxpbmUpID0+IHtcbiAgICAgIGNvbnN0IHJlbW92ZWQgPSBsaW5lLnJlcGxhY2UocmVnZXhwLCAnJyk7XG5cbiAgICAgIHN1bW1hcnkucGF0aHMucHVzaChyZW1vdmVkKTtcbiAgICAgIChpc0ZvbGRlclJlZ2V4cC50ZXN0KHJlbW92ZWQpID8gc3VtbWFyeS5mb2xkZXJzIDogc3VtbWFyeS5maWxlcykucHVzaChyZW1vdmVkKTtcbiAgIH0pO1xuXG4gICByZXR1cm4gc3VtbWFyeTtcbn1cbiIsICJpbXBvcnQgeyBUYXNrQ29uZmlndXJhdGlvbkVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL3Rhc2stY29uZmlndXJhdGlvbi1lcnJvcic7XG5pbXBvcnQgdHlwZSB7IEJ1ZmZlclRhc2ssIEVtcHR5VGFza1BhcnNlciwgU2ltcGxlR2l0VGFzaywgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGNvbnN0IEVNUFRZX0NPTU1BTkRTOiBbXSA9IFtdO1xuXG5leHBvcnQgdHlwZSBFbXB0eVRhc2sgPSB7XG4gICBjb21tYW5kczogdHlwZW9mIEVNUFRZX0NPTU1BTkRTO1xuICAgZm9ybWF0OiAnZW1wdHknO1xuICAgcGFyc2VyOiBFbXB0eVRhc2tQYXJzZXI7XG4gICBvbkVycm9yPzogdW5kZWZpbmVkO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGFkaG9jRXhlY1Rhc2socGFyc2VyOiBFbXB0eVRhc2tQYXJzZXIpOiBFbXB0eVRhc2sge1xuICAgcmV0dXJuIHtcbiAgICAgIGNvbW1hbmRzOiBFTVBUWV9DT01NQU5EUyxcbiAgICAgIGZvcm1hdDogJ2VtcHR5JyxcbiAgICAgIHBhcnNlcixcbiAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25maWd1cmF0aW9uRXJyb3JUYXNrKGVycm9yOiBFcnJvciB8IHN0cmluZyk6IEVtcHR5VGFzayB7XG4gICByZXR1cm4ge1xuICAgICAgY29tbWFuZHM6IEVNUFRZX0NPTU1BTkRTLFxuICAgICAgZm9ybWF0OiAnZW1wdHknLFxuICAgICAgcGFyc2VyKCkge1xuICAgICAgICAgdGhyb3cgdHlwZW9mIGVycm9yID09PSAnc3RyaW5nJyA/IG5ldyBUYXNrQ29uZmlndXJhdGlvbkVycm9yKGVycm9yKSA6IGVycm9yO1xuICAgICAgfSxcbiAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKGNvbW1hbmRzOiBzdHJpbmdbXSwgdHJpbW1lZCA9IGZhbHNlKTogU3RyaW5nVGFzazxzdHJpbmc+IHtcbiAgIHJldHVybiB7XG4gICAgICBjb21tYW5kcyxcbiAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgIHBhcnNlcih0ZXh0KSB7XG4gICAgICAgICByZXR1cm4gdHJpbW1lZCA/IFN0cmluZyh0ZXh0KS50cmltKCkgOiB0ZXh0O1xuICAgICAgfSxcbiAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJhaWdodFRocm91Z2hCdWZmZXJUYXNrKGNvbW1hbmRzOiBzdHJpbmdbXSk6IEJ1ZmZlclRhc2s8YW55PiB7XG4gICByZXR1cm4ge1xuICAgICAgY29tbWFuZHMsXG4gICAgICBmb3JtYXQ6ICdidWZmZXInLFxuICAgICAgcGFyc2VyKGJ1ZmZlcikge1xuICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgIH0sXG4gICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNCdWZmZXJUYXNrPFI+KHRhc2s6IFNpbXBsZUdpdFRhc2s8Uj4pOiB0YXNrIGlzIEJ1ZmZlclRhc2s8Uj4ge1xuICAgcmV0dXJuIHRhc2suZm9ybWF0ID09PSAnYnVmZmVyJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRW1wdHlUYXNrPFI+KHRhc2s6IFNpbXBsZUdpdFRhc2s8Uj4pOiB0YXNrIGlzIEVtcHR5VGFzayB7XG4gICByZXR1cm4gdGFzay5mb3JtYXQgPT09ICdlbXB0eScgfHwgIXRhc2suY29tbWFuZHMubGVuZ3RoO1xufVxuIiwgImltcG9ydCB7IENsZWFuU3VtbWFyeSB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgY2xlYW5TdW1tYXJ5UGFyc2VyIH0gZnJvbSAnLi4vcmVzcG9uc2VzL0NsZWFuU3VtbWFyeSc7XG5pbXBvcnQgeyBNYXliZSwgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGFzU3RyaW5nQXJyYXkgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBjb25maWd1cmF0aW9uRXJyb3JUYXNrIH0gZnJvbSAnLi90YXNrJztcblxuZXhwb3J0IGNvbnN0IENPTkZJR19FUlJPUl9JTlRFUkFDVElWRV9NT0RFID0gJ0dpdCBjbGVhbiBpbnRlcmFjdGl2ZSBtb2RlIGlzIG5vdCBzdXBwb3J0ZWQnO1xuZXhwb3J0IGNvbnN0IENPTkZJR19FUlJPUl9NT0RFX1JFUVVJUkVEID0gJ0dpdCBjbGVhbiBtb2RlIHBhcmFtZXRlciAoXCJuXCIgb3IgXCJmXCIpIGlzIHJlcXVpcmVkJztcbmV4cG9ydCBjb25zdCBDT05GSUdfRVJST1JfVU5LTk9XTl9PUFRJT04gPSAnR2l0IGNsZWFuIHVua25vd24gb3B0aW9uIGZvdW5kIGluOiAnO1xuXG4vKipcbiAqIEFsbCBzdXBwb3J0ZWQgb3B0aW9uIHN3aXRjaGVzIGF2YWlsYWJsZSBmb3IgdXNlIGluIGEgYGdpdC5jbGVhbmAgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydCBlbnVtIENsZWFuT3B0aW9ucyB7XG4gICBEUllfUlVOID0gJ24nLFxuICAgRk9SQ0UgPSAnZicsXG4gICBJR05PUkVEX0lOQ0xVREVEID0gJ3gnLFxuICAgSUdOT1JFRF9PTkxZID0gJ1gnLFxuICAgRVhDTFVESU5HID0gJ2UnLFxuICAgUVVJRVQgPSAncScsXG4gICBSRUNVUlNJVkUgPSAnZCcsXG59XG5cbi8qKlxuICogVGhlIHR3byBtb2RlcyBgZ2l0LmNsZWFuYCBjYW4gcnVuIGluIC0gb25lIG9mIHRoZXNlIG11c3QgYmUgc3VwcGxpZWQgaW4gb3JkZXJcbiAqIGZvciB0aGUgY29tbWFuZCB0byBub3QgdGhyb3cgYSBgVGFza0NvbmZpZ3VyYXRpb25FcnJvcmBcbiAqL1xuZXhwb3J0IHR5cGUgQ2xlYW5Nb2RlID0gQ2xlYW5PcHRpb25zLkZPUkNFIHwgQ2xlYW5PcHRpb25zLkRSWV9SVU47XG5cbmNvbnN0IENsZWFuT3B0aW9uVmFsdWVzOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQoW1xuICAgJ2knLFxuICAgLi4uYXNTdHJpbmdBcnJheShPYmplY3QudmFsdWVzKENsZWFuT3B0aW9ucyBhcyBhbnkpKSxcbl0pO1xuXG5leHBvcnQgZnVuY3Rpb24gY2xlYW5XaXRoT3B0aW9uc1Rhc2sobW9kZTogQ2xlYW5Nb2RlIHwgc3RyaW5nLCBjdXN0b21BcmdzOiBzdHJpbmdbXSkge1xuICAgY29uc3QgeyBjbGVhbk1vZGUsIG9wdGlvbnMsIHZhbGlkIH0gPSBnZXRDbGVhbk9wdGlvbnMobW9kZSk7XG5cbiAgIGlmICghY2xlYW5Nb2RlKSB7XG4gICAgICByZXR1cm4gY29uZmlndXJhdGlvbkVycm9yVGFzayhDT05GSUdfRVJST1JfTU9ERV9SRVFVSVJFRCk7XG4gICB9XG5cbiAgIGlmICghdmFsaWQub3B0aW9ucykge1xuICAgICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25FcnJvclRhc2soQ09ORklHX0VSUk9SX1VOS05PV05fT1BUSU9OICsgSlNPTi5zdHJpbmdpZnkobW9kZSkpO1xuICAgfVxuXG4gICBvcHRpb25zLnB1c2goLi4uY3VzdG9tQXJncyk7XG5cbiAgIGlmIChvcHRpb25zLnNvbWUoaXNJbnRlcmFjdGl2ZU1vZGUpKSB7XG4gICAgICByZXR1cm4gY29uZmlndXJhdGlvbkVycm9yVGFzayhDT05GSUdfRVJST1JfSU5URVJBQ1RJVkVfTU9ERSk7XG4gICB9XG5cbiAgIHJldHVybiBjbGVhblRhc2soY2xlYW5Nb2RlLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFuVGFzayhtb2RlOiBDbGVhbk1vZGUsIGN1c3RvbUFyZ3M6IHN0cmluZ1tdKTogU3RyaW5nVGFzazxDbGVhblN1bW1hcnk+IHtcbiAgIGNvbnN0IGNvbW1hbmRzOiBzdHJpbmdbXSA9IFsnY2xlYW4nLCBgLSR7bW9kZX1gLCAuLi5jdXN0b21BcmdzXTtcblxuICAgcmV0dXJuIHtcbiAgICAgIGNvbW1hbmRzLFxuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgcGFyc2VyKHRleHQ6IHN0cmluZyk6IENsZWFuU3VtbWFyeSB7XG4gICAgICAgICByZXR1cm4gY2xlYW5TdW1tYXJ5UGFyc2VyKG1vZGUgPT09IENsZWFuT3B0aW9ucy5EUllfUlVOLCB0ZXh0KTtcbiAgICAgIH0sXG4gICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNDbGVhbk9wdGlvbnNBcnJheShpbnB1dDogc3RyaW5nW10pOiBpbnB1dCBpcyBDbGVhbk9wdGlvbnNbXSB7XG4gICByZXR1cm4gQXJyYXkuaXNBcnJheShpbnB1dCkgJiYgaW5wdXQuZXZlcnkoKHRlc3QpID0+IENsZWFuT3B0aW9uVmFsdWVzLmhhcyh0ZXN0KSk7XG59XG5cbmZ1bmN0aW9uIGdldENsZWFuT3B0aW9ucyhpbnB1dDogc3RyaW5nKSB7XG4gICBsZXQgY2xlYW5Nb2RlOiBNYXliZTxDbGVhbk1vZGU+O1xuICAgbGV0IG9wdGlvbnM6IHN0cmluZ1tdID0gW107XG4gICBsZXQgdmFsaWQgPSB7IGNsZWFuTW9kZTogZmFsc2UsIG9wdGlvbnM6IHRydWUgfTtcblxuICAgaW5wdXRcbiAgICAgIC5yZXBsYWNlKC9bXmEtel1pL2csICcnKVxuICAgICAgLnNwbGl0KCcnKVxuICAgICAgLmZvckVhY2goKGNoYXIpID0+IHtcbiAgICAgICAgIGlmIChpc0NsZWFuTW9kZShjaGFyKSkge1xuICAgICAgICAgICAgY2xlYW5Nb2RlID0gY2hhcjtcbiAgICAgICAgICAgIHZhbGlkLmNsZWFuTW9kZSA9IHRydWU7XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsaWQub3B0aW9ucyA9IHZhbGlkLm9wdGlvbnMgJiYgaXNLbm93bk9wdGlvbigob3B0aW9uc1tvcHRpb25zLmxlbmd0aF0gPSBgLSR7Y2hhcn1gKSk7XG4gICAgICAgICB9XG4gICAgICB9KTtcblxuICAgcmV0dXJuIHtcbiAgICAgIGNsZWFuTW9kZSxcbiAgICAgIG9wdGlvbnMsXG4gICAgICB2YWxpZCxcbiAgIH07XG59XG5cbmZ1bmN0aW9uIGlzQ2xlYW5Nb2RlKGNsZWFuTW9kZT86IHN0cmluZyk6IGNsZWFuTW9kZSBpcyBDbGVhbk1vZGUge1xuICAgcmV0dXJuIGNsZWFuTW9kZSA9PT0gQ2xlYW5PcHRpb25zLkZPUkNFIHx8IGNsZWFuTW9kZSA9PT0gQ2xlYW5PcHRpb25zLkRSWV9SVU47XG59XG5cbmZ1bmN0aW9uIGlzS25vd25PcHRpb24ob3B0aW9uOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgIHJldHVybiAvXi1bYS16XSQvaS50ZXN0KG9wdGlvbikgJiYgQ2xlYW5PcHRpb25WYWx1ZXMuaGFzKG9wdGlvbi5jaGFyQXQoMSkpO1xufVxuXG5mdW5jdGlvbiBpc0ludGVyYWN0aXZlTW9kZShvcHRpb246IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgaWYgKC9eLVteXFwtXS8udGVzdChvcHRpb24pKSB7XG4gICAgICByZXR1cm4gb3B0aW9uLmluZGV4T2YoJ2knKSA+IDA7XG4gICB9XG5cbiAgIHJldHVybiBvcHRpb24gPT09ICctLWludGVyYWN0aXZlJztcbn1cbiIsICJpbXBvcnQgeyBDb25maWdHZXRSZXN1bHQsIENvbmZpZ0xpc3RTdW1tYXJ5LCBDb25maWdWYWx1ZXMgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IGxhc3QsIHNwbGl0T24gfSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBjbGFzcyBDb25maWdMaXN0IGltcGxlbWVudHMgQ29uZmlnTGlzdFN1bW1hcnkge1xuICAgcHVibGljIGZpbGVzOiBzdHJpbmdbXSA9IFtdO1xuICAgcHVibGljIHZhbHVlczogeyBbZmlsZU5hbWU6IHN0cmluZ106IENvbmZpZ1ZhbHVlcyB9ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgcHJpdmF0ZSBfYWxsOiBDb25maWdWYWx1ZXMgfCB1bmRlZmluZWQ7XG5cbiAgIHB1YmxpYyBnZXQgYWxsKCk6IENvbmZpZ1ZhbHVlcyB7XG4gICAgICBpZiAoIXRoaXMuX2FsbCkge1xuICAgICAgICAgdGhpcy5fYWxsID0gdGhpcy5maWxlcy5yZWR1Y2UoKGFsbDogQ29uZmlnVmFsdWVzLCBmaWxlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGFsbCwgdGhpcy52YWx1ZXNbZmlsZV0pO1xuICAgICAgICAgfSwge30pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fYWxsO1xuICAgfVxuXG4gICBwdWJsaWMgYWRkRmlsZShmaWxlOiBzdHJpbmcpOiBDb25maWdWYWx1ZXMge1xuICAgICAgaWYgKCEoZmlsZSBpbiB0aGlzLnZhbHVlcykpIHtcbiAgICAgICAgIGNvbnN0IGxhdGVzdCA9IGxhc3QodGhpcy5maWxlcyk7XG4gICAgICAgICB0aGlzLnZhbHVlc1tmaWxlXSA9IGxhdGVzdCA/IE9iamVjdC5jcmVhdGUodGhpcy52YWx1ZXNbbGF0ZXN0XSkgOiB7fTtcblxuICAgICAgICAgdGhpcy5maWxlcy5wdXNoKGZpbGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy52YWx1ZXNbZmlsZV07XG4gICB9XG5cbiAgIHB1YmxpYyBhZGRWYWx1ZShmaWxlOiBzdHJpbmcsIGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSB7XG4gICAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLmFkZEZpbGUoZmlsZSk7XG5cbiAgICAgIGlmICghdmFsdWVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgIHZhbHVlc1trZXldID0gdmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzW2tleV0pKSB7XG4gICAgICAgICAodmFsdWVzW2tleV0gYXMgc3RyaW5nW10pLnB1c2godmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHZhbHVlc1trZXldID0gW3ZhbHVlc1trZXldIGFzIHN0cmluZywgdmFsdWVdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9hbGwgPSB1bmRlZmluZWQ7XG4gICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25maWdMaXN0UGFyc2VyKHRleHQ6IHN0cmluZyk6IENvbmZpZ0xpc3Qge1xuICAgY29uc3QgY29uZmlnID0gbmV3IENvbmZpZ0xpc3QoKTtcblxuICAgZm9yIChjb25zdCBpdGVtIG9mIGNvbmZpZ1BhcnNlcih0ZXh0KSkge1xuICAgICAgY29uZmlnLmFkZFZhbHVlKGl0ZW0uZmlsZSwgU3RyaW5nKGl0ZW0ua2V5KSwgaXRlbS52YWx1ZSk7XG4gICB9XG5cbiAgIHJldHVybiBjb25maWc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25maWdHZXRQYXJzZXIodGV4dDogc3RyaW5nLCBrZXk6IHN0cmluZyk6IENvbmZpZ0dldFJlc3VsdCB7XG4gICBsZXQgdmFsdWU6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICAgY29uc3QgdmFsdWVzOiBzdHJpbmdbXSA9IFtdO1xuICAgY29uc3Qgc2NvcGVzOiBNYXA8c3RyaW5nLCBzdHJpbmdbXT4gPSBuZXcgTWFwKCk7XG5cbiAgIGZvciAoY29uc3QgaXRlbSBvZiBjb25maWdQYXJzZXIodGV4dCwga2V5KSkge1xuICAgICAgaWYgKGl0ZW0ua2V5ICE9PSBrZXkpIHtcbiAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YWx1ZXMucHVzaCgodmFsdWUgPSBpdGVtLnZhbHVlKSk7XG5cbiAgICAgIGlmICghc2NvcGVzLmhhcyhpdGVtLmZpbGUpKSB7XG4gICAgICAgICBzY29wZXMuc2V0KGl0ZW0uZmlsZSwgW10pO1xuICAgICAgfVxuXG4gICAgICBzY29wZXMuZ2V0KGl0ZW0uZmlsZSkhLnB1c2godmFsdWUpO1xuICAgfVxuXG4gICByZXR1cm4ge1xuICAgICAga2V5LFxuICAgICAgcGF0aHM6IEFycmF5LmZyb20oc2NvcGVzLmtleXMoKSksXG4gICAgICBzY29wZXMsXG4gICAgICB2YWx1ZSxcbiAgICAgIHZhbHVlcyxcbiAgIH07XG59XG5cbmZ1bmN0aW9uIGNvbmZpZ0ZpbGVQYXRoKGZpbGVQYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgcmV0dXJuIGZpbGVQYXRoLnJlcGxhY2UoL14oZmlsZSk6LywgJycpO1xufVxuXG5mdW5jdGlvbiogY29uZmlnUGFyc2VyKHRleHQ6IHN0cmluZywgcmVxdWVzdGVkS2V5OiBzdHJpbmcgfCBudWxsID0gbnVsbCkge1xuICAgY29uc3QgbGluZXMgPSB0ZXh0LnNwbGl0KCdcXDAnKTtcblxuICAgZm9yIChsZXQgaSA9IDAsIG1heCA9IGxpbmVzLmxlbmd0aCAtIDE7IGkgPCBtYXg7ICkge1xuICAgICAgY29uc3QgZmlsZSA9IGNvbmZpZ0ZpbGVQYXRoKGxpbmVzW2krK10pO1xuXG4gICAgICBsZXQgdmFsdWUgPSBsaW5lc1tpKytdO1xuICAgICAgbGV0IGtleSA9IHJlcXVlc3RlZEtleTtcblxuICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKCdcXG4nKSkge1xuICAgICAgICAgY29uc3QgbGluZSA9IHNwbGl0T24odmFsdWUsICdcXG4nKTtcbiAgICAgICAgIGtleSA9IGxpbmVbMF07XG4gICAgICAgICB2YWx1ZSA9IGxpbmVbMV07XG4gICAgICB9XG5cbiAgICAgIHlpZWxkIHsgZmlsZSwga2V5LCB2YWx1ZSB9O1xuICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgQ29uZmlnR2V0UmVzdWx0LCBDb25maWdMaXN0U3VtbWFyeSwgU2ltcGxlR2l0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBjb25maWdHZXRQYXJzZXIsIGNvbmZpZ0xpc3RQYXJzZXIgfSBmcm9tICcuLi9yZXNwb25zZXMvQ29uZmlnTGlzdCc7XG5pbXBvcnQgdHlwZSB7IFNpbXBsZUdpdEFwaSB9IGZyb20gJy4uL3NpbXBsZS1naXQtYXBpJztcbmltcG9ydCB0eXBlIHsgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudCB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGVudW0gR2l0Q29uZmlnU2NvcGUge1xuICAgc3lzdGVtID0gJ3N5c3RlbScsXG4gICBnbG9iYWwgPSAnZ2xvYmFsJyxcbiAgIGxvY2FsID0gJ2xvY2FsJyxcbiAgIHdvcmt0cmVlID0gJ3dvcmt0cmVlJyxcbn1cblxuZnVuY3Rpb24gYXNDb25maWdTY29wZTxUIGV4dGVuZHMgR2l0Q29uZmlnU2NvcGUgfCB1bmRlZmluZWQ+KFxuICAgc2NvcGU6IEdpdENvbmZpZ1Njb3BlIHwgdW5rbm93bixcbiAgIGZhbGxiYWNrOiBUXG4pOiBHaXRDb25maWdTY29wZSB8IFQge1xuICAgaWYgKHR5cGVvZiBzY29wZSA9PT0gJ3N0cmluZycgJiYgR2l0Q29uZmlnU2NvcGUuaGFzT3duUHJvcGVydHkoc2NvcGUpKSB7XG4gICAgICByZXR1cm4gc2NvcGUgYXMgR2l0Q29uZmlnU2NvcGU7XG4gICB9XG4gICByZXR1cm4gZmFsbGJhY2s7XG59XG5cbmZ1bmN0aW9uIGFkZENvbmZpZ1Rhc2soXG4gICBrZXk6IHN0cmluZyxcbiAgIHZhbHVlOiBzdHJpbmcsXG4gICBhcHBlbmQ6IGJvb2xlYW4sXG4gICBzY29wZTogR2l0Q29uZmlnU2NvcGVcbik6IFN0cmluZ1Rhc2s8c3RyaW5nPiB7XG4gICBjb25zdCBjb21tYW5kczogc3RyaW5nW10gPSBbJ2NvbmZpZycsIGAtLSR7c2NvcGV9YF07XG5cbiAgIGlmIChhcHBlbmQpIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goJy0tYWRkJyk7XG4gICB9XG5cbiAgIGNvbW1hbmRzLnB1c2goa2V5LCB2YWx1ZSk7XG5cbiAgIHJldHVybiB7XG4gICAgICBjb21tYW5kcyxcbiAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgIHBhcnNlcih0ZXh0OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICB9LFxuICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29uZmlnVGFzayhrZXk6IHN0cmluZywgc2NvcGU/OiBHaXRDb25maWdTY29wZSk6IFN0cmluZ1Rhc2s8Q29uZmlnR2V0UmVzdWx0PiB7XG4gICBjb25zdCBjb21tYW5kczogc3RyaW5nW10gPSBbJ2NvbmZpZycsICctLW51bGwnLCAnLS1zaG93LW9yaWdpbicsICctLWdldC1hbGwnLCBrZXldO1xuXG4gICBpZiAoc2NvcGUpIHtcbiAgICAgIGNvbW1hbmRzLnNwbGljZSgxLCAwLCBgLS0ke3Njb3BlfWApO1xuICAgfVxuXG4gICByZXR1cm4ge1xuICAgICAgY29tbWFuZHMsXG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBwYXJzZXIodGV4dCkge1xuICAgICAgICAgcmV0dXJuIGNvbmZpZ0dldFBhcnNlcih0ZXh0LCBrZXkpO1xuICAgICAgfSxcbiAgIH07XG59XG5cbmZ1bmN0aW9uIGxpc3RDb25maWdUYXNrKHNjb3BlPzogR2l0Q29uZmlnU2NvcGUpOiBTdHJpbmdUYXNrPENvbmZpZ0xpc3RTdW1tYXJ5PiB7XG4gICBjb25zdCBjb21tYW5kcyA9IFsnY29uZmlnJywgJy0tbGlzdCcsICctLXNob3ctb3JpZ2luJywgJy0tbnVsbCddO1xuXG4gICBpZiAoc2NvcGUpIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goYC0tJHtzY29wZX1gKTtcbiAgIH1cblxuICAgcmV0dXJuIHtcbiAgICAgIGNvbW1hbmRzLFxuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgcGFyc2VyKHRleHQ6IHN0cmluZykge1xuICAgICAgICAgcmV0dXJuIGNvbmZpZ0xpc3RQYXJzZXIodGV4dCk7XG4gICAgICB9LFxuICAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCk6IFBpY2s8U2ltcGxlR2l0LCAnYWRkQ29uZmlnJyB8ICdnZXRDb25maWcnIHwgJ2xpc3RDb25maWcnPiB7XG4gICByZXR1cm4ge1xuICAgICAgYWRkQ29uZmlnKHRoaXM6IFNpbXBsZUdpdEFwaSwga2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcsIC4uLnJlc3Q6IHVua25vd25bXSkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgICBhZGRDb25maWdUYXNrKFxuICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICByZXN0WzBdID09PSB0cnVlLFxuICAgICAgICAgICAgICAgYXNDb25maWdTY29wZShyZXN0WzFdLCBHaXRDb25maWdTY29wZS5sb2NhbClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgICAgKTtcbiAgICAgIH0sXG5cbiAgICAgIGdldENvbmZpZyh0aGlzOiBTaW1wbGVHaXRBcGksIGtleTogc3RyaW5nLCBzY29wZT86IEdpdENvbmZpZ1Njb3BlKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgICAgIGdldENvbmZpZ1Rhc2soa2V5LCBhc0NvbmZpZ1Njb3BlKHNjb3BlLCB1bmRlZmluZWQpKSxcbiAgICAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICAgICApO1xuICAgICAgfSxcblxuICAgICAgbGlzdENvbmZpZyh0aGlzOiBTaW1wbGVHaXRBcGksIC4uLnJlc3Q6IHVua25vd25bXSkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgICBsaXN0Q29uZmlnVGFzayhhc0NvbmZpZ1Njb3BlKHJlc3RbMF0sIHVuZGVmaW5lZCkpLFxuICAgICAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICAgICk7XG4gICAgICB9LFxuICAgfTtcbn1cbiIsICJleHBvcnQgZW51bSBEaWZmTmFtZVN0YXR1cyB7XG4gICBBRERFRCA9ICdBJyxcbiAgIENPUElFRCA9ICdDJyxcbiAgIERFTEVURUQgPSAnRCcsXG4gICBNT0RJRklFRCA9ICdNJyxcbiAgIFJFTkFNRUQgPSAnUicsXG4gICBDSEFOR0VEID0gJ1QnLFxuICAgVU5NRVJHRUQgPSAnVScsXG4gICBVTktOT1dOID0gJ1gnLFxuICAgQlJPS0VOID0gJ0InLFxufVxuXG5jb25zdCBkaWZmTmFtZVN0YXR1cyA9IG5ldyBTZXQoT2JqZWN0LnZhbHVlcyhEaWZmTmFtZVN0YXR1cykpO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNEaWZmTmFtZVN0YXR1cyhpbnB1dDogc3RyaW5nKTogaW5wdXQgaXMgRGlmZk5hbWVTdGF0dXMge1xuICAgcmV0dXJuIGRpZmZOYW1lU3RhdHVzLmhhcyhpbnB1dCBhcyBEaWZmTmFtZVN0YXR1cyk7XG59XG4iLCAiaW1wb3J0IHsgR3JlcFJlc3VsdCwgU2ltcGxlR2l0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBTaW1wbGVHaXRBcGkgfSBmcm9tICcuLi9zaW1wbGUtZ2l0LWFwaSc7XG5pbXBvcnQge1xuICAgYXNOdW1iZXIsXG4gICBmb3JFYWNoTGluZVdpdGhDb250ZW50LFxuICAgZ2V0VHJhaWxpbmdPcHRpb25zLFxuICAgTlVMTCxcbiAgIHByZWZpeGVkQXJyYXksXG4gICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQsXG59IGZyb20gJy4uL3V0aWxzJztcblxuaW1wb3J0IHsgY29uZmlndXJhdGlvbkVycm9yVGFzayB9IGZyb20gJy4vdGFzayc7XG5cbmNvbnN0IGRpc2FsbG93ZWRPcHRpb25zID0gWyctaCddO1xuXG5jb25zdCBRdWVyeSA9IFN5bWJvbCgnZ3JlcFF1ZXJ5Jyk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2l0R3JlcFF1ZXJ5IGV4dGVuZHMgSXRlcmFibGU8c3RyaW5nPiB7XG4gICAvKiogQWRkcyBvbmUgb3IgbW9yZSB0ZXJtcyB0byBiZSBncm91cGVkIGFzIGFuIFwiYW5kXCIgdG8gYW55IG90aGVyIHRlcm1zICovXG4gICBhbmQoLi4uYW5kOiBzdHJpbmdbXSk6IHRoaXM7XG5cbiAgIC8qKiBBZGRzIG9uZSBvciBtb3JlIHNlYXJjaCB0ZXJtcyAtIGdpdC5ncmVwIHdpbGwgXCJvclwiIHRoaXMgdG8gb3RoZXIgdGVybXMgKi9cbiAgIHBhcmFtKC4uLnBhcmFtOiBzdHJpbmdbXSk6IHRoaXM7XG59XG5cbmNsYXNzIEdyZXBRdWVyeSBpbXBsZW1lbnRzIEdpdEdyZXBRdWVyeSB7XG4gICBwcml2YXRlIFtRdWVyeV06IHN0cmluZ1tdID0gW107XG5cbiAgICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgIGZvciAoY29uc3QgcXVlcnkgb2YgdGhpc1tRdWVyeV0pIHtcbiAgICAgICAgIHlpZWxkIHF1ZXJ5O1xuICAgICAgfVxuICAgfVxuXG4gICBhbmQoLi4uYW5kOiBzdHJpbmdbXSkge1xuICAgICAgYW5kLmxlbmd0aCAmJiB0aGlzW1F1ZXJ5XS5wdXNoKCctLWFuZCcsICcoJywgLi4ucHJlZml4ZWRBcnJheShhbmQsICctZScpLCAnKScpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICB9XG5cbiAgIHBhcmFtKC4uLnBhcmFtOiBzdHJpbmdbXSkge1xuICAgICAgdGhpc1tRdWVyeV0ucHVzaCguLi5wcmVmaXhlZEFycmF5KHBhcmFtLCAnLWUnKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGJ1aWxkZXIgZm9yIGEgYGdpdC5ncmVwYCBxdWVyeSB3aXRoIG9wdGlvbmFsIHBhcmFtc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ3JlcFF1ZXJ5QnVpbGRlciguLi5wYXJhbXM6IHN0cmluZ1tdKTogR2l0R3JlcFF1ZXJ5IHtcbiAgIHJldHVybiBuZXcgR3JlcFF1ZXJ5KCkucGFyYW0oLi4ucGFyYW1zKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VHcmVwKGdyZXA6IHN0cmluZyk6IEdyZXBSZXN1bHQge1xuICAgY29uc3QgcGF0aHM6IEdyZXBSZXN1bHRbJ3BhdGhzJ10gPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgIGNvbnN0IHJlc3VsdHM6IEdyZXBSZXN1bHRbJ3Jlc3VsdHMnXSA9IHt9O1xuXG4gICBmb3JFYWNoTGluZVdpdGhDb250ZW50KGdyZXAsIChpbnB1dCkgPT4ge1xuICAgICAgY29uc3QgW3BhdGgsIGxpbmUsIHByZXZpZXddID0gaW5wdXQuc3BsaXQoTlVMTCk7XG4gICAgICBwYXRocy5hZGQocGF0aCk7XG4gICAgICAocmVzdWx0c1twYXRoXSA9IHJlc3VsdHNbcGF0aF0gfHwgW10pLnB1c2goe1xuICAgICAgICAgbGluZTogYXNOdW1iZXIobGluZSksXG4gICAgICAgICBwYXRoLFxuICAgICAgICAgcHJldmlldyxcbiAgICAgIH0pO1xuICAgfSk7XG5cbiAgIHJldHVybiB7XG4gICAgICBwYXRocyxcbiAgICAgIHJlc3VsdHMsXG4gICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKTogUGljazxTaW1wbGVHaXQsICdncmVwJz4ge1xuICAgcmV0dXJuIHtcbiAgICAgIGdyZXAodGhpczogU2ltcGxlR2l0QXBpLCBzZWFyY2hUZXJtOiBzdHJpbmcgfCBHaXRHcmVwUXVlcnkpIHtcbiAgICAgICAgIGNvbnN0IHRoZW4gPSB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKTtcbiAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKTtcblxuICAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2YgZGlzYWxsb3dlZE9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmluY2x1ZGVzKG9wdGlvbikpIHtcbiAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgICAgICAgICAgY29uZmlndXJhdGlvbkVycm9yVGFzayhgZ2l0LmdyZXA6IHVzZSBvZiBcIiR7b3B0aW9ufVwiIGlzIG5vdCBzdXBwb3J0ZWQuYCksXG4gICAgICAgICAgICAgICAgICB0aGVuXG4gICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuXG4gICAgICAgICBpZiAodHlwZW9mIHNlYXJjaFRlcm0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzZWFyY2hUZXJtID0gZ3JlcFF1ZXJ5QnVpbGRlcigpLnBhcmFtKHNlYXJjaFRlcm0pO1xuICAgICAgICAgfVxuXG4gICAgICAgICBjb25zdCBjb21tYW5kcyA9IFsnZ3JlcCcsICctLW51bGwnLCAnLW4nLCAnLS1mdWxsLW5hbWUnLCAuLi5vcHRpb25zLCAuLi5zZWFyY2hUZXJtXTtcblxuICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICBjb21tYW5kcyxcbiAgICAgICAgICAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgICAgICAgICAgIHBhcnNlcihzdGRPdXQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUdyZXAoc3RkT3V0KTtcbiAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGhlblxuICAgICAgICAgKTtcbiAgICAgIH0sXG4gICB9O1xufVxuIiwgImltcG9ydCB7IHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2sgfSBmcm9tICcuL3Rhc2snO1xuaW1wb3J0IHsgTWF5YmUsIE9wdGlvbkZsYWdzLCBPcHRpb25zIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgZW51bSBSZXNldE1vZGUge1xuICAgTUlYRUQgPSAnbWl4ZWQnLFxuICAgU09GVCA9ICdzb2Z0JyxcbiAgIEhBUkQgPSAnaGFyZCcsXG4gICBNRVJHRSA9ICdtZXJnZScsXG4gICBLRUVQID0gJ2tlZXAnLFxufVxuXG5jb25zdCBSZXNldE1vZGVzID0gQXJyYXkuZnJvbShPYmplY3QudmFsdWVzKFJlc2V0TW9kZSkpO1xuXG5leHBvcnQgdHlwZSBSZXNldE9wdGlvbnMgPSBPcHRpb25zICZcbiAgIE9wdGlvbkZsYWdzPCctcScgfCAnLS1xdWlldCcgfCAnLS1uby1xdWlldCcgfCAnLS1wYXRoc3BlYy1mcm9tLW51bCc+ICZcbiAgIE9wdGlvbkZsYWdzPCctLXBhdGhzcGVjLWZyb20tZmlsZScsIHN0cmluZz47XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNldFRhc2sobW9kZTogTWF5YmU8UmVzZXRNb2RlPiwgY3VzdG9tQXJnczogc3RyaW5nW10pIHtcbiAgIGNvbnN0IGNvbW1hbmRzOiBzdHJpbmdbXSA9IFsncmVzZXQnXTtcbiAgIGlmIChpc1ZhbGlkUmVzZXRNb2RlKG1vZGUpKSB7XG4gICAgICBjb21tYW5kcy5wdXNoKGAtLSR7bW9kZX1gKTtcbiAgIH1cbiAgIGNvbW1hbmRzLnB1c2goLi4uY3VzdG9tQXJncyk7XG5cbiAgIHJldHVybiBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKGNvbW1hbmRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlc2V0TW9kZShtb2RlOiBSZXNldE1vZGUgfCBhbnkpOiBNYXliZTxSZXNldE1vZGU+IHtcbiAgIGlmIChpc1ZhbGlkUmVzZXRNb2RlKG1vZGUpKSB7XG4gICAgICByZXR1cm4gbW9kZTtcbiAgIH1cblxuICAgc3dpdGNoICh0eXBlb2YgbW9kZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgICByZXR1cm4gUmVzZXRNb2RlLlNPRlQ7XG4gICB9XG5cbiAgIHJldHVybjtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZFJlc2V0TW9kZShtb2RlOiBSZXNldE1vZGUgfCBhbnkpOiBtb2RlIGlzIFJlc2V0TW9kZSB7XG4gICByZXR1cm4gUmVzZXRNb2Rlcy5pbmNsdWRlcyhtb2RlKTtcbn1cbiIsICJpbXBvcnQgZGVidWcsIHsgRGVidWdnZXIgfSBmcm9tICdkZWJ1Zyc7XG5pbXBvcnQge1xuICAgYXBwZW5kLFxuICAgZmlsdGVySGFzTGVuZ3RoLFxuICAgZmlsdGVyU3RyaW5nLFxuICAgZmlsdGVyVHlwZSxcbiAgIE5PT1AsXG4gICBvYmplY3RUb1N0cmluZyxcbiAgIHJlbW92ZSxcbn0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBNYXliZSB9IGZyb20gJy4vdHlwZXMnO1xuXG5kZWJ1Zy5mb3JtYXR0ZXJzLkwgPSAodmFsdWU6IGFueSkgPT4gU3RyaW5nKGZpbHRlckhhc0xlbmd0aCh2YWx1ZSkgPyB2YWx1ZS5sZW5ndGggOiAnLScpO1xuZGVidWcuZm9ybWF0dGVycy5CID0gKHZhbHVlOiBCdWZmZXIpID0+IHtcbiAgIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgIH1cbiAgIHJldHVybiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59O1xuXG50eXBlIE91dHB1dExvZ2dpbmdIYW5kbGVyID0gKG1lc3NhZ2U6IHN0cmluZywgLi4uYXJnczogYW55W10pID0+IHZvaWQ7XG5cbmZ1bmN0aW9uIGNyZWF0ZUxvZygpIHtcbiAgIHJldHVybiBkZWJ1Zygnc2ltcGxlLWdpdCcpO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE91dHB1dExvZ2dlciBleHRlbmRzIE91dHB1dExvZ2dpbmdIYW5kbGVyIHtcbiAgIHJlYWRvbmx5IGxhYmVsOiBzdHJpbmc7XG5cbiAgIGluZm86IE91dHB1dExvZ2dpbmdIYW5kbGVyO1xuICAgc3RlcChuZXh0U3RlcD86IHN0cmluZyk6IE91dHB1dExvZ2dlcjtcbiAgIHNpYmxpbmcobmFtZTogc3RyaW5nKTogT3V0cHV0TG9nZ2VyO1xufVxuXG5mdW5jdGlvbiBwcmVmaXhlZExvZ2dlcihcbiAgIHRvOiBEZWJ1Z2dlcixcbiAgIHByZWZpeDogc3RyaW5nLFxuICAgZm9yd2FyZD86IE91dHB1dExvZ2dpbmdIYW5kbGVyXG4pOiBPdXRwdXRMb2dnaW5nSGFuZGxlciB7XG4gICBpZiAoIXByZWZpeCB8fCAhU3RyaW5nKHByZWZpeCkucmVwbGFjZSgvXFxzKi8sICcnKSkge1xuICAgICAgcmV0dXJuICFmb3J3YXJkXG4gICAgICAgICA/IHRvXG4gICAgICAgICA6IChtZXNzYWdlLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgIHRvKG1lc3NhZ2UsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgICBmb3J3YXJkKG1lc3NhZ2UsIC4uLmFyZ3MpO1xuICAgICAgICAgICB9O1xuICAgfVxuXG4gICByZXR1cm4gKG1lc3NhZ2UsIC4uLmFyZ3MpID0+IHtcbiAgICAgIHRvKGAlcyAke21lc3NhZ2V9YCwgcHJlZml4LCAuLi5hcmdzKTtcbiAgICAgIGlmIChmb3J3YXJkKSB7XG4gICAgICAgICBmb3J3YXJkKG1lc3NhZ2UsIC4uLmFyZ3MpO1xuICAgICAgfVxuICAgfTtcbn1cblxuZnVuY3Rpb24gY2hpbGRMb2dnZXJOYW1lKFxuICAgbmFtZTogTWF5YmU8c3RyaW5nPixcbiAgIGNoaWxkRGVidWdnZXI6IE1heWJlPERlYnVnZ2VyPixcbiAgIHsgbmFtZXNwYWNlOiBwYXJlbnROYW1lc3BhY2UgfTogRGVidWdnZXJcbik6IHN0cmluZyB7XG4gICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgIH1cbiAgIGNvbnN0IGNoaWxkTmFtZXNwYWNlID0gKGNoaWxkRGVidWdnZXIgJiYgY2hpbGREZWJ1Z2dlci5uYW1lc3BhY2UpIHx8ICcnO1xuXG4gICBpZiAoY2hpbGROYW1lc3BhY2Uuc3RhcnRzV2l0aChwYXJlbnROYW1lc3BhY2UpKSB7XG4gICAgICByZXR1cm4gY2hpbGROYW1lc3BhY2Uuc3Vic3RyKHBhcmVudE5hbWVzcGFjZS5sZW5ndGggKyAxKTtcbiAgIH1cblxuICAgcmV0dXJuIGNoaWxkTmFtZXNwYWNlIHx8IHBhcmVudE5hbWVzcGFjZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUxvZ2dlcihcbiAgIGxhYmVsOiBzdHJpbmcsXG4gICB2ZXJib3NlPzogc3RyaW5nIHwgRGVidWdnZXIsXG4gICBpbml0aWFsU3RlcD86IHN0cmluZyxcbiAgIGluZm9EZWJ1Z2dlciA9IGNyZWF0ZUxvZygpXG4pOiBPdXRwdXRMb2dnZXIge1xuICAgY29uc3QgbGFiZWxQcmVmaXggPSAobGFiZWwgJiYgYFske2xhYmVsfV1gKSB8fCAnJztcblxuICAgY29uc3Qgc3Bhd25lZDogT3V0cHV0TG9nZ2VyW10gPSBbXTtcbiAgIGNvbnN0IGRlYnVnRGVidWdnZXI6IE1heWJlPERlYnVnZ2VyPiA9XG4gICAgICB0eXBlb2YgdmVyYm9zZSA9PT0gJ3N0cmluZycgPyBpbmZvRGVidWdnZXIuZXh0ZW5kKHZlcmJvc2UpIDogdmVyYm9zZTtcbiAgIGNvbnN0IGtleSA9IGNoaWxkTG9nZ2VyTmFtZShmaWx0ZXJUeXBlKHZlcmJvc2UsIGZpbHRlclN0cmluZyksIGRlYnVnRGVidWdnZXIsIGluZm9EZWJ1Z2dlcik7XG5cbiAgIHJldHVybiBzdGVwKGluaXRpYWxTdGVwKTtcblxuICAgZnVuY3Rpb24gc2libGluZyhuYW1lOiBzdHJpbmcsIGluaXRpYWw/OiBzdHJpbmcpIHtcbiAgICAgIHJldHVybiBhcHBlbmQoXG4gICAgICAgICBzcGF3bmVkLFxuICAgICAgICAgY3JlYXRlTG9nZ2VyKGxhYmVsLCBrZXkucmVwbGFjZSgvXlteOl0rLywgbmFtZSksIGluaXRpYWwsIGluZm9EZWJ1Z2dlcilcbiAgICAgICk7XG4gICB9XG5cbiAgIGZ1bmN0aW9uIHN0ZXAocGhhc2U/OiBzdHJpbmcpIHtcbiAgICAgIGNvbnN0IHN0ZXBQcmVmaXggPSAocGhhc2UgJiYgYFske3BoYXNlfV1gKSB8fCAnJztcbiAgICAgIGNvbnN0IGRlYnVnID0gKGRlYnVnRGVidWdnZXIgJiYgcHJlZml4ZWRMb2dnZXIoZGVidWdEZWJ1Z2dlciwgc3RlcFByZWZpeCkpIHx8IE5PT1A7XG4gICAgICBjb25zdCBpbmZvID0gcHJlZml4ZWRMb2dnZXIoaW5mb0RlYnVnZ2VyLCBgJHtsYWJlbFByZWZpeH0gJHtzdGVwUHJlZml4fWAsIGRlYnVnKTtcblxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZGVidWdEZWJ1Z2dlciA/IGRlYnVnIDogaW5mbywge1xuICAgICAgICAgbGFiZWwsXG4gICAgICAgICBzaWJsaW5nLFxuICAgICAgICAgaW5mbyxcbiAgICAgICAgIHN0ZXAsXG4gICAgICB9KTtcbiAgIH1cbn1cblxuLyoqXG4gKiBUaGUgYEdpdExvZ2dlcmAgaXMgdXNlZCBieSB0aGUgbWFpbiBgU2ltcGxlR2l0YCBydW5uZXIgdG8gaGFuZGxlIGxvZ2dpbmdcbiAqIGFueSB3YXJuaW5ncyBvciBlcnJvcnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBHaXRMb2dnZXIge1xuICAgcHVibGljIGVycm9yOiBPdXRwdXRMb2dnaW5nSGFuZGxlcjtcblxuICAgcHVibGljIHdhcm46IE91dHB1dExvZ2dpbmdIYW5kbGVyO1xuXG4gICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9vdXQ6IERlYnVnZ2VyID0gY3JlYXRlTG9nKCkpIHtcbiAgICAgIHRoaXMuZXJyb3IgPSBwcmVmaXhlZExvZ2dlcihfb3V0LCAnW0VSUk9SXScpO1xuICAgICAgdGhpcy53YXJuID0gcHJlZml4ZWRMb2dnZXIoX291dCwgJ1tXQVJOXScpO1xuICAgfVxuXG4gICBzaWxlbnQoc2lsZW5jZSA9IGZhbHNlKSB7XG4gICAgICBpZiAoc2lsZW5jZSAhPT0gdGhpcy5fb3V0LmVuYWJsZWQpIHtcbiAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBuYW1lc3BhY2UgfSA9IHRoaXMuX291dDtcbiAgICAgIGNvbnN0IGVudiA9IChwcm9jZXNzLmVudi5ERUJVRyB8fCAnJykuc3BsaXQoJywnKS5maWx0ZXIoKHMpID0+ICEhcyk7XG4gICAgICBjb25zdCBoYXNPbiA9IGVudi5pbmNsdWRlcyhuYW1lc3BhY2UpO1xuICAgICAgY29uc3QgaGFzT2ZmID0gZW52LmluY2x1ZGVzKGAtJHtuYW1lc3BhY2V9YCk7XG5cbiAgICAgIC8vIGVuYWJsaW5nIHRoZSBsb2dcbiAgICAgIGlmICghc2lsZW5jZSkge1xuICAgICAgICAgaWYgKGhhc09mZikge1xuICAgICAgICAgICAgcmVtb3ZlKGVudiwgYC0ke25hbWVzcGFjZX1gKTtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbnYucHVzaChuYW1lc3BhY2UpO1xuICAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIGlmIChoYXNPbikge1xuICAgICAgICAgICAgcmVtb3ZlKGVudiwgbmFtZXNwYWNlKTtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbnYucHVzaChgLSR7bmFtZXNwYWNlfWApO1xuICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkZWJ1Zy5lbmFibGUoZW52LmpvaW4oJywnKSk7XG4gICB9XG59XG4iLCAiaW1wb3J0IHsgU2ltcGxlR2l0VGFzayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IEdpdEVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL2dpdC1lcnJvcic7XG5pbXBvcnQgeyBjcmVhdGVMb2dnZXIsIE91dHB1dExvZ2dlciB9IGZyb20gJy4uL2dpdC1sb2dnZXInO1xuXG50eXBlIEFueVNpbXBsZUdpdFRhc2sgPSBTaW1wbGVHaXRUYXNrPGFueT47XG5cbnR5cGUgVGFza0luUHJvZ3Jlc3MgPSB7XG4gICBuYW1lOiBzdHJpbmc7XG4gICBsb2dnZXI6IE91dHB1dExvZ2dlcjtcbiAgIHRhc2s6IEFueVNpbXBsZUdpdFRhc2s7XG59O1xuXG5leHBvcnQgY2xhc3MgVGFza3NQZW5kaW5nUXVldWUge1xuICAgcHJpdmF0ZSBfcXVldWU6IE1hcDxBbnlTaW1wbGVHaXRUYXNrLCBUYXNrSW5Qcm9ncmVzcz4gPSBuZXcgTWFwKCk7XG5cbiAgIGNvbnN0cnVjdG9yKHByaXZhdGUgbG9nTGFiZWwgPSAnR2l0RXhlY3V0b3InKSB7fVxuXG4gICBwcml2YXRlIHdpdGhQcm9ncmVzcyh0YXNrOiBBbnlTaW1wbGVHaXRUYXNrKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcXVldWUuZ2V0KHRhc2spO1xuICAgfVxuXG4gICBwcml2YXRlIGNyZWF0ZVByb2dyZXNzKHRhc2s6IEFueVNpbXBsZUdpdFRhc2spOiBUYXNrSW5Qcm9ncmVzcyB7XG4gICAgICBjb25zdCBuYW1lID0gVGFza3NQZW5kaW5nUXVldWUuZ2V0TmFtZSh0YXNrLmNvbW1hbmRzWzBdKTtcbiAgICAgIGNvbnN0IGxvZ2dlciA9IGNyZWF0ZUxvZ2dlcih0aGlzLmxvZ0xhYmVsLCBuYW1lKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgIHRhc2ssXG4gICAgICAgICBsb2dnZXIsXG4gICAgICAgICBuYW1lLFxuICAgICAgfTtcbiAgIH1cblxuICAgcHVzaCh0YXNrOiBBbnlTaW1wbGVHaXRUYXNrKTogVGFza0luUHJvZ3Jlc3Mge1xuICAgICAgY29uc3QgcHJvZ3Jlc3MgPSB0aGlzLmNyZWF0ZVByb2dyZXNzKHRhc2spO1xuICAgICAgcHJvZ3Jlc3MubG9nZ2VyKCdBZGRpbmcgdGFzayB0byB0aGUgcXVldWUsIGNvbW1hbmRzID0gJW8nLCB0YXNrLmNvbW1hbmRzKTtcblxuICAgICAgdGhpcy5fcXVldWUuc2V0KHRhc2ssIHByb2dyZXNzKTtcblxuICAgICAgcmV0dXJuIHByb2dyZXNzO1xuICAgfVxuXG4gICBmYXRhbChlcnI6IEdpdEVycm9yKSB7XG4gICAgICBmb3IgKGNvbnN0IFt0YXNrLCB7IGxvZ2dlciB9XSBvZiBBcnJheS5mcm9tKHRoaXMuX3F1ZXVlLmVudHJpZXMoKSkpIHtcbiAgICAgICAgIGlmICh0YXNrID09PSBlcnIudGFzaykge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oYEZhaWxlZCAlb2AsIGVycik7XG4gICAgICAgICAgICBsb2dnZXIoXG4gICAgICAgICAgICAgICBgRmF0YWwgZXhjZXB0aW9uLCBhbnkgYXMteWV0IHVuLXN0YXJ0ZWQgdGFza3MgcnVuIHRocm91Z2ggdGhpcyBleGVjdXRvciB3aWxsIG5vdCBiZSBhdHRlbXB0ZWRgXG4gICAgICAgICAgICApO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKFxuICAgICAgICAgICAgICAgYEEgZmF0YWwgZXhjZXB0aW9uIG9jY3VycmVkIGluIGEgcHJldmlvdXMgdGFzaywgdGhlIHF1ZXVlIGhhcyBiZWVuIHB1cmdlZDogJW9gLFxuICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2VcbiAgICAgICAgICAgICk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHRoaXMuY29tcGxldGUodGFzayk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9xdWV1ZS5zaXplICE9PSAwKSB7XG4gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFF1ZXVlIHNpemUgc2hvdWxkIGJlIHplcm8gYWZ0ZXIgZmF0YWw6ICR7dGhpcy5fcXVldWUuc2l6ZX1gKTtcbiAgICAgIH1cbiAgIH1cblxuICAgY29tcGxldGUodGFzazogQW55U2ltcGxlR2l0VGFzaykge1xuICAgICAgY29uc3QgcHJvZ3Jlc3MgPSB0aGlzLndpdGhQcm9ncmVzcyh0YXNrKTtcbiAgICAgIGlmIChwcm9ncmVzcykge1xuICAgICAgICAgdGhpcy5fcXVldWUuZGVsZXRlKHRhc2spO1xuICAgICAgfVxuICAgfVxuXG4gICBhdHRlbXB0KHRhc2s6IEFueVNpbXBsZUdpdFRhc2spOiBUYXNrSW5Qcm9ncmVzcyB7XG4gICAgICBjb25zdCBwcm9ncmVzcyA9IHRoaXMud2l0aFByb2dyZXNzKHRhc2spO1xuICAgICAgaWYgKCFwcm9ncmVzcykge1xuICAgICAgICAgdGhyb3cgbmV3IEdpdEVycm9yKHVuZGVmaW5lZCwgJ1Rhc2tzUGVuZGluZ1F1ZXVlOiBhdHRlbXB0IGNhbGxlZCBmb3IgYW4gdW5rbm93biB0YXNrJyk7XG4gICAgICB9XG4gICAgICBwcm9ncmVzcy5sb2dnZXIoJ1N0YXJ0aW5nIHRhc2snKTtcblxuICAgICAgcmV0dXJuIHByb2dyZXNzO1xuICAgfVxuXG4gICBzdGF0aWMgZ2V0TmFtZShuYW1lID0gJ2VtcHR5Jykge1xuICAgICAgcmV0dXJuIGB0YXNrOiR7bmFtZX06JHsrK1Rhc2tzUGVuZGluZ1F1ZXVlLmNvdW50ZXJ9YDtcbiAgIH1cblxuICAgcHJpdmF0ZSBzdGF0aWMgY291bnRlciA9IDA7XG59XG4iLCAiaW1wb3J0IHsgc3Bhd24sIFNwYXduT3B0aW9ucyB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IHsgR2l0RXJyb3IgfSBmcm9tICcuLi9lcnJvcnMvZ2l0LWVycm9yJztcbmltcG9ydCB7IE91dHB1dExvZ2dlciB9IGZyb20gJy4uL2dpdC1sb2dnZXInO1xuaW1wb3J0IHsgUGx1Z2luU3RvcmUgfSBmcm9tICcuLi9wbHVnaW5zJztcbmltcG9ydCB7IEVtcHR5VGFzaywgaXNCdWZmZXJUYXNrLCBpc0VtcHR5VGFzayB9IGZyb20gJy4uL3Rhc2tzL3Rhc2snO1xuaW1wb3J0IHtcbiAgIEdpdEV4ZWN1dG9yUmVzdWx0LFxuICAgTWF5YmUsXG4gICBvdXRwdXRIYW5kbGVyLFxuICAgUnVubmFibGVUYXNrLFxuICAgU2ltcGxlR2l0RXhlY3V0b3IsXG4gICBTaW1wbGVHaXRUYXNrLFxufSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBjYWxsVGFza1BhcnNlciwgZmlyc3QsIEdpdE91dHB1dFN0cmVhbXMsIG9iamVjdFRvU3RyaW5nIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgU2NoZWR1bGVyIH0gZnJvbSAnLi9zY2hlZHVsZXInO1xuaW1wb3J0IHsgVGFza3NQZW5kaW5nUXVldWUgfSBmcm9tICcuL3Rhc2tzLXBlbmRpbmctcXVldWUnO1xuXG5leHBvcnQgY2xhc3MgR2l0RXhlY3V0b3JDaGFpbiBpbXBsZW1lbnRzIFNpbXBsZUdpdEV4ZWN1dG9yIHtcbiAgIHByaXZhdGUgX2NoYWluOiBQcm9taXNlPGFueT4gPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgIHByaXZhdGUgX3F1ZXVlID0gbmV3IFRhc2tzUGVuZGluZ1F1ZXVlKCk7XG4gICBwcml2YXRlIF9jd2Q6IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICAgcHVibGljIGdldCBiaW5hcnkoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZXhlY3V0b3IuYmluYXJ5O1xuICAgfVxuXG4gICBwdWJsaWMgZ2V0IGN3ZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jd2QgfHwgdGhpcy5fZXhlY3V0b3IuY3dkO1xuICAgfVxuXG4gICBwdWJsaWMgc2V0IGN3ZChjd2Q6IHN0cmluZykge1xuICAgICAgdGhpcy5fY3dkID0gY3dkO1xuICAgfVxuXG4gICBwdWJsaWMgZ2V0IGVudigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9leGVjdXRvci5lbnY7XG4gICB9XG5cbiAgIHB1YmxpYyBnZXQgb3V0cHV0SGFuZGxlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9leGVjdXRvci5vdXRwdXRIYW5kbGVyO1xuICAgfVxuXG4gICBjb25zdHJ1Y3RvcihcbiAgICAgIHByaXZhdGUgX2V4ZWN1dG9yOiBTaW1wbGVHaXRFeGVjdXRvcixcbiAgICAgIHByaXZhdGUgX3NjaGVkdWxlcjogU2NoZWR1bGVyLFxuICAgICAgcHJpdmF0ZSBfcGx1Z2luczogUGx1Z2luU3RvcmVcbiAgICkge31cblxuICAgcHVibGljIGNoYWluKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICB9XG5cbiAgIHB1YmxpYyBwdXNoPFI+KHRhc2s6IFNpbXBsZUdpdFRhc2s8Uj4pOiBQcm9taXNlPFI+IHtcbiAgICAgIHRoaXMuX3F1ZXVlLnB1c2godGFzayk7XG5cbiAgICAgIHJldHVybiAodGhpcy5fY2hhaW4gPSB0aGlzLl9jaGFpbi50aGVuKCgpID0+IHRoaXMuYXR0ZW1wdFRhc2sodGFzaykpKTtcbiAgIH1cblxuICAgcHJpdmF0ZSBhc3luYyBhdHRlbXB0VGFzazxSPih0YXNrOiBTaW1wbGVHaXRUYXNrPFI+KTogUHJvbWlzZTx2b2lkIHwgUj4ge1xuICAgICAgY29uc3Qgb25TY2hlZHVsZUNvbXBsZXRlID0gYXdhaXQgdGhpcy5fc2NoZWR1bGVyLm5leHQoKTtcbiAgICAgIGNvbnN0IG9uUXVldWVDb21wbGV0ZSA9ICgpID0+IHRoaXMuX3F1ZXVlLmNvbXBsZXRlKHRhc2spO1xuXG4gICAgICB0cnkge1xuICAgICAgICAgY29uc3QgeyBsb2dnZXIgfSA9IHRoaXMuX3F1ZXVlLmF0dGVtcHQodGFzayk7XG4gICAgICAgICByZXR1cm4gKGF3YWl0IChpc0VtcHR5VGFzayh0YXNrKVxuICAgICAgICAgICAgPyB0aGlzLmF0dGVtcHRFbXB0eVRhc2sodGFzaywgbG9nZ2VyKVxuICAgICAgICAgICAgOiB0aGlzLmF0dGVtcHRSZW1vdGVUYXNrKHRhc2ssIGxvZ2dlcikpKSBhcyBSO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgdGhyb3cgdGhpcy5vbkZhdGFsRXhjZXB0aW9uKHRhc2ssIGUgYXMgRXJyb3IpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgIG9uUXVldWVDb21wbGV0ZSgpO1xuICAgICAgICAgb25TY2hlZHVsZUNvbXBsZXRlKCk7XG4gICAgICB9XG4gICB9XG5cbiAgIHByaXZhdGUgb25GYXRhbEV4Y2VwdGlvbjxSPih0YXNrOiBTaW1wbGVHaXRUYXNrPFI+LCBlOiBFcnJvcikge1xuICAgICAgY29uc3QgZ2l0RXJyb3IgPVxuICAgICAgICAgZSBpbnN0YW5jZW9mIEdpdEVycm9yID8gT2JqZWN0LmFzc2lnbihlLCB7IHRhc2sgfSkgOiBuZXcgR2l0RXJyb3IodGFzaywgZSAmJiBTdHJpbmcoZSkpO1xuXG4gICAgICB0aGlzLl9jaGFpbiA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgdGhpcy5fcXVldWUuZmF0YWwoZ2l0RXJyb3IpO1xuXG4gICAgICByZXR1cm4gZ2l0RXJyb3I7XG4gICB9XG5cbiAgIHByaXZhdGUgYXN5bmMgYXR0ZW1wdFJlbW90ZVRhc2s8Uj4odGFzazogUnVubmFibGVUYXNrPFI+LCBsb2dnZXI6IE91dHB1dExvZ2dlcikge1xuICAgICAgY29uc3QgYXJncyA9IHRoaXMuX3BsdWdpbnMuZXhlYyhcbiAgICAgICAgICdzcGF3bi5hcmdzJyxcbiAgICAgICAgIFsuLi50YXNrLmNvbW1hbmRzXSxcbiAgICAgICAgIHBsdWdpbkNvbnRleHQodGFzaywgdGFzay5jb21tYW5kcylcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHJhdyA9IGF3YWl0IHRoaXMuZ2l0UmVzcG9uc2UoXG4gICAgICAgICB0YXNrLFxuICAgICAgICAgdGhpcy5iaW5hcnksXG4gICAgICAgICBhcmdzLFxuICAgICAgICAgdGhpcy5vdXRwdXRIYW5kbGVyLFxuICAgICAgICAgbG9nZ2VyLnN0ZXAoJ1NQQVdOJylcbiAgICAgICk7XG4gICAgICBjb25zdCBvdXRwdXRTdHJlYW1zID0gYXdhaXQgdGhpcy5oYW5kbGVUYXNrRGF0YSh0YXNrLCBhcmdzLCByYXcsIGxvZ2dlci5zdGVwKCdIQU5ETEUnKSk7XG5cbiAgICAgIGxvZ2dlcihgcGFzc2luZyByZXNwb25zZSB0byB0YXNrJ3MgcGFyc2VyIGFzIGEgJXNgLCB0YXNrLmZvcm1hdCk7XG5cbiAgICAgIGlmIChpc0J1ZmZlclRhc2sodGFzaykpIHtcbiAgICAgICAgIHJldHVybiBjYWxsVGFza1BhcnNlcih0YXNrLnBhcnNlciwgb3V0cHV0U3RyZWFtcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYWxsVGFza1BhcnNlcih0YXNrLnBhcnNlciwgb3V0cHV0U3RyZWFtcy5hc1N0cmluZ3MoKSk7XG4gICB9XG5cbiAgIHByaXZhdGUgYXN5bmMgYXR0ZW1wdEVtcHR5VGFzayh0YXNrOiBFbXB0eVRhc2ssIGxvZ2dlcjogT3V0cHV0TG9nZ2VyKSB7XG4gICAgICBsb2dnZXIoYGVtcHR5IHRhc2sgYnlwYXNzaW5nIGNoaWxkIHByb2Nlc3MgdG8gY2FsbCB0byB0YXNrJ3MgcGFyc2VyYCk7XG4gICAgICByZXR1cm4gdGFzay5wYXJzZXIodGhpcyk7XG4gICB9XG5cbiAgIHByaXZhdGUgaGFuZGxlVGFza0RhdGE8Uj4oXG4gICAgICB0YXNrOiBTaW1wbGVHaXRUYXNrPFI+LFxuICAgICAgYXJnczogc3RyaW5nW10sXG4gICAgICByZXN1bHQ6IEdpdEV4ZWN1dG9yUmVzdWx0LFxuICAgICAgbG9nZ2VyOiBPdXRwdXRMb2dnZXJcbiAgICk6IFByb21pc2U8R2l0T3V0cHV0U3RyZWFtcz4ge1xuICAgICAgY29uc3QgeyBleGl0Q29kZSwgcmVqZWN0aW9uLCBzdGRPdXQsIHN0ZEVyciB9ID0gcmVzdWx0O1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKGRvbmUsIGZhaWwpID0+IHtcbiAgICAgICAgIGxvZ2dlcihgUHJlcGFyaW5nIHRvIGhhbmRsZSBwcm9jZXNzIHJlc3BvbnNlIGV4aXRDb2RlPSVkIHN0ZE91dD1gLCBleGl0Q29kZSk7XG5cbiAgICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IHRoaXMuX3BsdWdpbnMuZXhlYyhcbiAgICAgICAgICAgICd0YXNrLmVycm9yJyxcbiAgICAgICAgICAgIHsgZXJyb3I6IHJlamVjdGlvbiB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgLi4ucGx1Z2luQ29udGV4dCh0YXNrLCBhcmdzKSxcbiAgICAgICAgICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICk7XG5cbiAgICAgICAgIGlmIChlcnJvciAmJiB0YXNrLm9uRXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKGBleGl0Q29kZT0lcyBoYW5kbGluZyB3aXRoIGN1c3RvbSBlcnJvciBoYW5kbGVyYCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0YXNrLm9uRXJyb3IoXG4gICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgIChuZXdTdGRPdXQpID0+IHtcbiAgICAgICAgICAgICAgICAgIGxvZ2dlci5pbmZvKGBjdXN0b20gZXJyb3IgaGFuZGxlciB0cmVhdGVkIGFzIHN1Y2Nlc3NgKTtcbiAgICAgICAgICAgICAgICAgIGxvZ2dlcihgY3VzdG9tIGVycm9yIHJldHVybmVkIGEgJXNgLCBvYmplY3RUb1N0cmluZyhuZXdTdGRPdXQpKTtcblxuICAgICAgICAgICAgICAgICAgZG9uZShcbiAgICAgICAgICAgICAgICAgICAgIG5ldyBHaXRPdXRwdXRTdHJlYW1zKFxuICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShuZXdTdGRPdXQpID8gQnVmZmVyLmNvbmNhdChuZXdTdGRPdXQpIDogbmV3U3RkT3V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgQnVmZmVyLmNvbmNhdChzdGRFcnIpXG4gICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgIGZhaWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oXG4gICAgICAgICAgICAgICBgaGFuZGxpbmcgYXMgZXJyb3I6IGV4aXRDb2RlPSVzIHN0ZEVycj0lcyByZWplY3Rpb249JW9gLFxuICAgICAgICAgICAgICAgZXhpdENvZGUsXG4gICAgICAgICAgICAgICBzdGRFcnIubGVuZ3RoLFxuICAgICAgICAgICAgICAgcmVqZWN0aW9uXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIGZhaWwoZXJyb3IpO1xuICAgICAgICAgfVxuXG4gICAgICAgICBsb2dnZXIuaW5mbyhgcmV0cmlldmluZyB0YXNrIG91dHB1dCBjb21wbGV0ZWApO1xuICAgICAgICAgZG9uZShuZXcgR2l0T3V0cHV0U3RyZWFtcyhCdWZmZXIuY29uY2F0KHN0ZE91dCksIEJ1ZmZlci5jb25jYXQoc3RkRXJyKSkpO1xuICAgICAgfSk7XG4gICB9XG5cbiAgIHByaXZhdGUgYXN5bmMgZ2l0UmVzcG9uc2U8Uj4oXG4gICAgICB0YXNrOiBTaW1wbGVHaXRUYXNrPFI+LFxuICAgICAgY29tbWFuZDogc3RyaW5nLFxuICAgICAgYXJnczogc3RyaW5nW10sXG4gICAgICBvdXRwdXRIYW5kbGVyOiBNYXliZTxvdXRwdXRIYW5kbGVyPixcbiAgICAgIGxvZ2dlcjogT3V0cHV0TG9nZ2VyXG4gICApOiBQcm9taXNlPEdpdEV4ZWN1dG9yUmVzdWx0PiB7XG4gICAgICBjb25zdCBvdXRwdXRMb2dnZXIgPSBsb2dnZXIuc2libGluZygnb3V0cHV0Jyk7XG4gICAgICBjb25zdCBzcGF3bk9wdGlvbnM6IFNwYXduT3B0aW9ucyA9IHRoaXMuX3BsdWdpbnMuZXhlYyhcbiAgICAgICAgICdzcGF3bi5vcHRpb25zJyxcbiAgICAgICAgIHtcbiAgICAgICAgICAgIGN3ZDogdGhpcy5jd2QsXG4gICAgICAgICAgICBlbnY6IHRoaXMuZW52LFxuICAgICAgICAgICAgd2luZG93c0hpZGU6IHRydWUsXG4gICAgICAgICB9LFxuICAgICAgICAgcGx1Z2luQ29udGV4dCh0YXNrLCB0YXNrLmNvbW1hbmRzKVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChkb25lKSA9PiB7XG4gICAgICAgICBjb25zdCBzdGRPdXQ6IEJ1ZmZlcltdID0gW107XG4gICAgICAgICBjb25zdCBzdGRFcnI6IEJ1ZmZlcltdID0gW107XG5cbiAgICAgICAgIGxvZ2dlci5pbmZvKGAlcyAlb2AsIGNvbW1hbmQsIGFyZ3MpO1xuICAgICAgICAgbG9nZ2VyKCclTycsIHNwYXduT3B0aW9ucyk7XG5cbiAgICAgICAgIGxldCByZWplY3Rpb24gPSB0aGlzLl9iZWZvcmVTcGF3bih0YXNrLCBhcmdzKTtcbiAgICAgICAgIGlmIChyZWplY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBkb25lKHtcbiAgICAgICAgICAgICAgIHN0ZE91dCxcbiAgICAgICAgICAgICAgIHN0ZEVycixcbiAgICAgICAgICAgICAgIGV4aXRDb2RlOiA5OTAxLFxuICAgICAgICAgICAgICAgcmVqZWN0aW9uLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHRoaXMuX3BsdWdpbnMuZXhlYygnc3Bhd24uYmVmb3JlJywgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAuLi5wbHVnaW5Db250ZXh0KHRhc2ssIGFyZ3MpLFxuICAgICAgICAgICAga2lsbChyZWFzb24pIHtcbiAgICAgICAgICAgICAgIHJlamVjdGlvbiA9IHJlYXNvbiB8fCByZWplY3Rpb247XG4gICAgICAgICAgICB9LFxuICAgICAgICAgfSk7XG5cbiAgICAgICAgIGNvbnN0IHNwYXduZWQgPSBzcGF3bihjb21tYW5kLCBhcmdzLCBzcGF3bk9wdGlvbnMpO1xuXG4gICAgICAgICBzcGF3bmVkLnN0ZG91dCEub24oXG4gICAgICAgICAgICAnZGF0YScsXG4gICAgICAgICAgICBvbkRhdGFSZWNlaXZlZChzdGRPdXQsICdzdGRPdXQnLCBsb2dnZXIsIG91dHB1dExvZ2dlci5zdGVwKCdzdGRPdXQnKSlcbiAgICAgICAgICk7XG4gICAgICAgICBzcGF3bmVkLnN0ZGVyciEub24oXG4gICAgICAgICAgICAnZGF0YScsXG4gICAgICAgICAgICBvbkRhdGFSZWNlaXZlZChzdGRFcnIsICdzdGRFcnInLCBsb2dnZXIsIG91dHB1dExvZ2dlci5zdGVwKCdzdGRFcnInKSlcbiAgICAgICAgICk7XG5cbiAgICAgICAgIHNwYXduZWQub24oJ2Vycm9yJywgb25FcnJvclJlY2VpdmVkKHN0ZEVyciwgbG9nZ2VyKSk7XG5cbiAgICAgICAgIGlmIChvdXRwdXRIYW5kbGVyKSB7XG4gICAgICAgICAgICBsb2dnZXIoYFBhc3NpbmcgY2hpbGQgcHJvY2VzcyBzdGRPdXQvc3RkRXJyIHRvIGN1c3RvbSBvdXRwdXRIYW5kbGVyYCk7XG4gICAgICAgICAgICBvdXRwdXRIYW5kbGVyKGNvbW1hbmQsIHNwYXduZWQuc3Rkb3V0ISwgc3Bhd25lZC5zdGRlcnIhLCBbLi4uYXJnc10pO1xuICAgICAgICAgfVxuXG4gICAgICAgICB0aGlzLl9wbHVnaW5zLmV4ZWMoJ3NwYXduLmFmdGVyJywgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAuLi5wbHVnaW5Db250ZXh0KHRhc2ssIGFyZ3MpLFxuICAgICAgICAgICAgc3Bhd25lZCxcbiAgICAgICAgICAgIGNsb3NlKGV4aXRDb2RlOiBudW1iZXIsIHJlYXNvbj86IEVycm9yKSB7XG4gICAgICAgICAgICAgICBkb25lKHtcbiAgICAgICAgICAgICAgICAgIHN0ZE91dCxcbiAgICAgICAgICAgICAgICAgIHN0ZEVycixcbiAgICAgICAgICAgICAgICAgIGV4aXRDb2RlLFxuICAgICAgICAgICAgICAgICAgcmVqZWN0aW9uOiByZWplY3Rpb24gfHwgcmVhc29uLFxuICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAga2lsbChyZWFzb246IEVycm9yKSB7XG4gICAgICAgICAgICAgICBpZiAoc3Bhd25lZC5raWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgcmVqZWN0aW9uID0gcmVhc29uO1xuICAgICAgICAgICAgICAgc3Bhd25lZC5raWxsKCdTSUdJTlQnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgfVxuXG4gICBwcml2YXRlIF9iZWZvcmVTcGF3bjxSPih0YXNrOiBTaW1wbGVHaXRUYXNrPFI+LCBhcmdzOiBzdHJpbmdbXSkge1xuICAgICAgbGV0IHJlamVjdGlvbjogTWF5YmU8RXJyb3I+O1xuICAgICAgdGhpcy5fcGx1Z2lucy5leGVjKCdzcGF3bi5iZWZvcmUnLCB1bmRlZmluZWQsIHtcbiAgICAgICAgIC4uLnBsdWdpbkNvbnRleHQodGFzaywgYXJncyksXG4gICAgICAgICBraWxsKHJlYXNvbikge1xuICAgICAgICAgICAgcmVqZWN0aW9uID0gcmVhc29uIHx8IHJlamVjdGlvbjtcbiAgICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHJlamVjdGlvbjtcbiAgIH1cbn1cblxuZnVuY3Rpb24gcGx1Z2luQ29udGV4dDxSPih0YXNrOiBTaW1wbGVHaXRUYXNrPFI+LCBjb21tYW5kczogc3RyaW5nW10pIHtcbiAgIHJldHVybiB7XG4gICAgICBtZXRob2Q6IGZpcnN0KHRhc2suY29tbWFuZHMpIHx8ICcnLFxuICAgICAgY29tbWFuZHMsXG4gICB9O1xufVxuXG5mdW5jdGlvbiBvbkVycm9yUmVjZWl2ZWQodGFyZ2V0OiBCdWZmZXJbXSwgbG9nZ2VyOiBPdXRwdXRMb2dnZXIpIHtcbiAgIHJldHVybiAoZXJyOiBFcnJvcikgPT4ge1xuICAgICAgbG9nZ2VyKGBbRVJST1JdIGNoaWxkIHByb2Nlc3MgZXhjZXB0aW9uICVvYCwgZXJyKTtcbiAgICAgIHRhcmdldC5wdXNoKEJ1ZmZlci5mcm9tKFN0cmluZyhlcnIuc3RhY2spLCAnYXNjaWknKSk7XG4gICB9O1xufVxuXG5mdW5jdGlvbiBvbkRhdGFSZWNlaXZlZChcbiAgIHRhcmdldDogQnVmZmVyW10sXG4gICBuYW1lOiBzdHJpbmcsXG4gICBsb2dnZXI6IE91dHB1dExvZ2dlcixcbiAgIG91dHB1dDogT3V0cHV0TG9nZ2VyXG4pIHtcbiAgIHJldHVybiAoYnVmZmVyOiBCdWZmZXIpID0+IHtcbiAgICAgIGxvZ2dlcihgJXMgcmVjZWl2ZWQgJUwgYnl0ZXNgLCBuYW1lLCBidWZmZXIpO1xuICAgICAgb3V0cHV0KGAlQmAsIGJ1ZmZlcik7XG4gICAgICB0YXJnZXQucHVzaChidWZmZXIpO1xuICAgfTtcbn1cbiIsICJpbXBvcnQgdHlwZSB7IFBsdWdpblN0b3JlIH0gZnJvbSAnLi4vcGx1Z2lucyc7XG5pbXBvcnQgdHlwZSB7IEdpdEV4ZWN1dG9yRW52LCBvdXRwdXRIYW5kbGVyLCBTaW1wbGVHaXRFeGVjdXRvciwgU2ltcGxlR2l0VGFzayB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgR2l0RXhlY3V0b3JDaGFpbiB9IGZyb20gJy4vZ2l0LWV4ZWN1dG9yLWNoYWluJztcbmltcG9ydCB7IFNjaGVkdWxlciB9IGZyb20gJy4vc2NoZWR1bGVyJztcblxuZXhwb3J0IGNsYXNzIEdpdEV4ZWN1dG9yIGltcGxlbWVudHMgU2ltcGxlR2l0RXhlY3V0b3Ige1xuICAgcHJpdmF0ZSBfY2hhaW4gPSBuZXcgR2l0RXhlY3V0b3JDaGFpbih0aGlzLCB0aGlzLl9zY2hlZHVsZXIsIHRoaXMuX3BsdWdpbnMpO1xuXG4gICBwdWJsaWMgZW52OiBHaXRFeGVjdXRvckVudjtcbiAgIHB1YmxpYyBvdXRwdXRIYW5kbGVyPzogb3V0cHV0SGFuZGxlcjtcblxuICAgY29uc3RydWN0b3IoXG4gICAgICBwdWJsaWMgYmluYXJ5OiBzdHJpbmcgPSAnZ2l0JyxcbiAgICAgIHB1YmxpYyBjd2Q6IHN0cmluZyxcbiAgICAgIHByaXZhdGUgX3NjaGVkdWxlcjogU2NoZWR1bGVyLFxuICAgICAgcHJpdmF0ZSBfcGx1Z2luczogUGx1Z2luU3RvcmVcbiAgICkge31cblxuICAgY2hhaW4oKTogU2ltcGxlR2l0RXhlY3V0b3Ige1xuICAgICAgcmV0dXJuIG5ldyBHaXRFeGVjdXRvckNoYWluKHRoaXMsIHRoaXMuX3NjaGVkdWxlciwgdGhpcy5fcGx1Z2lucyk7XG4gICB9XG5cbiAgIHB1c2g8Uj4odGFzazogU2ltcGxlR2l0VGFzazxSPik6IFByb21pc2U8Uj4ge1xuICAgICAgcmV0dXJuIHRoaXMuX2NoYWluLnB1c2godGFzayk7XG4gICB9XG59XG4iLCAiaW1wb3J0IHsgR2l0RXJyb3IgfSBmcm9tICcuL2Vycm9ycy9naXQtZXJyb3InO1xuaW1wb3J0IHsgR2l0UmVzcG9uc2VFcnJvciB9IGZyb20gJy4vZXJyb3JzL2dpdC1yZXNwb25zZS1lcnJvcic7XG5pbXBvcnQgeyBTaW1wbGVHaXRUYXNrLCBTaW1wbGVHaXRUYXNrQ2FsbGJhY2sgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IE5PT1AgfSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHRhc2tDYWxsYmFjazxSPihcbiAgIHRhc2s6IFNpbXBsZUdpdFRhc2s8Uj4sXG4gICByZXNwb25zZTogUHJvbWlzZTxSPixcbiAgIGNhbGxiYWNrOiBTaW1wbGVHaXRUYXNrQ2FsbGJhY2s8Uj4gPSBOT09QXG4pIHtcbiAgIGNvbnN0IG9uU3VjY2VzcyA9IChkYXRhOiBSKSA9PiB7XG4gICAgICBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgIH07XG5cbiAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyOiBHaXRFcnJvciB8IEdpdFJlc3BvbnNlRXJyb3IpID0+IHtcbiAgICAgIGlmIChlcnI/LnRhc2sgPT09IHRhc2spIHtcbiAgICAgICAgIGNhbGxiYWNrKFxuICAgICAgICAgICAgZXJyIGluc3RhbmNlb2YgR2l0UmVzcG9uc2VFcnJvciA/IGFkZERlcHJlY2F0aW9uTm90aWNlVG9FcnJvcihlcnIpIDogZXJyLFxuICAgICAgICAgICAgdW5kZWZpbmVkIGFzIGFueVxuICAgICAgICAgKTtcbiAgICAgIH1cbiAgIH07XG5cbiAgIHJlc3BvbnNlLnRoZW4ob25TdWNjZXNzLCBvbkVycm9yKTtcbn1cblxuZnVuY3Rpb24gYWRkRGVwcmVjYXRpb25Ob3RpY2VUb0Vycm9yKGVycjogR2l0UmVzcG9uc2VFcnJvcikge1xuICAgbGV0IGxvZyA9IChuYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgIGBzaW1wbGUtZ2l0IGRlcHJlY2F0aW9uIG5vdGljZTogYWNjZXNzaW5nIEdpdFJlc3BvbnNlRXJyb3IuJHtuYW1lfSBzaG91bGQgYmUgR2l0UmVzcG9uc2VFcnJvci5naXQuJHtuYW1lfSwgdGhpcyB3aWxsIG5vIGxvbmdlciBiZSBhdmFpbGFibGUgaW4gdmVyc2lvbiAzYFxuICAgICAgKTtcbiAgICAgIGxvZyA9IE5PT1A7XG4gICB9O1xuXG4gICByZXR1cm4gT2JqZWN0LmNyZWF0ZShlcnIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGVyci5naXQpLnJlZHVjZShkZXNjcmlwdG9yUmVkdWNlciwge30pKTtcblxuICAgZnVuY3Rpb24gZGVzY3JpcHRvclJlZHVjZXIoYWxsOiBQcm9wZXJ0eURlc2NyaXB0b3JNYXAsIG5hbWU6IHN0cmluZyk6IHR5cGVvZiBhbGwge1xuICAgICAgaWYgKG5hbWUgaW4gZXJyKSB7XG4gICAgICAgICByZXR1cm4gYWxsO1xuICAgICAgfVxuXG4gICAgICBhbGxbbmFtZV0gPSB7XG4gICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICBsb2cobmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gZXJyLmdpdFtuYW1lXTtcbiAgICAgICAgIH0sXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gYWxsO1xuICAgfVxufVxuIiwgImltcG9ydCB7IGZvbGRlckV4aXN0cyB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IFNpbXBsZUdpdEV4ZWN1dG9yIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgYWRob2NFeGVjVGFzayB9IGZyb20gJy4vdGFzayc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGFuZ2VXb3JraW5nRGlyZWN0b3J5VGFzayhkaXJlY3Rvcnk6IHN0cmluZywgcm9vdD86IFNpbXBsZUdpdEV4ZWN1dG9yKSB7XG4gICByZXR1cm4gYWRob2NFeGVjVGFzaygoaW5zdGFuY2U6IFNpbXBsZUdpdEV4ZWN1dG9yKSA9PiB7XG4gICAgICBpZiAoIWZvbGRlckV4aXN0cyhkaXJlY3RvcnkpKSB7XG4gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdpdC5jd2Q6IGNhbm5vdCBjaGFuZ2UgdG8gbm9uLWRpcmVjdG9yeSBcIiR7ZGlyZWN0b3J5fVwiYCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoKHJvb3QgfHwgaW5zdGFuY2UpLmN3ZCA9IGRpcmVjdG9yeSk7XG4gICB9KTtcbn1cbiIsICJpbXBvcnQgdHlwZSB7IFNpbXBsZUdpdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHR5cGUgeyBTaW1wbGVHaXRBcGkgfSBmcm9tICcuLi9zaW1wbGUtZ2l0LWFwaSc7XG5pbXBvcnQgeyBnZXRUcmFpbGluZ09wdGlvbnMsIHJlbW92ZSwgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50IH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayB9IGZyb20gJy4vdGFzayc7XG5cbmZ1bmN0aW9uIGNoZWNrb3V0VGFzayhhcmdzOiBzdHJpbmdbXSkge1xuICAgY29uc3QgY29tbWFuZHMgPSBbJ2NoZWNrb3V0JywgLi4uYXJnc107XG4gICBpZiAoY29tbWFuZHNbMV0gPT09ICctYicgJiYgY29tbWFuZHMuaW5jbHVkZXMoJy1CJykpIHtcbiAgICAgIGNvbW1hbmRzWzFdID0gcmVtb3ZlKGNvbW1hbmRzLCAnLUInKTtcbiAgIH1cblxuICAgcmV0dXJuIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soY29tbWFuZHMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKTogUGljazxTaW1wbGVHaXQsICdjaGVja291dCcgfCAnY2hlY2tvdXRCcmFuY2gnIHwgJ2NoZWNrb3V0TG9jYWxCcmFuY2gnPiB7XG4gICByZXR1cm4ge1xuICAgICAgY2hlY2tvdXQodGhpczogU2ltcGxlR2l0QXBpKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgICAgIGNoZWNrb3V0VGFzayhnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzLCAxKSksXG4gICAgICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgICAgKTtcbiAgICAgIH0sXG5cbiAgICAgIGNoZWNrb3V0QnJhbmNoKHRoaXM6IFNpbXBsZUdpdEFwaSwgYnJhbmNoTmFtZSwgc3RhcnRQb2ludCkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgICBjaGVja291dFRhc2soWyctYicsIGJyYW5jaE5hbWUsIHN0YXJ0UG9pbnQsIC4uLmdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpXSksXG4gICAgICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgICAgKTtcbiAgICAgIH0sXG5cbiAgICAgIGNoZWNrb3V0TG9jYWxCcmFuY2godGhpczogU2ltcGxlR2l0QXBpLCBicmFuY2hOYW1lKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgICAgIGNoZWNrb3V0VGFzayhbJy1iJywgYnJhbmNoTmFtZSwgLi4uZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cyldKSxcbiAgICAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICAgICApO1xuICAgICAgfSxcbiAgIH07XG59XG4iLCAiaW1wb3J0IHsgQ29tbWl0UmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBMaW5lUGFyc2VyLCBwYXJzZVN0cmluZ1Jlc3BvbnNlIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5jb25zdCBwYXJzZXJzOiBMaW5lUGFyc2VyPENvbW1pdFJlc3VsdD5bXSA9IFtcbiAgIG5ldyBMaW5lUGFyc2VyKC9eXFxbKFteXFxzXSspKCBcXChbXildK1xcKSk/IChbXlxcXV0rKS8sIChyZXN1bHQsIFticmFuY2gsIHJvb3QsIGNvbW1pdF0pID0+IHtcbiAgICAgIHJlc3VsdC5icmFuY2ggPSBicmFuY2g7XG4gICAgICByZXN1bHQuY29tbWl0ID0gY29tbWl0O1xuICAgICAgcmVzdWx0LnJvb3QgPSAhIXJvb3Q7XG4gICB9KSxcbiAgIG5ldyBMaW5lUGFyc2VyKC9cXHMqQXV0aG9yOlxccyguKykvaSwgKHJlc3VsdCwgW2F1dGhvcl0pID0+IHtcbiAgICAgIGNvbnN0IHBhcnRzID0gYXV0aG9yLnNwbGl0KCc8Jyk7XG4gICAgICBjb25zdCBlbWFpbCA9IHBhcnRzLnBvcCgpO1xuXG4gICAgICBpZiAoIWVtYWlsIHx8ICFlbWFpbC5pbmNsdWRlcygnQCcpKSB7XG4gICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdC5hdXRob3IgPSB7XG4gICAgICAgICBlbWFpbDogZW1haWwuc3Vic3RyKDAsIGVtYWlsLmxlbmd0aCAtIDEpLFxuICAgICAgICAgbmFtZTogcGFydHMuam9pbignPCcpLnRyaW0oKSxcbiAgICAgIH07XG4gICB9KSxcbiAgIG5ldyBMaW5lUGFyc2VyKFxuICAgICAgLyhcXGQrKVteLF0qKD86LFxccyooXFxkKylbXixdKikoPzosXFxzKihcXGQrKSkvZyxcbiAgICAgIChyZXN1bHQsIFtjaGFuZ2VzLCBpbnNlcnRpb25zLCBkZWxldGlvbnNdKSA9PiB7XG4gICAgICAgICByZXN1bHQuc3VtbWFyeS5jaGFuZ2VzID0gcGFyc2VJbnQoY2hhbmdlcywgMTApIHx8IDA7XG4gICAgICAgICByZXN1bHQuc3VtbWFyeS5pbnNlcnRpb25zID0gcGFyc2VJbnQoaW5zZXJ0aW9ucywgMTApIHx8IDA7XG4gICAgICAgICByZXN1bHQuc3VtbWFyeS5kZWxldGlvbnMgPSBwYXJzZUludChkZWxldGlvbnMsIDEwKSB8fCAwO1xuICAgICAgfVxuICAgKSxcbiAgIG5ldyBMaW5lUGFyc2VyKFxuICAgICAgL14oXFxkKylbXixdKig/OixcXHMqKFxcZCspW14oXStcXCgoWystXSkpPy8sXG4gICAgICAocmVzdWx0LCBbY2hhbmdlcywgbGluZXMsIGRpcmVjdGlvbl0pID0+IHtcbiAgICAgICAgIHJlc3VsdC5zdW1tYXJ5LmNoYW5nZXMgPSBwYXJzZUludChjaGFuZ2VzLCAxMCkgfHwgMDtcbiAgICAgICAgIGNvbnN0IGNvdW50ID0gcGFyc2VJbnQobGluZXMsIDEwKSB8fCAwO1xuICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJy0nKSB7XG4gICAgICAgICAgICByZXN1bHQuc3VtbWFyeS5kZWxldGlvbnMgPSBjb3VudDtcbiAgICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnKycpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdW1tYXJ5Lmluc2VydGlvbnMgPSBjb3VudDtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICksXG5dO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VDb21taXRSZXN1bHQoc3RkT3V0OiBzdHJpbmcpOiBDb21taXRSZXN1bHQge1xuICAgY29uc3QgcmVzdWx0OiBDb21taXRSZXN1bHQgPSB7XG4gICAgICBhdXRob3I6IG51bGwsXG4gICAgICBicmFuY2g6ICcnLFxuICAgICAgY29tbWl0OiAnJyxcbiAgICAgIHJvb3Q6IGZhbHNlLFxuICAgICAgc3VtbWFyeToge1xuICAgICAgICAgY2hhbmdlczogMCxcbiAgICAgICAgIGluc2VydGlvbnM6IDAsXG4gICAgICAgICBkZWxldGlvbnM6IDAsXG4gICAgICB9LFxuICAgfTtcbiAgIHJldHVybiBwYXJzZVN0cmluZ1Jlc3BvbnNlKHJlc3VsdCwgcGFyc2Vycywgc3RkT3V0KTtcbn1cbiIsICJpbXBvcnQgdHlwZSB7IENvbW1pdFJlc3VsdCwgU2ltcGxlR2l0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgdHlwZSB7IFNpbXBsZUdpdEFwaSB9IGZyb20gJy4uL3NpbXBsZS1naXQtYXBpJztcbmltcG9ydCB0eXBlIHsgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IHBhcnNlQ29tbWl0UmVzdWx0IH0gZnJvbSAnLi4vcGFyc2Vycy9wYXJzZS1jb21taXQnO1xuaW1wb3J0IHtcbiAgIGFzQXJyYXksXG4gICBmaWx0ZXJBcnJheSxcbiAgIGZpbHRlclN0cmluZ09yU3RyaW5nQXJyYXksXG4gICBmaWx0ZXJUeXBlLFxuICAgZ2V0VHJhaWxpbmdPcHRpb25zLFxuICAgcHJlZml4ZWRBcnJheSxcbiAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudCxcbn0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgY29uZmlndXJhdGlvbkVycm9yVGFzayB9IGZyb20gJy4vdGFzayc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21taXRUYXNrKFxuICAgbWVzc2FnZTogc3RyaW5nW10sXG4gICBmaWxlczogc3RyaW5nW10sXG4gICBjdXN0b21BcmdzOiBzdHJpbmdbXVxuKTogU3RyaW5nVGFzazxDb21taXRSZXN1bHQ+IHtcbiAgIGNvbnN0IGNvbW1hbmRzOiBzdHJpbmdbXSA9IFtcbiAgICAgICctYycsXG4gICAgICAnY29yZS5hYmJyZXY9NDAnLFxuICAgICAgJ2NvbW1pdCcsXG4gICAgICAuLi5wcmVmaXhlZEFycmF5KG1lc3NhZ2UsICctbScpLFxuICAgICAgLi4uZmlsZXMsXG4gICAgICAuLi5jdXN0b21BcmdzLFxuICAgXTtcblxuICAgcmV0dXJuIHtcbiAgICAgIGNvbW1hbmRzLFxuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgcGFyc2VyOiBwYXJzZUNvbW1pdFJlc3VsdCxcbiAgIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpOiBQaWNrPFNpbXBsZUdpdCwgJ2NvbW1pdCc+IHtcbiAgIHJldHVybiB7XG4gICAgICBjb21taXQodGhpczogU2ltcGxlR2l0QXBpLCBtZXNzYWdlOiBzdHJpbmcgfCBzdHJpbmdbXSwgLi4ucmVzdDogdW5rbm93bltdKSB7XG4gICAgICAgICBjb25zdCBuZXh0ID0gdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cyk7XG4gICAgICAgICBjb25zdCB0YXNrID1cbiAgICAgICAgICAgIHJlamVjdERlcHJlY2F0ZWRTaWduYXR1cmVzKG1lc3NhZ2UpIHx8XG4gICAgICAgICAgICBjb21taXRUYXNrKFxuICAgICAgICAgICAgICAgYXNBcnJheShtZXNzYWdlKSxcbiAgICAgICAgICAgICAgIGFzQXJyYXkoZmlsdGVyVHlwZShyZXN0WzBdLCBmaWx0ZXJTdHJpbmdPclN0cmluZ0FycmF5LCBbXSkpLFxuICAgICAgICAgICAgICAgWy4uLmZpbHRlclR5cGUocmVzdFsxXSwgZmlsdGVyQXJyYXksIFtdKSwgLi4uZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cywgMCwgdHJ1ZSldXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayh0YXNrLCBuZXh0KTtcbiAgICAgIH0sXG4gICB9O1xuXG4gICBmdW5jdGlvbiByZWplY3REZXByZWNhdGVkU2lnbmF0dXJlcyhtZXNzYWdlPzogdW5rbm93bikge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgICFmaWx0ZXJTdHJpbmdPclN0cmluZ0FycmF5KG1lc3NhZ2UpICYmXG4gICAgICAgICBjb25maWd1cmF0aW9uRXJyb3JUYXNrKFxuICAgICAgICAgICAgYGdpdC5jb21taXQ6IHJlcXVpcmVzIHRoZSBjb21taXQgbWVzc2FnZSB0byBiZSBzdXBwbGllZCBhcyBhIHN0cmluZy9zdHJpbmdbXWBcbiAgICAgICAgIClcbiAgICAgICk7XG4gICB9XG59XG4iLCAiaW1wb3J0IHsgUmVzcG9uc2UsIFNpbXBsZUdpdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgU2ltcGxlR2l0QXBpIH0gZnJvbSAnLi4vc2ltcGxlLWdpdC1hcGknO1xuaW1wb3J0IHsgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50IH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayB9IGZyb20gJy4vdGFzayc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpOiBQaWNrPFNpbXBsZUdpdCwgJ2ZpcnN0Q29tbWl0Jz4ge1xuICAgcmV0dXJuIHtcbiAgICAgIGZpcnN0Q29tbWl0KHRoaXM6IFNpbXBsZUdpdEFwaSk6IFJlc3BvbnNlPHN0cmluZz4ge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgICBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKFsncmV2LWxpc3QnLCAnLS1tYXgtcGFyZW50cz0wJywgJ0hFQUQnXSwgdHJ1ZSksXG4gICAgICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgICAgKTtcbiAgICAgIH0sXG4gICB9O1xufVxuIiwgImltcG9ydCB7IHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2sgfSBmcm9tICcuL3Rhc2snO1xuaW1wb3J0IHsgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcblxuLyoqXG4gKiBUYXNrIHVzZWQgYnkgYGdpdC5oYXNoT2JqZWN0YFxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaE9iamVjdFRhc2soZmlsZVBhdGg6IHN0cmluZywgd3JpdGU6IGJvb2xlYW4pOiBTdHJpbmdUYXNrPHN0cmluZz4ge1xuICAgY29uc3QgY29tbWFuZHMgPSBbJ2hhc2gtb2JqZWN0JywgZmlsZVBhdGhdO1xuICAgaWYgKHdyaXRlKSB7XG4gICAgICBjb21tYW5kcy5wdXNoKCctdycpO1xuICAgfVxuXG4gICByZXR1cm4gc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhjb21tYW5kcywgdHJ1ZSk7XG59XG4iLCAiaW1wb3J0IHsgSW5pdFJlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuXG5leHBvcnQgY2xhc3MgSW5pdFN1bW1hcnkgaW1wbGVtZW50cyBJbml0UmVzdWx0IHtcbiAgIGNvbnN0cnVjdG9yKFxuICAgICAgcHVibGljIHJlYWRvbmx5IGJhcmU6IGJvb2xlYW4sXG4gICAgICBwdWJsaWMgcmVhZG9ubHkgcGF0aDogc3RyaW5nLFxuICAgICAgcHVibGljIHJlYWRvbmx5IGV4aXN0aW5nOiBib29sZWFuLFxuICAgICAgcHVibGljIHJlYWRvbmx5IGdpdERpcjogc3RyaW5nXG4gICApIHt9XG59XG5cbmNvbnN0IGluaXRSZXNwb25zZVJlZ2V4ID0gL15Jbml0LisgcmVwb3NpdG9yeSBpbiAoLispJC87XG5jb25zdCByZUluaXRSZXNwb25zZVJlZ2V4ID0gL15SZWluLisgaW4gKC4rKSQvO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VJbml0KGJhcmU6IGJvb2xlYW4sIHBhdGg6IHN0cmluZywgdGV4dDogc3RyaW5nKSB7XG4gICBjb25zdCByZXNwb25zZSA9IFN0cmluZyh0ZXh0KS50cmltKCk7XG4gICBsZXQgcmVzdWx0O1xuXG4gICBpZiAoKHJlc3VsdCA9IGluaXRSZXNwb25zZVJlZ2V4LmV4ZWMocmVzcG9uc2UpKSkge1xuICAgICAgcmV0dXJuIG5ldyBJbml0U3VtbWFyeShiYXJlLCBwYXRoLCBmYWxzZSwgcmVzdWx0WzFdKTtcbiAgIH1cblxuICAgaWYgKChyZXN1bHQgPSByZUluaXRSZXNwb25zZVJlZ2V4LmV4ZWMocmVzcG9uc2UpKSkge1xuICAgICAgcmV0dXJuIG5ldyBJbml0U3VtbWFyeShiYXJlLCBwYXRoLCB0cnVlLCByZXN1bHRbMV0pO1xuICAgfVxuXG4gICBsZXQgZ2l0RGlyID0gJyc7XG4gICBjb25zdCB0b2tlbnMgPSByZXNwb25zZS5zcGxpdCgnICcpO1xuICAgd2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHRva2VuID0gdG9rZW5zLnNoaWZ0KCk7XG4gICAgICBpZiAodG9rZW4gPT09ICdpbicpIHtcbiAgICAgICAgIGdpdERpciA9IHRva2Vucy5qb2luKCcgJyk7XG4gICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgIH1cblxuICAgcmV0dXJuIG5ldyBJbml0U3VtbWFyeShiYXJlLCBwYXRoLCAvXnJlL2kudGVzdChyZXNwb25zZSksIGdpdERpcik7XG59XG4iLCAiaW1wb3J0IHsgSW5pdFJlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgcGFyc2VJbml0IH0gZnJvbSAnLi4vcmVzcG9uc2VzL0luaXRTdW1tYXJ5JztcbmltcG9ydCB7IFN0cmluZ1Rhc2sgfSBmcm9tICcuLi90eXBlcyc7XG5cbmNvbnN0IGJhcmVDb21tYW5kID0gJy0tYmFyZSc7XG5cbmZ1bmN0aW9uIGhhc0JhcmVDb21tYW5kKGNvbW1hbmQ6IHN0cmluZ1tdKSB7XG4gICByZXR1cm4gY29tbWFuZC5pbmNsdWRlcyhiYXJlQ29tbWFuZCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0VGFzayhiYXJlID0gZmFsc2UsIHBhdGg6IHN0cmluZywgY3VzdG9tQXJnczogc3RyaW5nW10pOiBTdHJpbmdUYXNrPEluaXRSZXN1bHQ+IHtcbiAgIGNvbnN0IGNvbW1hbmRzID0gWydpbml0JywgLi4uY3VzdG9tQXJnc107XG4gICBpZiAoYmFyZSAmJiAhaGFzQmFyZUNvbW1hbmQoY29tbWFuZHMpKSB7XG4gICAgICBjb21tYW5kcy5zcGxpY2UoMSwgMCwgYmFyZUNvbW1hbmQpO1xuICAgfVxuXG4gICByZXR1cm4ge1xuICAgICAgY29tbWFuZHMsXG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBwYXJzZXIodGV4dDogc3RyaW5nKTogSW5pdFJlc3VsdCB7XG4gICAgICAgICByZXR1cm4gcGFyc2VJbml0KGNvbW1hbmRzLmluY2x1ZGVzKCctLWJhcmUnKSwgcGF0aCwgdGV4dCk7XG4gICAgICB9LFxuICAgfTtcbn1cbiIsICJleHBvcnQgZW51bSBMb2dGb3JtYXQge1xuICAgTk9ORSA9ICcnLFxuICAgU1RBVCA9ICctLXN0YXQnLFxuICAgTlVNX1NUQVQgPSAnLS1udW1zdGF0JyxcbiAgIE5BTUVfT05MWSA9ICctLW5hbWUtb25seScsXG4gICBOQU1FX1NUQVRVUyA9ICctLW5hbWUtc3RhdHVzJyxcbn1cblxuY29uc3QgbG9nRm9ybWF0UmVnZXggPSAvXi0tKHN0YXR8bnVtc3RhdHxuYW1lLW9ubHl8bmFtZS1zdGF0dXMpKD18JCkvO1xuXG5leHBvcnQgZnVuY3Rpb24gbG9nRm9ybWF0RnJvbUNvbW1hbmQoY3VzdG9tQXJnczogc3RyaW5nW10pIHtcbiAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VzdG9tQXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZm9ybWF0ID0gbG9nRm9ybWF0UmVnZXguZXhlYyhjdXN0b21BcmdzW2ldKTtcbiAgICAgIGlmIChmb3JtYXQpIHtcbiAgICAgICAgIHJldHVybiBgLS0ke2Zvcm1hdFsxXX1gIGFzIExvZ0Zvcm1hdDtcbiAgICAgIH1cbiAgIH1cblxuICAgcmV0dXJuIExvZ0Zvcm1hdC5OT05FO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNMb2dGb3JtYXQoY3VzdG9tQXJnOiBzdHJpbmcgfCB1bmtub3duKSB7XG4gICByZXR1cm4gbG9nRm9ybWF0UmVnZXgudGVzdChjdXN0b21BcmcgYXMgc3RyaW5nKTtcbn1cbiIsICJpbXBvcnQgeyBEaWZmUmVzdWx0LCBEaWZmUmVzdWx0QmluYXJ5RmlsZSwgRGlmZlJlc3VsdFRleHRGaWxlIH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5cbi8qKipcbiAqIFRoZSBEaWZmU3VtbWFyeSBpcyByZXR1cm5lZCBhcyBhIHJlc3BvbnNlIHRvIGdldHRpbmcgYGdpdCgpLnN0YXR1cygpYFxuICovXG5leHBvcnQgY2xhc3MgRGlmZlN1bW1hcnkgaW1wbGVtZW50cyBEaWZmUmVzdWx0IHtcbiAgIGNoYW5nZWQgPSAwO1xuICAgZGVsZXRpb25zID0gMDtcbiAgIGluc2VydGlvbnMgPSAwO1xuXG4gICBmaWxlczogQXJyYXk8RGlmZlJlc3VsdFRleHRGaWxlIHwgRGlmZlJlc3VsdEJpbmFyeUZpbGU+ID0gW107XG59XG4iLCAiaW1wb3J0IHsgRGlmZlJlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgTG9nRm9ybWF0IH0gZnJvbSAnLi4vYXJncy9sb2ctZm9ybWF0JztcbmltcG9ydCB7IERpZmZTdW1tYXJ5IH0gZnJvbSAnLi4vcmVzcG9uc2VzL0RpZmZTdW1tYXJ5JztcbmltcG9ydCB7IGlzRGlmZk5hbWVTdGF0dXMgfSBmcm9tICcuLi90YXNrcy9kaWZmLW5hbWUtc3RhdHVzJztcbmltcG9ydCB7IGFzTnVtYmVyLCBMaW5lUGFyc2VyLCBvclZvaWQsIHBhcnNlU3RyaW5nUmVzcG9uc2UgfSBmcm9tICcuLi91dGlscyc7XG5cbmNvbnN0IHN0YXRQYXJzZXIgPSBbXG4gICBuZXcgTGluZVBhcnNlcjxEaWZmUmVzdWx0PihcbiAgICAgIC8oLispXFxzK1xcfFxccysoXFxkKykoXFxzK1srXFwtXSspPyQvLFxuICAgICAgKHJlc3VsdCwgW2ZpbGUsIGNoYW5nZXMsIGFsdGVyYXRpb25zID0gJyddKSA9PiB7XG4gICAgICAgICByZXN1bHQuZmlsZXMucHVzaCh7XG4gICAgICAgICAgICBmaWxlOiBmaWxlLnRyaW0oKSxcbiAgICAgICAgICAgIGNoYW5nZXM6IGFzTnVtYmVyKGNoYW5nZXMpLFxuICAgICAgICAgICAgaW5zZXJ0aW9uczogYWx0ZXJhdGlvbnMucmVwbGFjZSgvW14rXS9nLCAnJykubGVuZ3RoLFxuICAgICAgICAgICAgZGVsZXRpb25zOiBhbHRlcmF0aW9ucy5yZXBsYWNlKC9bXi1dL2csICcnKS5sZW5ndGgsXG4gICAgICAgICAgICBiaW5hcnk6IGZhbHNlLFxuICAgICAgICAgfSk7XG4gICAgICB9XG4gICApLFxuICAgbmV3IExpbmVQYXJzZXI8RGlmZlJlc3VsdD4oXG4gICAgICAvKC4rKSBcXHxcXHMrQmluIChbMC05Ll0rKSAtPiAoWzAtOS5dKykgKFthLXpdKykvLFxuICAgICAgKHJlc3VsdCwgW2ZpbGUsIGJlZm9yZSwgYWZ0ZXJdKSA9PiB7XG4gICAgICAgICByZXN1bHQuZmlsZXMucHVzaCh7XG4gICAgICAgICAgICBmaWxlOiBmaWxlLnRyaW0oKSxcbiAgICAgICAgICAgIGJlZm9yZTogYXNOdW1iZXIoYmVmb3JlKSxcbiAgICAgICAgICAgIGFmdGVyOiBhc051bWJlcihhZnRlciksXG4gICAgICAgICAgICBiaW5hcnk6IHRydWUsXG4gICAgICAgICB9KTtcbiAgICAgIH1cbiAgICksXG4gICBuZXcgTGluZVBhcnNlcjxEaWZmUmVzdWx0PihcbiAgICAgIC8oXFxkKykgZmlsZXM/IGNoYW5nZWRcXHMqKCg/OiwgXFxkKyBbXixdKyl7MCwyfSkvLFxuICAgICAgKHJlc3VsdCwgW2NoYW5nZWQsIHN1bW1hcnldKSA9PiB7XG4gICAgICAgICBjb25zdCBpbnNlcnRlZCA9IC8oXFxkKykgaS8uZXhlYyhzdW1tYXJ5KTtcbiAgICAgICAgIGNvbnN0IGRlbGV0ZWQgPSAvKFxcZCspIGQvLmV4ZWMoc3VtbWFyeSk7XG5cbiAgICAgICAgIHJlc3VsdC5jaGFuZ2VkID0gYXNOdW1iZXIoY2hhbmdlZCk7XG4gICAgICAgICByZXN1bHQuaW5zZXJ0aW9ucyA9IGFzTnVtYmVyKGluc2VydGVkPy5bMV0pO1xuICAgICAgICAgcmVzdWx0LmRlbGV0aW9ucyA9IGFzTnVtYmVyKGRlbGV0ZWQ/LlsxXSk7XG4gICAgICB9XG4gICApLFxuXTtcblxuY29uc3QgbnVtU3RhdFBhcnNlciA9IFtcbiAgIG5ldyBMaW5lUGFyc2VyPERpZmZSZXN1bHQ+KFxuICAgICAgLyhcXGQrKVxcdChcXGQrKVxcdCguKykkLyxcbiAgICAgIChyZXN1bHQsIFtjaGFuZ2VzSW5zZXJ0LCBjaGFuZ2VzRGVsZXRlLCBmaWxlXSkgPT4ge1xuICAgICAgICAgY29uc3QgaW5zZXJ0aW9ucyA9IGFzTnVtYmVyKGNoYW5nZXNJbnNlcnQpO1xuICAgICAgICAgY29uc3QgZGVsZXRpb25zID0gYXNOdW1iZXIoY2hhbmdlc0RlbGV0ZSk7XG5cbiAgICAgICAgIHJlc3VsdC5jaGFuZ2VkKys7XG4gICAgICAgICByZXN1bHQuaW5zZXJ0aW9ucyArPSBpbnNlcnRpb25zO1xuICAgICAgICAgcmVzdWx0LmRlbGV0aW9ucyArPSBkZWxldGlvbnM7XG5cbiAgICAgICAgIHJlc3VsdC5maWxlcy5wdXNoKHtcbiAgICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgICBjaGFuZ2VzOiBpbnNlcnRpb25zICsgZGVsZXRpb25zLFxuICAgICAgICAgICAgaW5zZXJ0aW9ucyxcbiAgICAgICAgICAgIGRlbGV0aW9ucyxcbiAgICAgICAgICAgIGJpbmFyeTogZmFsc2UsXG4gICAgICAgICB9KTtcbiAgICAgIH1cbiAgICksXG4gICBuZXcgTGluZVBhcnNlcjxEaWZmUmVzdWx0PigvLVxcdC1cXHQoLispJC8sIChyZXN1bHQsIFtmaWxlXSkgPT4ge1xuICAgICAgcmVzdWx0LmNoYW5nZWQrKztcblxuICAgICAgcmVzdWx0LmZpbGVzLnB1c2goe1xuICAgICAgICAgZmlsZSxcbiAgICAgICAgIGFmdGVyOiAwLFxuICAgICAgICAgYmVmb3JlOiAwLFxuICAgICAgICAgYmluYXJ5OiB0cnVlLFxuICAgICAgfSk7XG4gICB9KSxcbl07XG5cbmNvbnN0IG5hbWVPbmx5UGFyc2VyID0gW1xuICAgbmV3IExpbmVQYXJzZXI8RGlmZlJlc3VsdD4oLyguKykkLywgKHJlc3VsdCwgW2ZpbGVdKSA9PiB7XG4gICAgICByZXN1bHQuY2hhbmdlZCsrO1xuICAgICAgcmVzdWx0LmZpbGVzLnB1c2goe1xuICAgICAgICAgZmlsZSxcbiAgICAgICAgIGNoYW5nZXM6IDAsXG4gICAgICAgICBpbnNlcnRpb25zOiAwLFxuICAgICAgICAgZGVsZXRpb25zOiAwLFxuICAgICAgICAgYmluYXJ5OiBmYWxzZSxcbiAgICAgIH0pO1xuICAgfSksXG5dO1xuXG5jb25zdCBuYW1lU3RhdHVzUGFyc2VyID0gW1xuICAgbmV3IExpbmVQYXJzZXI8RGlmZlJlc3VsdD4oXG4gICAgICAvKFtBQ0RNUlRVWEJdKShbMC05XXswLDN9KVxcdCguW15cXHRdKikoXFx0KC5bXlxcdF0qKSk/JC8sXG4gICAgICAocmVzdWx0LCBbc3RhdHVzLCBfc2ltaWxhcml0eSwgZnJvbSwgX3RvLCB0b10pID0+IHtcbiAgICAgICAgIHJlc3VsdC5jaGFuZ2VkKys7XG4gICAgICAgICByZXN1bHQuZmlsZXMucHVzaCh7XG4gICAgICAgICAgICBmaWxlOiB0byA/PyBmcm9tLFxuICAgICAgICAgICAgY2hhbmdlczogMCxcbiAgICAgICAgICAgIHN0YXR1czogb3JWb2lkKGlzRGlmZk5hbWVTdGF0dXMoc3RhdHVzKSAmJiBzdGF0dXMpLFxuICAgICAgICAgICAgaW5zZXJ0aW9uczogMCxcbiAgICAgICAgICAgIGRlbGV0aW9uczogMCxcbiAgICAgICAgICAgIGJpbmFyeTogZmFsc2UsXG4gICAgICAgICB9KTtcbiAgICAgIH1cbiAgICksXG5dO1xuXG5jb25zdCBkaWZmU3VtbWFyeVBhcnNlcnM6IFJlY29yZDxMb2dGb3JtYXQsIExpbmVQYXJzZXI8RGlmZlJlc3VsdD5bXT4gPSB7XG4gICBbTG9nRm9ybWF0Lk5PTkVdOiBzdGF0UGFyc2VyLFxuICAgW0xvZ0Zvcm1hdC5TVEFUXTogc3RhdFBhcnNlcixcbiAgIFtMb2dGb3JtYXQuTlVNX1NUQVRdOiBudW1TdGF0UGFyc2VyLFxuICAgW0xvZ0Zvcm1hdC5OQU1FX1NUQVRVU106IG5hbWVTdGF0dXNQYXJzZXIsXG4gICBbTG9nRm9ybWF0Lk5BTUVfT05MWV06IG5hbWVPbmx5UGFyc2VyLFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldERpZmZQYXJzZXIoZm9ybWF0ID0gTG9nRm9ybWF0Lk5PTkUpIHtcbiAgIGNvbnN0IHBhcnNlciA9IGRpZmZTdW1tYXJ5UGFyc2Vyc1tmb3JtYXRdO1xuXG4gICByZXR1cm4gKHN0ZE91dDogc3RyaW5nKSA9PiBwYXJzZVN0cmluZ1Jlc3BvbnNlKG5ldyBEaWZmU3VtbWFyeSgpLCBwYXJzZXIsIHN0ZE91dCwgZmFsc2UpO1xufVxuIiwgImltcG9ydCB7IExpc3RMb2dMaW5lLCBMb2dSZXN1bHQgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IHRvTGluZXNXaXRoQ29udGVudCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IGdldERpZmZQYXJzZXIgfSBmcm9tICcuL3BhcnNlLWRpZmYtc3VtbWFyeSc7XG5pbXBvcnQgeyBMb2dGb3JtYXQgfSBmcm9tICcuLi9hcmdzL2xvZy1mb3JtYXQnO1xuXG5leHBvcnQgY29uc3QgU1RBUlRfQk9VTkRBUlkgPSAnXHUwMEYyXHUwMEYyXHUwMEYyXHUwMEYyXHUwMEYyXHUwMEYyICc7XG5cbmV4cG9ydCBjb25zdCBDT01NSVRfQk9VTkRBUlkgPSAnIFx1MDBGMlx1MDBGMic7XG5cbmV4cG9ydCBjb25zdCBTUExJVFRFUiA9ICcgXHUwMEYyICc7XG5cbmNvbnN0IGRlZmF1bHRGaWVsZE5hbWVzID0gWydoYXNoJywgJ2RhdGUnLCAnbWVzc2FnZScsICdyZWZzJywgJ2F1dGhvcl9uYW1lJywgJ2F1dGhvcl9lbWFpbCddO1xuXG5mdW5jdGlvbiBsaW5lQnVpbGRlcih0b2tlbnM6IHN0cmluZ1tdLCBmaWVsZHM6IHN0cmluZ1tdKTogYW55IHtcbiAgIHJldHVybiBmaWVsZHMucmVkdWNlKFxuICAgICAgKGxpbmUsIGZpZWxkLCBpbmRleCkgPT4ge1xuICAgICAgICAgbGluZVtmaWVsZF0gPSB0b2tlbnNbaW5kZXhdIHx8ICcnO1xuICAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgICB9LFxuICAgICAgT2JqZWN0LmNyZWF0ZSh7IGRpZmY6IG51bGwgfSkgYXMgYW55XG4gICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTGlzdExvZ1N1bW1hcnlQYXJzZXI8VCA9IGFueT4oXG4gICBzcGxpdHRlciA9IFNQTElUVEVSLFxuICAgZmllbGRzID0gZGVmYXVsdEZpZWxkTmFtZXMsXG4gICBsb2dGb3JtYXQgPSBMb2dGb3JtYXQuTk9ORVxuKSB7XG4gICBjb25zdCBwYXJzZURpZmZSZXN1bHQgPSBnZXREaWZmUGFyc2VyKGxvZ0Zvcm1hdCk7XG5cbiAgIHJldHVybiBmdW5jdGlvbiAoc3RkT3V0OiBzdHJpbmcpOiBMb2dSZXN1bHQ8VD4ge1xuICAgICAgY29uc3QgYWxsOiBSZWFkb25seUFycmF5PFQgJiBMaXN0TG9nTGluZT4gPSB0b0xpbmVzV2l0aENvbnRlbnQoXG4gICAgICAgICBzdGRPdXQsXG4gICAgICAgICB0cnVlLFxuICAgICAgICAgU1RBUlRfQk9VTkRBUllcbiAgICAgICkubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICBjb25zdCBsaW5lRGV0YWlsID0gaXRlbS50cmltKCkuc3BsaXQoQ09NTUlUX0JPVU5EQVJZKTtcbiAgICAgICAgIGNvbnN0IGxpc3RMb2dMaW5lOiBUICYgTGlzdExvZ0xpbmUgPSBsaW5lQnVpbGRlcihcbiAgICAgICAgICAgIGxpbmVEZXRhaWxbMF0udHJpbSgpLnNwbGl0KHNwbGl0dGVyKSxcbiAgICAgICAgICAgIGZpZWxkc1xuICAgICAgICAgKTtcblxuICAgICAgICAgaWYgKGxpbmVEZXRhaWwubGVuZ3RoID4gMSAmJiAhIWxpbmVEZXRhaWxbMV0udHJpbSgpKSB7XG4gICAgICAgICAgICBsaXN0TG9nTGluZS5kaWZmID0gcGFyc2VEaWZmUmVzdWx0KGxpbmVEZXRhaWxbMV0pO1xuICAgICAgICAgfVxuXG4gICAgICAgICByZXR1cm4gbGlzdExvZ0xpbmU7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgIGFsbCxcbiAgICAgICAgIGxhdGVzdDogKGFsbC5sZW5ndGggJiYgYWxsWzBdKSB8fCBudWxsLFxuICAgICAgICAgdG90YWw6IGFsbC5sZW5ndGgsXG4gICAgICB9O1xuICAgfTtcbn1cbiIsICJpbXBvcnQgeyBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgRGlmZlJlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgaXNMb2dGb3JtYXQsIExvZ0Zvcm1hdCwgbG9nRm9ybWF0RnJvbUNvbW1hbmQgfSBmcm9tICcuLi9hcmdzL2xvZy1mb3JtYXQnO1xuaW1wb3J0IHsgZ2V0RGlmZlBhcnNlciB9IGZyb20gJy4uL3BhcnNlcnMvcGFyc2UtZGlmZi1zdW1tYXJ5JztcbmltcG9ydCB7IGNvbmZpZ3VyYXRpb25FcnJvclRhc2ssIEVtcHR5VGFzayB9IGZyb20gJy4vdGFzayc7XG5cbmV4cG9ydCBmdW5jdGlvbiBkaWZmU3VtbWFyeVRhc2soY3VzdG9tQXJnczogc3RyaW5nW10pOiBTdHJpbmdUYXNrPERpZmZSZXN1bHQ+IHwgRW1wdHlUYXNrIHtcbiAgIGxldCBsb2dGb3JtYXQgPSBsb2dGb3JtYXRGcm9tQ29tbWFuZChjdXN0b21BcmdzKTtcblxuICAgY29uc3QgY29tbWFuZHMgPSBbJ2RpZmYnXTtcblxuICAgaWYgKGxvZ0Zvcm1hdCA9PT0gTG9nRm9ybWF0Lk5PTkUpIHtcbiAgICAgIGxvZ0Zvcm1hdCA9IExvZ0Zvcm1hdC5TVEFUO1xuICAgICAgY29tbWFuZHMucHVzaCgnLS1zdGF0PTQwOTYnKTtcbiAgIH1cblxuICAgY29tbWFuZHMucHVzaCguLi5jdXN0b21BcmdzKTtcblxuICAgcmV0dXJuIChcbiAgICAgIHZhbGlkYXRlTG9nRm9ybWF0Q29uZmlnKGNvbW1hbmRzKSB8fCB7XG4gICAgICAgICBjb21tYW5kcyxcbiAgICAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgICAgIHBhcnNlcjogZ2V0RGlmZlBhcnNlcihsb2dGb3JtYXQpLFxuICAgICAgfVxuICAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlTG9nRm9ybWF0Q29uZmlnKGN1c3RvbUFyZ3M6IHVua25vd25bXSk6IEVtcHR5VGFzayB8IHZvaWQge1xuICAgY29uc3QgZmxhZ3MgPSBjdXN0b21BcmdzLmZpbHRlcihpc0xvZ0Zvcm1hdCk7XG5cbiAgIGlmIChmbGFncy5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4gY29uZmlndXJhdGlvbkVycm9yVGFzayhcbiAgICAgICAgIGBTdW1tYXJ5IGZsYWdzIGFyZSBtdXR1YWxseSBleGNsdXNpdmUgLSBwaWNrIG9uZSBvZiAke2ZsYWdzLmpvaW4oJywnKX1gXG4gICAgICApO1xuICAgfVxuXG4gICBpZiAoZmxhZ3MubGVuZ3RoICYmIGN1c3RvbUFyZ3MuaW5jbHVkZXMoJy16JykpIHtcbiAgICAgIHJldHVybiBjb25maWd1cmF0aW9uRXJyb3JUYXNrKFxuICAgICAgICAgYFN1bW1hcnkgZmxhZyAke2ZsYWdzfSBwYXJzaW5nIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggbnVsbCB0ZXJtaW5hdGlvbiBvcHRpb24gJy16J2BcbiAgICAgICk7XG4gICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBPcHRpb25zLCBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHR5cGUgeyBMb2dSZXN1bHQsIFNpbXBsZUdpdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgbG9nRm9ybWF0RnJvbUNvbW1hbmQgfSBmcm9tICcuLi9hcmdzL2xvZy1mb3JtYXQnO1xuaW1wb3J0IHsgcGF0aHNwZWMgfSBmcm9tICcuLi9hcmdzL3BhdGhzcGVjJztcbmltcG9ydCB7XG4gICBDT01NSVRfQk9VTkRBUlksXG4gICBjcmVhdGVMaXN0TG9nU3VtbWFyeVBhcnNlcixcbiAgIFNQTElUVEVSLFxuICAgU1RBUlRfQk9VTkRBUlksXG59IGZyb20gJy4uL3BhcnNlcnMvcGFyc2UtbGlzdC1sb2ctc3VtbWFyeSc7XG5pbXBvcnQge1xuICAgYXBwZW5kVGFza09wdGlvbnMsXG4gICBmaWx0ZXJBcnJheSxcbiAgIGZpbHRlclByaW1pdGl2ZXMsXG4gICBmaWx0ZXJTdHJpbmcsXG4gICBmaWx0ZXJUeXBlLFxuICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50LFxuICAgdHJhaWxpbmdPcHRpb25zQXJndW1lbnQsXG59IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IFNpbXBsZUdpdEFwaSB9IGZyb20gJy4uL3NpbXBsZS1naXQtYXBpJztcbmltcG9ydCB7IGNvbmZpZ3VyYXRpb25FcnJvclRhc2sgfSBmcm9tICcuL3Rhc2snO1xuaW1wb3J0IHsgdmFsaWRhdGVMb2dGb3JtYXRDb25maWcgfSBmcm9tICcuL2RpZmYnO1xuXG5lbnVtIGV4Y2x1ZGVPcHRpb25zIHtcbiAgICctLXByZXR0eScsXG4gICAnbWF4LWNvdW50JyxcbiAgICdtYXhDb3VudCcsXG4gICAnbicsXG4gICAnZmlsZScsXG4gICAnZm9ybWF0JyxcbiAgICdmcm9tJyxcbiAgICd0bycsXG4gICAnc3BsaXR0ZXInLFxuICAgJ3N5bW1ldHJpYycsXG4gICAnbWFpbE1hcCcsXG4gICAnbXVsdGlMaW5lJyxcbiAgICdzdHJpY3REYXRlJyxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEZWZhdWx0TG9nRmllbGRzIHtcbiAgIGhhc2g6IHN0cmluZztcbiAgIGRhdGU6IHN0cmluZztcbiAgIG1lc3NhZ2U6IHN0cmluZztcbiAgIHJlZnM6IHN0cmluZztcbiAgIGJvZHk6IHN0cmluZztcbiAgIGF1dGhvcl9uYW1lOiBzdHJpbmc7XG4gICBhdXRob3JfZW1haWw6IHN0cmluZztcbn1cblxuZXhwb3J0IHR5cGUgTG9nT3B0aW9uczxUID0gRGVmYXVsdExvZ0ZpZWxkcz4gPSB7XG4gICBmaWxlPzogc3RyaW5nO1xuICAgZm9ybWF0PzogVDtcbiAgIGZyb20/OiBzdHJpbmc7XG4gICBtYWlsTWFwPzogYm9vbGVhbjtcbiAgIG1heENvdW50PzogbnVtYmVyO1xuICAgbXVsdGlMaW5lPzogYm9vbGVhbjtcbiAgIHNwbGl0dGVyPzogc3RyaW5nO1xuICAgc3RyaWN0RGF0ZT86IGJvb2xlYW47XG4gICBzeW1tZXRyaWM/OiBib29sZWFuO1xuICAgdG8/OiBzdHJpbmc7XG59O1xuXG5pbnRlcmZhY2UgUGFyc2VkTG9nT3B0aW9ucyB7XG4gICBmaWVsZHM6IHN0cmluZ1tdO1xuICAgc3BsaXR0ZXI6IHN0cmluZztcbiAgIGNvbW1hbmRzOiBzdHJpbmdbXTtcbn1cblxuZnVuY3Rpb24gcHJldHR5Rm9ybWF0KFxuICAgZm9ybWF0OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCB1bmtub3duPixcbiAgIHNwbGl0dGVyOiBzdHJpbmdcbik6IFtzdHJpbmdbXSwgc3RyaW5nXSB7XG4gICBjb25zdCBmaWVsZHM6IHN0cmluZ1tdID0gW107XG4gICBjb25zdCBmb3JtYXRTdHI6IHN0cmluZ1tdID0gW107XG5cbiAgIE9iamVjdC5rZXlzKGZvcm1hdCkuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICAgIGZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgICAgIGZvcm1hdFN0ci5wdXNoKFN0cmluZyhmb3JtYXRbZmllbGRdKSk7XG4gICB9KTtcblxuICAgcmV0dXJuIFtmaWVsZHMsIGZvcm1hdFN0ci5qb2luKHNwbGl0dGVyKV07XG59XG5cbmZ1bmN0aW9uIHVzZXJPcHRpb25zPFQgZXh0ZW5kcyBPcHRpb25zPihpbnB1dDogVCk6IE9wdGlvbnMge1xuICAgcmV0dXJuIE9iamVjdC5rZXlzKGlucHV0KS5yZWR1Y2UoKG91dCwga2V5KSA9PiB7XG4gICAgICBpZiAoIShrZXkgaW4gZXhjbHVkZU9wdGlvbnMpKSB7XG4gICAgICAgICBvdXRba2V5XSA9IGlucHV0W2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0O1xuICAgfSwge30gYXMgT3B0aW9ucyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUxvZ09wdGlvbnM8VCBleHRlbmRzIE9wdGlvbnM+KFxuICAgb3B0OiBPcHRpb25zIHwgTG9nT3B0aW9uczxUPiA9IHt9LFxuICAgY3VzdG9tQXJnczogc3RyaW5nW10gPSBbXVxuKTogUGFyc2VkTG9nT3B0aW9ucyB7XG4gICBjb25zdCBzcGxpdHRlciA9IGZpbHRlclR5cGUob3B0LnNwbGl0dGVyLCBmaWx0ZXJTdHJpbmcsIFNQTElUVEVSKTtcbiAgIGNvbnN0IGZvcm1hdCA9XG4gICAgICAhZmlsdGVyUHJpbWl0aXZlcyhvcHQuZm9ybWF0KSAmJiBvcHQuZm9ybWF0XG4gICAgICAgICA/IG9wdC5mb3JtYXRcbiAgICAgICAgIDoge1xuICAgICAgICAgICAgICBoYXNoOiAnJUgnLFxuICAgICAgICAgICAgICBkYXRlOiBvcHQuc3RyaWN0RGF0ZSA9PT0gZmFsc2UgPyAnJWFpJyA6ICclYUknLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAnJXMnLFxuICAgICAgICAgICAgICByZWZzOiAnJUQnLFxuICAgICAgICAgICAgICBib2R5OiBvcHQubXVsdGlMaW5lID8gJyVCJyA6ICclYicsXG4gICAgICAgICAgICAgIGF1dGhvcl9uYW1lOiBvcHQubWFpbE1hcCAhPT0gZmFsc2UgPyAnJWFOJyA6ICclYW4nLFxuICAgICAgICAgICAgICBhdXRob3JfZW1haWw6IG9wdC5tYWlsTWFwICE9PSBmYWxzZSA/ICclYUUnIDogJyVhZScsXG4gICAgICAgICAgIH07XG5cbiAgIGNvbnN0IFtmaWVsZHMsIGZvcm1hdFN0cl0gPSBwcmV0dHlGb3JtYXQoZm9ybWF0LCBzcGxpdHRlcik7XG5cbiAgIGNvbnN0IHN1ZmZpeDogc3RyaW5nW10gPSBbXTtcbiAgIGNvbnN0IGNvbW1hbmQ6IHN0cmluZ1tdID0gW1xuICAgICAgYC0tcHJldHR5PWZvcm1hdDoke1NUQVJUX0JPVU5EQVJZfSR7Zm9ybWF0U3RyfSR7Q09NTUlUX0JPVU5EQVJZfWAsXG4gICAgICAuLi5jdXN0b21BcmdzLFxuICAgXTtcblxuICAgY29uc3QgbWF4Q291bnQ6IG51bWJlciB8IHVuZGVmaW5lZCA9IChvcHQgYXMgYW55KS5uIHx8IChvcHQgYXMgYW55KVsnbWF4LWNvdW50J10gfHwgb3B0Lm1heENvdW50O1xuICAgaWYgKG1heENvdW50KSB7XG4gICAgICBjb21tYW5kLnB1c2goYC0tbWF4LWNvdW50PSR7bWF4Q291bnR9YCk7XG4gICB9XG5cbiAgIGlmIChvcHQuZnJvbSB8fCBvcHQudG8pIHtcbiAgICAgIGNvbnN0IHJhbmdlT3BlcmF0b3IgPSBvcHQuc3ltbWV0cmljICE9PSBmYWxzZSA/ICcuLi4nIDogJy4uJztcbiAgICAgIHN1ZmZpeC5wdXNoKGAke29wdC5mcm9tIHx8ICcnfSR7cmFuZ2VPcGVyYXRvcn0ke29wdC50byB8fCAnJ31gKTtcbiAgIH1cblxuICAgaWYgKGZpbHRlclN0cmluZyhvcHQuZmlsZSkpIHtcbiAgICAgIGNvbW1hbmQucHVzaCgnLS1mb2xsb3cnLCBwYXRoc3BlYyhvcHQuZmlsZSkpO1xuICAgfVxuXG4gICBhcHBlbmRUYXNrT3B0aW9ucyh1c2VyT3B0aW9ucyhvcHQgYXMgT3B0aW9ucyksIGNvbW1hbmQpO1xuXG4gICByZXR1cm4ge1xuICAgICAgZmllbGRzLFxuICAgICAgc3BsaXR0ZXIsXG4gICAgICBjb21tYW5kczogWy4uLmNvbW1hbmQsIC4uLnN1ZmZpeF0sXG4gICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9nVGFzazxUPihcbiAgIHNwbGl0dGVyOiBzdHJpbmcsXG4gICBmaWVsZHM6IHN0cmluZ1tdLFxuICAgY3VzdG9tQXJnczogc3RyaW5nW11cbik6IFN0cmluZ1Rhc2s8TG9nUmVzdWx0PFQ+PiB7XG4gICBjb25zdCBwYXJzZXIgPSBjcmVhdGVMaXN0TG9nU3VtbWFyeVBhcnNlcihzcGxpdHRlciwgZmllbGRzLCBsb2dGb3JtYXRGcm9tQ29tbWFuZChjdXN0b21BcmdzKSk7XG5cbiAgIHJldHVybiB7XG4gICAgICBjb21tYW5kczogWydsb2cnLCAuLi5jdXN0b21BcmdzXSxcbiAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgIHBhcnNlcixcbiAgIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpOiBQaWNrPFNpbXBsZUdpdCwgJ2xvZyc+IHtcbiAgIHJldHVybiB7XG4gICAgICBsb2c8VCBleHRlbmRzIE9wdGlvbnM+KHRoaXM6IFNpbXBsZUdpdEFwaSwgLi4ucmVzdDogdW5rbm93bltdKSB7XG4gICAgICAgICBjb25zdCBuZXh0ID0gdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cyk7XG4gICAgICAgICBjb25zdCBvcHRpb25zID0gcGFyc2VMb2dPcHRpb25zPFQ+KFxuICAgICAgICAgICAgdHJhaWxpbmdPcHRpb25zQXJndW1lbnQoYXJndW1lbnRzKSxcbiAgICAgICAgICAgIGZpbHRlclR5cGUoYXJndW1lbnRzWzBdLCBmaWx0ZXJBcnJheSlcbiAgICAgICAgICk7XG4gICAgICAgICBjb25zdCB0YXNrID1cbiAgICAgICAgICAgIHJlamVjdERlcHJlY2F0ZWRTaWduYXR1cmVzKC4uLnJlc3QpIHx8XG4gICAgICAgICAgICB2YWxpZGF0ZUxvZ0Zvcm1hdENvbmZpZyhvcHRpb25zLmNvbW1hbmRzKSB8fFxuICAgICAgICAgICAgY3JlYXRlTG9nVGFzayhvcHRpb25zKTtcblxuICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2sodGFzaywgbmV4dCk7XG4gICAgICB9LFxuICAgfTtcblxuICAgZnVuY3Rpb24gY3JlYXRlTG9nVGFzayhvcHRpb25zOiBQYXJzZWRMb2dPcHRpb25zKSB7XG4gICAgICByZXR1cm4gbG9nVGFzayhvcHRpb25zLnNwbGl0dGVyLCBvcHRpb25zLmZpZWxkcywgb3B0aW9ucy5jb21tYW5kcyk7XG4gICB9XG5cbiAgIGZ1bmN0aW9uIHJlamVjdERlcHJlY2F0ZWRTaWduYXR1cmVzKGZyb20/OiB1bmtub3duLCB0bz86IHVua25vd24pIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgICBmaWx0ZXJTdHJpbmcoZnJvbSkgJiZcbiAgICAgICAgIGZpbHRlclN0cmluZyh0bykgJiZcbiAgICAgICAgIGNvbmZpZ3VyYXRpb25FcnJvclRhc2soXG4gICAgICAgICAgICBgZ2l0LmxvZyhzdHJpbmcsIHN0cmluZykgc2hvdWxkIGJlIHJlcGxhY2VkIHdpdGggZ2l0LmxvZyh7IGZyb206IHN0cmluZywgdG86IHN0cmluZyB9KWBcbiAgICAgICAgIClcbiAgICAgICk7XG4gICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgIE1lcmdlQ29uZmxpY3QsXG4gICBNZXJnZUNvbmZsaWN0RGVsZXRpb24sXG4gICBNZXJnZURldGFpbCxcbiAgIE1lcmdlUmVzdWx0U3RhdHVzLFxufSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcblxuZXhwb3J0IGNsYXNzIE1lcmdlU3VtbWFyeUNvbmZsaWN0IGltcGxlbWVudHMgTWVyZ2VDb25mbGljdCB7XG4gICBjb25zdHJ1Y3RvcihcbiAgICAgIHB1YmxpYyByZWFkb25seSByZWFzb246IHN0cmluZyxcbiAgICAgIHB1YmxpYyByZWFkb25seSBmaWxlOiBzdHJpbmcgfCBudWxsID0gbnVsbCxcbiAgICAgIHB1YmxpYyByZWFkb25seSBtZXRhPzogTWVyZ2VDb25mbGljdERlbGV0aW9uXG4gICApIHt9XG5cbiAgIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIGAke3RoaXMuZmlsZX06JHt0aGlzLnJlYXNvbn1gO1xuICAgfVxufVxuXG5leHBvcnQgY2xhc3MgTWVyZ2VTdW1tYXJ5RGV0YWlsIGltcGxlbWVudHMgTWVyZ2VEZXRhaWwge1xuICAgcHVibGljIGNvbmZsaWN0czogTWVyZ2VDb25mbGljdFtdID0gW107XG4gICBwdWJsaWMgbWVyZ2VzOiBzdHJpbmdbXSA9IFtdO1xuICAgcHVibGljIHJlc3VsdDogTWVyZ2VSZXN1bHRTdGF0dXMgPSAnc3VjY2Vzcyc7XG5cbiAgIGdldCBmYWlsZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25mbGljdHMubGVuZ3RoID4gMDtcbiAgIH1cblxuICAgZ2V0IHJlYXNvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlc3VsdDtcbiAgIH1cblxuICAgdG9TdHJpbmcoKSB7XG4gICAgICBpZiAodGhpcy5jb25mbGljdHMubGVuZ3RoKSB7XG4gICAgICAgICByZXR1cm4gYENPTkZMSUNUUzogJHt0aGlzLmNvbmZsaWN0cy5qb2luKCcsICcpfWA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnT0snO1xuICAgfVxufVxuIiwgImltcG9ydCB7XG4gICBQdWxsRGV0YWlsRmlsZUNoYW5nZXMsXG4gICBQdWxsRGV0YWlsU3VtbWFyeSxcbiAgIFB1bGxGYWlsZWRSZXN1bHQsXG4gICBQdWxsUmVzdWx0LFxufSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcblxuZXhwb3J0IGNsYXNzIFB1bGxTdW1tYXJ5IGltcGxlbWVudHMgUHVsbFJlc3VsdCB7XG4gICBwdWJsaWMgcmVtb3RlTWVzc2FnZXMgPSB7XG4gICAgICBhbGw6IFtdLFxuICAgfTtcbiAgIHB1YmxpYyBjcmVhdGVkID0gW107XG4gICBwdWJsaWMgZGVsZXRlZDogc3RyaW5nW10gPSBbXTtcbiAgIHB1YmxpYyBmaWxlczogc3RyaW5nW10gPSBbXTtcbiAgIHB1YmxpYyBkZWxldGlvbnM6IFB1bGxEZXRhaWxGaWxlQ2hhbmdlcyA9IHt9O1xuICAgcHVibGljIGluc2VydGlvbnM6IFB1bGxEZXRhaWxGaWxlQ2hhbmdlcyA9IHt9O1xuICAgcHVibGljIHN1bW1hcnk6IFB1bGxEZXRhaWxTdW1tYXJ5ID0ge1xuICAgICAgY2hhbmdlczogMCxcbiAgICAgIGRlbGV0aW9uczogMCxcbiAgICAgIGluc2VydGlvbnM6IDAsXG4gICB9O1xufVxuXG5leHBvcnQgY2xhc3MgUHVsbEZhaWxlZFN1bW1hcnkgaW1wbGVtZW50cyBQdWxsRmFpbGVkUmVzdWx0IHtcbiAgIHJlbW90ZSA9ICcnO1xuICAgaGFzaCA9IHtcbiAgICAgIGxvY2FsOiAnJyxcbiAgICAgIHJlbW90ZTogJycsXG4gICB9O1xuICAgYnJhbmNoID0ge1xuICAgICAgbG9jYWw6ICcnLFxuICAgICAgcmVtb3RlOiAnJyxcbiAgIH07XG4gICBtZXNzYWdlID0gJyc7XG5cbiAgIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbiAgIH1cbn1cbiIsICJpbXBvcnQge1xuICAgUmVtb3RlTWVzc2FnZVJlc3VsdCxcbiAgIFJlbW90ZU1lc3NhZ2VzLFxuICAgUmVtb3RlTWVzc2FnZXNPYmplY3RFbnVtZXJhdGlvbixcbn0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBhc051bWJlciwgUmVtb3RlTGluZVBhcnNlciB9IGZyb20gJy4uL3V0aWxzJztcblxuZnVuY3Rpb24gb2JqZWN0RW51bWVyYXRpb25SZXN1bHQ8VCBleHRlbmRzIFJlbW90ZU1lc3NhZ2VzID0gUmVtb3RlTWVzc2FnZXM+KFxuICAgcmVtb3RlTWVzc2FnZXM6IFRcbik6IFJlbW90ZU1lc3NhZ2VzT2JqZWN0RW51bWVyYXRpb24ge1xuICAgcmV0dXJuIChyZW1vdGVNZXNzYWdlcy5vYmplY3RzID0gcmVtb3RlTWVzc2FnZXMub2JqZWN0cyB8fCB7XG4gICAgICBjb21wcmVzc2luZzogMCxcbiAgICAgIGNvdW50aW5nOiAwLFxuICAgICAgZW51bWVyYXRpbmc6IDAsXG4gICAgICBwYWNrUmV1c2VkOiAwLFxuICAgICAgcmV1c2VkOiB7IGNvdW50OiAwLCBkZWx0YTogMCB9LFxuICAgICAgdG90YWw6IHsgY291bnQ6IDAsIGRlbHRhOiAwIH0sXG4gICB9KTtcbn1cblxuZnVuY3Rpb24gYXNPYmplY3RDb3VudChzb3VyY2U6IHN0cmluZykge1xuICAgY29uc3QgY291bnQgPSAvXlxccyooXFxkKykvLmV4ZWMoc291cmNlKTtcbiAgIGNvbnN0IGRlbHRhID0gL2RlbHRhIChcXGQrKS9pLmV4ZWMoc291cmNlKTtcblxuICAgcmV0dXJuIHtcbiAgICAgIGNvdW50OiBhc051bWJlcigoY291bnQgJiYgY291bnRbMV0pIHx8ICcwJyksXG4gICAgICBkZWx0YTogYXNOdW1iZXIoKGRlbHRhICYmIGRlbHRhWzFdKSB8fCAnMCcpLFxuICAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IHJlbW90ZU1lc3NhZ2VzT2JqZWN0UGFyc2VyczogUmVtb3RlTGluZVBhcnNlcjxSZW1vdGVNZXNzYWdlUmVzdWx0PFJlbW90ZU1lc3NhZ2VzPj5bXSA9XG4gICBbXG4gICAgICBuZXcgUmVtb3RlTGluZVBhcnNlcihcbiAgICAgICAgIC9ecmVtb3RlOlxccyooZW51bWVyYXRpbmd8Y291bnRpbmd8Y29tcHJlc3NpbmcpIG9iamVjdHM6IChcXGQrKSwvaSxcbiAgICAgICAgIChyZXN1bHQsIFthY3Rpb24sIGNvdW50XSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gYWN0aW9uLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjb25zdCBlbnVtZXJhdGlvbiA9IG9iamVjdEVudW1lcmF0aW9uUmVzdWx0KHJlc3VsdC5yZW1vdGVNZXNzYWdlcyk7XG5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oZW51bWVyYXRpb24sIHsgW2tleV06IGFzTnVtYmVyKGNvdW50KSB9KTtcbiAgICAgICAgIH1cbiAgICAgICksXG4gICAgICBuZXcgUmVtb3RlTGluZVBhcnNlcihcbiAgICAgICAgIC9ecmVtb3RlOlxccyooZW51bWVyYXRpbmd8Y291bnRpbmd8Y29tcHJlc3NpbmcpIG9iamVjdHM6IFxcZCslIFxcKFxcZCtcXC8oXFxkKylcXCksL2ksXG4gICAgICAgICAocmVzdWx0LCBbYWN0aW9uLCBjb3VudF0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGFjdGlvbi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgY29uc3QgZW51bWVyYXRpb24gPSBvYmplY3RFbnVtZXJhdGlvblJlc3VsdChyZXN1bHQucmVtb3RlTWVzc2FnZXMpO1xuXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGVudW1lcmF0aW9uLCB7IFtrZXldOiBhc051bWJlcihjb3VudCkgfSk7XG4gICAgICAgICB9XG4gICAgICApLFxuICAgICAgbmV3IFJlbW90ZUxpbmVQYXJzZXIoXG4gICAgICAgICAvdG90YWwgKFteLF0rKSwgcmV1c2VkIChbXixdKyksIHBhY2stcmV1c2VkIChcXGQrKS9pLFxuICAgICAgICAgKHJlc3VsdCwgW3RvdGFsLCByZXVzZWQsIHBhY2tSZXVzZWRdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvYmplY3RzID0gb2JqZWN0RW51bWVyYXRpb25SZXN1bHQocmVzdWx0LnJlbW90ZU1lc3NhZ2VzKTtcbiAgICAgICAgICAgIG9iamVjdHMudG90YWwgPSBhc09iamVjdENvdW50KHRvdGFsKTtcbiAgICAgICAgICAgIG9iamVjdHMucmV1c2VkID0gYXNPYmplY3RDb3VudChyZXVzZWQpO1xuICAgICAgICAgICAgb2JqZWN0cy5wYWNrUmV1c2VkID0gYXNOdW1iZXIocGFja1JldXNlZCk7XG4gICAgICAgICB9XG4gICAgICApLFxuICAgXTtcbiIsICJpbXBvcnQgeyBQdXNoUmVzdWx0UmVtb3RlTWVzc2FnZXMsIFJlbW90ZU1lc3NhZ2VSZXN1bHQsIFJlbW90ZU1lc3NhZ2VzIH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBhc051bWJlciwgcGFyc2VTdHJpbmdSZXNwb25zZSwgUmVtb3RlTGluZVBhcnNlciB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IHJlbW90ZU1lc3NhZ2VzT2JqZWN0UGFyc2VycyB9IGZyb20gJy4vcGFyc2UtcmVtb3RlLW9iamVjdHMnO1xuXG5jb25zdCBwYXJzZXJzOiBSZW1vdGVMaW5lUGFyc2VyPFJlbW90ZU1lc3NhZ2VSZXN1bHQ8UHVzaFJlc3VsdFJlbW90ZU1lc3NhZ2VzIHwgUmVtb3RlTWVzc2FnZXM+PltdID1cbiAgIFtcbiAgICAgIG5ldyBSZW1vdGVMaW5lUGFyc2VyKC9ecmVtb3RlOlxccyooLispJC8sIChyZXN1bHQsIFt0ZXh0XSkgPT4ge1xuICAgICAgICAgcmVzdWx0LnJlbW90ZU1lc3NhZ2VzLmFsbC5wdXNoKHRleHQudHJpbSgpKTtcbiAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pLFxuICAgICAgLi4ucmVtb3RlTWVzc2FnZXNPYmplY3RQYXJzZXJzLFxuICAgICAgbmV3IFJlbW90ZUxpbmVQYXJzZXIoXG4gICAgICAgICBbL2NyZWF0ZSBhICg/OnB1bGx8bWVyZ2UpIHJlcXVlc3QvaSwgL1xccyhodHRwcz86XFwvXFwvXFxTKykkL10sXG4gICAgICAgICAocmVzdWx0LCBbcHVsbFJlcXVlc3RVcmxdKSA9PiB7XG4gICAgICAgICAgICAocmVzdWx0LnJlbW90ZU1lc3NhZ2VzIGFzIFB1c2hSZXN1bHRSZW1vdGVNZXNzYWdlcykucHVsbFJlcXVlc3RVcmwgPSBwdWxsUmVxdWVzdFVybDtcbiAgICAgICAgIH1cbiAgICAgICksXG4gICAgICBuZXcgUmVtb3RlTGluZVBhcnNlcihcbiAgICAgICAgIFsvZm91bmQgKFxcZCspIHZ1bG5lcmFiaWxpdGllcy4rXFwoKFteKV0rKVxcKS9pLCAvXFxzKGh0dHBzPzpcXC9cXC9cXFMrKSQvXSxcbiAgICAgICAgIChyZXN1bHQsIFtjb3VudCwgc3VtbWFyeSwgdXJsXSkgPT4ge1xuICAgICAgICAgICAgKHJlc3VsdC5yZW1vdGVNZXNzYWdlcyBhcyBQdXNoUmVzdWx0UmVtb3RlTWVzc2FnZXMpLnZ1bG5lcmFiaWxpdGllcyA9IHtcbiAgICAgICAgICAgICAgIGNvdW50OiBhc051bWJlcihjb3VudCksXG4gICAgICAgICAgICAgICBzdW1tYXJ5LFxuICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgIH1cbiAgICAgICksXG4gICBdO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VSZW1vdGVNZXNzYWdlczxUIGV4dGVuZHMgUmVtb3RlTWVzc2FnZXMgPSBSZW1vdGVNZXNzYWdlcz4oXG4gICBfc3RkT3V0OiBzdHJpbmcsXG4gICBzdGRFcnI6IHN0cmluZ1xuKTogUmVtb3RlTWVzc2FnZVJlc3VsdCB7XG4gICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZSh7IHJlbW90ZU1lc3NhZ2VzOiBuZXcgUmVtb3RlTWVzc2FnZVN1bW1hcnkoKSBhcyBUIH0sIHBhcnNlcnMsIHN0ZEVycik7XG59XG5cbmV4cG9ydCBjbGFzcyBSZW1vdGVNZXNzYWdlU3VtbWFyeSBpbXBsZW1lbnRzIFJlbW90ZU1lc3NhZ2VzIHtcbiAgIHB1YmxpYyByZWFkb25seSBhbGw6IHN0cmluZ1tdID0gW107XG59XG4iLCAiaW1wb3J0IHsgUHVsbERldGFpbCwgUHVsbEZhaWxlZFJlc3VsdCwgUHVsbFJlc3VsdCwgUmVtb3RlTWVzc2FnZXMgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IFB1bGxGYWlsZWRTdW1tYXJ5LCBQdWxsU3VtbWFyeSB9IGZyb20gJy4uL3Jlc3BvbnNlcy9QdWxsU3VtbWFyeSc7XG5pbXBvcnQgeyBUYXNrUGFyc2VyIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgYXBwZW5kLCBMaW5lUGFyc2VyLCBwYXJzZVN0cmluZ1Jlc3BvbnNlIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgcGFyc2VSZW1vdGVNZXNzYWdlcyB9IGZyb20gJy4vcGFyc2UtcmVtb3RlLW1lc3NhZ2VzJztcblxuY29uc3QgRklMRV9VUERBVEVfUkVHRVggPSAvXlxccyooLis/KVxccytcXHxcXHMrXFxkK1xccyooXFwrKikoLSopLztcbmNvbnN0IFNVTU1BUllfUkVHRVggPSAvKFxcZCspXFxEKygoXFxkKylcXEQrXFwoXFwrXFwpKT8oXFxEKyhcXGQrKVxcRCtcXCgtXFwpKT8vO1xuY29uc3QgQUNUSU9OX1JFR0VYID0gL14oY3JlYXRlfGRlbGV0ZSkgbW9kZSBcXGQrICguKykvO1xuXG5jb25zdCBwYXJzZXJzOiBMaW5lUGFyc2VyPFB1bGxSZXN1bHQ+W10gPSBbXG4gICBuZXcgTGluZVBhcnNlcihGSUxFX1VQREFURV9SRUdFWCwgKHJlc3VsdCwgW2ZpbGUsIGluc2VydGlvbnMsIGRlbGV0aW9uc10pID0+IHtcbiAgICAgIHJlc3VsdC5maWxlcy5wdXNoKGZpbGUpO1xuXG4gICAgICBpZiAoaW5zZXJ0aW9ucykge1xuICAgICAgICAgcmVzdWx0Lmluc2VydGlvbnNbZmlsZV0gPSBpbnNlcnRpb25zLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlbGV0aW9ucykge1xuICAgICAgICAgcmVzdWx0LmRlbGV0aW9uc1tmaWxlXSA9IGRlbGV0aW9ucy5sZW5ndGg7XG4gICAgICB9XG4gICB9KSxcbiAgIG5ldyBMaW5lUGFyc2VyKFNVTU1BUllfUkVHRVgsIChyZXN1bHQsIFtjaGFuZ2VzLCAsIGluc2VydGlvbnMsICwgZGVsZXRpb25zXSkgPT4ge1xuICAgICAgaWYgKGluc2VydGlvbnMgIT09IHVuZGVmaW5lZCB8fCBkZWxldGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgcmVzdWx0LnN1bW1hcnkuY2hhbmdlcyA9ICtjaGFuZ2VzIHx8IDA7XG4gICAgICAgICByZXN1bHQuc3VtbWFyeS5pbnNlcnRpb25zID0gK2luc2VydGlvbnMgfHwgMDtcbiAgICAgICAgIHJlc3VsdC5zdW1tYXJ5LmRlbGV0aW9ucyA9ICtkZWxldGlvbnMgfHwgMDtcbiAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgfSksXG4gICBuZXcgTGluZVBhcnNlcihBQ1RJT05fUkVHRVgsIChyZXN1bHQsIFthY3Rpb24sIGZpbGVdKSA9PiB7XG4gICAgICBhcHBlbmQocmVzdWx0LmZpbGVzLCBmaWxlKTtcbiAgICAgIGFwcGVuZChhY3Rpb24gPT09ICdjcmVhdGUnID8gcmVzdWx0LmNyZWF0ZWQgOiByZXN1bHQuZGVsZXRlZCwgZmlsZSk7XG4gICB9KSxcbl07XG5cbmNvbnN0IGVycm9yUGFyc2VyczogTGluZVBhcnNlcjxQdWxsRmFpbGVkUmVzdWx0PltdID0gW1xuICAgbmV3IExpbmVQYXJzZXIoL15mcm9tXFxzKC4rKSQvaSwgKHJlc3VsdCwgW3JlbW90ZV0pID0+IHZvaWQgKHJlc3VsdC5yZW1vdGUgPSByZW1vdGUpKSxcbiAgIG5ldyBMaW5lUGFyc2VyKC9eZmF0YWw6XFxzKC4rKSQvLCAocmVzdWx0LCBbbWVzc2FnZV0pID0+IHZvaWQgKHJlc3VsdC5tZXNzYWdlID0gbWVzc2FnZSkpLFxuICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAvKFthLXowLTldKylcXC5cXC4oW2EtejAtOV0rKVxccysoXFxTKylcXHMrLT5cXHMrKFxcUyspJC8sXG4gICAgICAocmVzdWx0LCBbaGFzaExvY2FsLCBoYXNoUmVtb3RlLCBicmFuY2hMb2NhbCwgYnJhbmNoUmVtb3RlXSkgPT4ge1xuICAgICAgICAgcmVzdWx0LmJyYW5jaC5sb2NhbCA9IGJyYW5jaExvY2FsO1xuICAgICAgICAgcmVzdWx0Lmhhc2gubG9jYWwgPSBoYXNoTG9jYWw7XG4gICAgICAgICByZXN1bHQuYnJhbmNoLnJlbW90ZSA9IGJyYW5jaFJlbW90ZTtcbiAgICAgICAgIHJlc3VsdC5oYXNoLnJlbW90ZSA9IGhhc2hSZW1vdGU7XG4gICAgICB9XG4gICApLFxuXTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlUHVsbERldGFpbDogVGFza1BhcnNlcjxzdHJpbmcsIFB1bGxEZXRhaWw+ID0gKHN0ZE91dCwgc3RkRXJyKSA9PiB7XG4gICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZShuZXcgUHVsbFN1bW1hcnkoKSwgcGFyc2VycywgW3N0ZE91dCwgc3RkRXJyXSk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VQdWxsUmVzdWx0OiBUYXNrUGFyc2VyPHN0cmluZywgUHVsbFJlc3VsdD4gPSAoc3RkT3V0LCBzdGRFcnIpID0+IHtcbiAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgbmV3IFB1bGxTdW1tYXJ5KCksXG4gICAgICBwYXJzZVB1bGxEZXRhaWwoc3RkT3V0LCBzdGRFcnIpLFxuICAgICAgcGFyc2VSZW1vdGVNZXNzYWdlczxSZW1vdGVNZXNzYWdlcz4oc3RkT3V0LCBzdGRFcnIpXG4gICApO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUHVsbEVycm9yUmVzdWx0KHN0ZE91dDogc3RyaW5nLCBzdGRFcnI6IHN0cmluZykge1xuICAgY29uc3QgcHVsbEVycm9yID0gcGFyc2VTdHJpbmdSZXNwb25zZShuZXcgUHVsbEZhaWxlZFN1bW1hcnkoKSwgZXJyb3JQYXJzZXJzLCBbc3RkT3V0LCBzdGRFcnJdKTtcblxuICAgcmV0dXJuIHB1bGxFcnJvci5tZXNzYWdlICYmIHB1bGxFcnJvcjtcbn1cbiIsICJpbXBvcnQgeyBNZXJnZURldGFpbCwgTWVyZ2VSZXN1bHQgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IE1lcmdlU3VtbWFyeUNvbmZsaWN0LCBNZXJnZVN1bW1hcnlEZXRhaWwgfSBmcm9tICcuLi9yZXNwb25zZXMvTWVyZ2VTdW1tYXJ5JztcbmltcG9ydCB7IFRhc2tQYXJzZXIgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBMaW5lUGFyc2VyLCBwYXJzZVN0cmluZ1Jlc3BvbnNlIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgcGFyc2VQdWxsUmVzdWx0IH0gZnJvbSAnLi9wYXJzZS1wdWxsJztcblxuY29uc3QgcGFyc2VyczogTGluZVBhcnNlcjxNZXJnZURldGFpbD5bXSA9IFtcbiAgIG5ldyBMaW5lUGFyc2VyKC9eQXV0by1tZXJnaW5nXFxzKyguKykkLywgKHN1bW1hcnksIFthdXRvTWVyZ2VdKSA9PiB7XG4gICAgICBzdW1tYXJ5Lm1lcmdlcy5wdXNoKGF1dG9NZXJnZSk7XG4gICB9KSxcbiAgIG5ldyBMaW5lUGFyc2VyKC9eQ09ORkxJQ1RcXHMrXFwoKC4rKVxcKTogTWVyZ2UgY29uZmxpY3QgaW4gKC4rKSQvLCAoc3VtbWFyeSwgW3JlYXNvbiwgZmlsZV0pID0+IHtcbiAgICAgIHN1bW1hcnkuY29uZmxpY3RzLnB1c2gobmV3IE1lcmdlU3VtbWFyeUNvbmZsaWN0KHJlYXNvbiwgZmlsZSkpO1xuICAgfSksXG4gICBuZXcgTGluZVBhcnNlcihcbiAgICAgIC9eQ09ORkxJQ1RcXHMrXFwoKC4rXFwvZGVsZXRlKVxcKTogKC4rKSBkZWxldGVkIGluICguKykgYW5kLyxcbiAgICAgIChzdW1tYXJ5LCBbcmVhc29uLCBmaWxlLCBkZWxldGVSZWZdKSA9PiB7XG4gICAgICAgICBzdW1tYXJ5LmNvbmZsaWN0cy5wdXNoKG5ldyBNZXJnZVN1bW1hcnlDb25mbGljdChyZWFzb24sIGZpbGUsIHsgZGVsZXRlUmVmIH0pKTtcbiAgICAgIH1cbiAgICksXG4gICBuZXcgTGluZVBhcnNlcigvXkNPTkZMSUNUXFxzK1xcKCguKylcXCk6LywgKHN1bW1hcnksIFtyZWFzb25dKSA9PiB7XG4gICAgICBzdW1tYXJ5LmNvbmZsaWN0cy5wdXNoKG5ldyBNZXJnZVN1bW1hcnlDb25mbGljdChyZWFzb24sIG51bGwpKTtcbiAgIH0pLFxuICAgbmV3IExpbmVQYXJzZXIoL15BdXRvbWF0aWMgbWVyZ2UgZmFpbGVkO1xccysoLispJC8sIChzdW1tYXJ5LCBbcmVzdWx0XSkgPT4ge1xuICAgICAgc3VtbWFyeS5yZXN1bHQgPSByZXN1bHQ7XG4gICB9KSxcbl07XG5cbi8qKlxuICogUGFyc2UgdGhlIGNvbXBsZXRlIHJlc3BvbnNlIGZyb20gYGdpdC5tZXJnZWBcbiAqL1xuZXhwb3J0IGNvbnN0IHBhcnNlTWVyZ2VSZXN1bHQ6IFRhc2tQYXJzZXI8c3RyaW5nLCBNZXJnZVJlc3VsdD4gPSAoc3RkT3V0LCBzdGRFcnIpID0+IHtcbiAgIHJldHVybiBPYmplY3QuYXNzaWduKHBhcnNlTWVyZ2VEZXRhaWwoc3RkT3V0LCBzdGRFcnIpLCBwYXJzZVB1bGxSZXN1bHQoc3RkT3V0LCBzdGRFcnIpKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIG1lcmdlIHNwZWNpZmljIGRldGFpbCAoaWU6IG5vdCB0aGUgY29udGVudCBhbHNvIGF2YWlsYWJsZSBpbiB0aGUgcHVsbCBkZXRhaWwpIGZyb20gYGdpdC5tbmVyZ2VgXG4gKiBAcGFyYW0gc3RkT3V0XG4gKi9cbmV4cG9ydCBjb25zdCBwYXJzZU1lcmdlRGV0YWlsOiBUYXNrUGFyc2VyPHN0cmluZywgTWVyZ2VEZXRhaWw+ID0gKHN0ZE91dCkgPT4ge1xuICAgcmV0dXJuIHBhcnNlU3RyaW5nUmVzcG9uc2UobmV3IE1lcmdlU3VtbWFyeURldGFpbCgpLCBwYXJzZXJzLCBzdGRPdXQpO1xufTtcbiIsICJpbXBvcnQgeyBNZXJnZVJlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgR2l0UmVzcG9uc2VFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9naXQtcmVzcG9uc2UtZXJyb3InO1xuaW1wb3J0IHsgcGFyc2VNZXJnZVJlc3VsdCB9IGZyb20gJy4uL3BhcnNlcnMvcGFyc2UtbWVyZ2UnO1xuaW1wb3J0IHsgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGNvbmZpZ3VyYXRpb25FcnJvclRhc2ssIEVtcHR5VGFzayB9IGZyb20gJy4vdGFzayc7XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZVRhc2soY3VzdG9tQXJnczogc3RyaW5nW10pOiBFbXB0eVRhc2sgfCBTdHJpbmdUYXNrPE1lcmdlUmVzdWx0PiB7XG4gICBpZiAoIWN1c3RvbUFyZ3MubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gY29uZmlndXJhdGlvbkVycm9yVGFzaygnR2l0Lm1lcmdlIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBvcHRpb24nKTtcbiAgIH1cblxuICAgcmV0dXJuIHtcbiAgICAgIGNvbW1hbmRzOiBbJ21lcmdlJywgLi4uY3VzdG9tQXJnc10sXG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBwYXJzZXIoc3RkT3V0LCBzdGRFcnIpOiBNZXJnZVJlc3VsdCB7XG4gICAgICAgICBjb25zdCBtZXJnZSA9IHBhcnNlTWVyZ2VSZXN1bHQoc3RkT3V0LCBzdGRFcnIpO1xuICAgICAgICAgaWYgKG1lcmdlLmZhaWxlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEdpdFJlc3BvbnNlRXJyb3IobWVyZ2UpO1xuICAgICAgICAgfVxuXG4gICAgICAgICByZXR1cm4gbWVyZ2U7XG4gICAgICB9LFxuICAgfTtcbn1cbiIsICJpbXBvcnQge1xuICAgUHVzaERldGFpbCxcbiAgIFB1c2hSZXN1bHQsXG4gICBQdXNoUmVzdWx0UHVzaGVkSXRlbSxcbiAgIFB1c2hSZXN1bHRSZW1vdGVNZXNzYWdlcyxcbn0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBUYXNrUGFyc2VyIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgTGluZVBhcnNlciwgcGFyc2VTdHJpbmdSZXNwb25zZSB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IHBhcnNlUmVtb3RlTWVzc2FnZXMgfSBmcm9tICcuL3BhcnNlLXJlbW90ZS1tZXNzYWdlcyc7XG5cbmZ1bmN0aW9uIHB1c2hSZXN1bHRQdXNoZWRJdGVtKGxvY2FsOiBzdHJpbmcsIHJlbW90ZTogc3RyaW5nLCBzdGF0dXM6IHN0cmluZyk6IFB1c2hSZXN1bHRQdXNoZWRJdGVtIHtcbiAgIGNvbnN0IGRlbGV0ZWQgPSBzdGF0dXMuaW5jbHVkZXMoJ2RlbGV0ZWQnKTtcbiAgIGNvbnN0IHRhZyA9IHN0YXR1cy5pbmNsdWRlcygndGFnJykgfHwgL15yZWZzXFwvdGFncy8udGVzdChsb2NhbCk7XG4gICBjb25zdCBhbHJlYWR5VXBkYXRlZCA9ICFzdGF0dXMuaW5jbHVkZXMoJ25ldycpO1xuXG4gICByZXR1cm4ge1xuICAgICAgZGVsZXRlZCxcbiAgICAgIHRhZyxcbiAgICAgIGJyYW5jaDogIXRhZyxcbiAgICAgIG5ldzogIWFscmVhZHlVcGRhdGVkLFxuICAgICAgYWxyZWFkeVVwZGF0ZWQsXG4gICAgICBsb2NhbCxcbiAgICAgIHJlbW90ZSxcbiAgIH07XG59XG5cbmNvbnN0IHBhcnNlcnM6IExpbmVQYXJzZXI8UHVzaERldGFpbD5bXSA9IFtcbiAgIG5ldyBMaW5lUGFyc2VyKC9eUHVzaGluZyB0byAoLispJC8sIChyZXN1bHQsIFtyZXBvXSkgPT4ge1xuICAgICAgcmVzdWx0LnJlcG8gPSByZXBvO1xuICAgfSksXG4gICBuZXcgTGluZVBhcnNlcigvXnVwZGF0aW5nIGxvY2FsIHRyYWNraW5nIHJlZiAnKC4rKScvLCAocmVzdWx0LCBbbG9jYWxdKSA9PiB7XG4gICAgICByZXN1bHQucmVmID0ge1xuICAgICAgICAgLi4uKHJlc3VsdC5yZWYgfHwge30pLFxuICAgICAgICAgbG9jYWwsXG4gICAgICB9O1xuICAgfSksXG4gICBuZXcgTGluZVBhcnNlcigvXls9Ki1dXFxzKyhbXjpdKyk6KFxcUyspXFxzK1xcWyguKyldJC8sIChyZXN1bHQsIFtsb2NhbCwgcmVtb3RlLCB0eXBlXSkgPT4ge1xuICAgICAgcmVzdWx0LnB1c2hlZC5wdXNoKHB1c2hSZXN1bHRQdXNoZWRJdGVtKGxvY2FsLCByZW1vdGUsIHR5cGUpKTtcbiAgIH0pLFxuICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAvXkJyYW5jaCAnKFteJ10rKScgc2V0IHVwIHRvIHRyYWNrIHJlbW90ZSBicmFuY2ggJyhbXiddKyknIGZyb20gJyhbXiddKyknLyxcbiAgICAgIChyZXN1bHQsIFtsb2NhbCwgcmVtb3RlLCByZW1vdGVOYW1lXSkgPT4ge1xuICAgICAgICAgcmVzdWx0LmJyYW5jaCA9IHtcbiAgICAgICAgICAgIC4uLihyZXN1bHQuYnJhbmNoIHx8IHt9KSxcbiAgICAgICAgICAgIGxvY2FsLFxuICAgICAgICAgICAgcmVtb3RlLFxuICAgICAgICAgICAgcmVtb3RlTmFtZSxcbiAgICAgICAgIH07XG4gICAgICB9XG4gICApLFxuICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAvXihbXjpdKyk6KFxcUyspXFxzKyhbYS16MC05XSspXFwuXFwuKFthLXowLTldKykkLyxcbiAgICAgIChyZXN1bHQsIFtsb2NhbCwgcmVtb3RlLCBmcm9tLCB0b10pID0+IHtcbiAgICAgICAgIHJlc3VsdC51cGRhdGUgPSB7XG4gICAgICAgICAgICBoZWFkOiB7XG4gICAgICAgICAgICAgICBsb2NhbCxcbiAgICAgICAgICAgICAgIHJlbW90ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYXNoOiB7XG4gICAgICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgfTtcbiAgICAgIH1cbiAgICksXG5dO1xuXG5leHBvcnQgY29uc3QgcGFyc2VQdXNoUmVzdWx0OiBUYXNrUGFyc2VyPHN0cmluZywgUHVzaFJlc3VsdD4gPSAoc3RkT3V0LCBzdGRFcnIpID0+IHtcbiAgIGNvbnN0IHB1c2hEZXRhaWwgPSBwYXJzZVB1c2hEZXRhaWwoc3RkT3V0LCBzdGRFcnIpO1xuICAgY29uc3QgcmVzcG9uc2VEZXRhaWwgPSBwYXJzZVJlbW90ZU1lc3NhZ2VzPFB1c2hSZXN1bHRSZW1vdGVNZXNzYWdlcz4oc3RkT3V0LCBzdGRFcnIpO1xuXG4gICByZXR1cm4ge1xuICAgICAgLi4ucHVzaERldGFpbCxcbiAgICAgIC4uLnJlc3BvbnNlRGV0YWlsLFxuICAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZVB1c2hEZXRhaWw6IFRhc2tQYXJzZXI8c3RyaW5nLCBQdXNoRGV0YWlsPiA9IChzdGRPdXQsIHN0ZEVycikgPT4ge1xuICAgcmV0dXJuIHBhcnNlU3RyaW5nUmVzcG9uc2UoeyBwdXNoZWQ6IFtdIH0sIHBhcnNlcnMsIFtzdGRPdXQsIHN0ZEVycl0pO1xufTtcbiIsICJpbXBvcnQgeyBQdXNoUmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBwYXJzZVB1c2hSZXN1bHQgYXMgcGFyc2VyIH0gZnJvbSAnLi4vcGFyc2Vycy9wYXJzZS1wdXNoJztcbmltcG9ydCB7IFN0cmluZ1Rhc2sgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBhcHBlbmQsIHJlbW92ZSB9IGZyb20gJy4uL3V0aWxzJztcblxudHlwZSBQdXNoUmVmID0geyByZW1vdGU/OiBzdHJpbmc7IGJyYW5jaD86IHN0cmluZyB9O1xuXG5leHBvcnQgZnVuY3Rpb24gcHVzaFRhZ3NUYXNrKHJlZjogUHVzaFJlZiA9IHt9LCBjdXN0b21BcmdzOiBzdHJpbmdbXSk6IFN0cmluZ1Rhc2s8UHVzaFJlc3VsdD4ge1xuICAgYXBwZW5kKGN1c3RvbUFyZ3MsICctLXRhZ3MnKTtcbiAgIHJldHVybiBwdXNoVGFzayhyZWYsIGN1c3RvbUFyZ3MpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHVzaFRhc2socmVmOiBQdXNoUmVmID0ge30sIGN1c3RvbUFyZ3M6IHN0cmluZ1tdKTogU3RyaW5nVGFzazxQdXNoUmVzdWx0PiB7XG4gICBjb25zdCBjb21tYW5kcyA9IFsncHVzaCcsIC4uLmN1c3RvbUFyZ3NdO1xuICAgaWYgKHJlZi5icmFuY2gpIHtcbiAgICAgIGNvbW1hbmRzLnNwbGljZSgxLCAwLCByZWYuYnJhbmNoKTtcbiAgIH1cbiAgIGlmIChyZWYucmVtb3RlKSB7XG4gICAgICBjb21tYW5kcy5zcGxpY2UoMSwgMCwgcmVmLnJlbW90ZSk7XG4gICB9XG5cbiAgIHJlbW92ZShjb21tYW5kcywgJy12Jyk7XG4gICBhcHBlbmQoY29tbWFuZHMsICctLXZlcmJvc2UnKTtcbiAgIGFwcGVuZChjb21tYW5kcywgJy0tcG9yY2VsYWluJyk7XG5cbiAgIHJldHVybiB7XG4gICAgICBjb21tYW5kcyxcbiAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgIHBhcnNlcixcbiAgIH07XG59XG4iLCAiaW1wb3J0IHsgU2ltcGxlR2l0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBTaW1wbGVHaXRBcGkgfSBmcm9tICcuLi9zaW1wbGUtZ2l0LWFwaSc7XG5pbXBvcnQgeyBnZXRUcmFpbGluZ09wdGlvbnMsIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IHN0cmFpZ2h0VGhyb3VnaEJ1ZmZlclRhc2ssIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2sgfSBmcm9tICcuL3Rhc2snO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKTogUGljazxTaW1wbGVHaXQsICdzaG93QnVmZmVyJyB8ICdzaG93Jz4ge1xuICAgcmV0dXJuIHtcbiAgICAgIHNob3dCdWZmZXIodGhpczogU2ltcGxlR2l0QXBpKSB7XG4gICAgICAgICBjb25zdCBjb21tYW5kcyA9IFsnc2hvdycsIC4uLmdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMsIDEpXTtcbiAgICAgICAgIGlmICghY29tbWFuZHMuaW5jbHVkZXMoJy0tYmluYXJ5JykpIHtcbiAgICAgICAgICAgIGNvbW1hbmRzLnNwbGljZSgxLCAwLCAnLS1iaW5hcnknKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgICBzdHJhaWdodFRocm91Z2hCdWZmZXJUYXNrKGNvbW1hbmRzKSxcbiAgICAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICAgICApO1xuICAgICAgfSxcblxuICAgICAgc2hvdyh0aGlzOiBTaW1wbGVHaXRBcGkpIHtcbiAgICAgICAgIGNvbnN0IGNvbW1hbmRzID0gWydzaG93JywgLi4uZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cywgMSldO1xuICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgICBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKGNvbW1hbmRzKSxcbiAgICAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICAgICApO1xuICAgICAgfSxcbiAgIH07XG59XG4iLCAiaW1wb3J0IHsgRmlsZVN0YXR1c1Jlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuXG5leHBvcnQgY29uc3QgZnJvbVBhdGhSZWdleCA9IC9eKC4rKSAtPiAoLispJC87XG5cbmV4cG9ydCBjbGFzcyBGaWxlU3RhdHVzU3VtbWFyeSBpbXBsZW1lbnRzIEZpbGVTdGF0dXNSZXN1bHQge1xuICAgcHVibGljIHJlYWRvbmx5IGZyb206IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICAgY29uc3RydWN0b3IoXG4gICAgICBwdWJsaWMgcGF0aDogc3RyaW5nLFxuICAgICAgcHVibGljIGluZGV4OiBzdHJpbmcsXG4gICAgICBwdWJsaWMgd29ya2luZ19kaXI6IHN0cmluZ1xuICAgKSB7XG4gICAgICBpZiAoJ1InID09PSBpbmRleCArIHdvcmtpbmdfZGlyKSB7XG4gICAgICAgICBjb25zdCBkZXRhaWwgPSBmcm9tUGF0aFJlZ2V4LmV4ZWMocGF0aCkgfHwgW251bGwsIHBhdGgsIHBhdGhdO1xuICAgICAgICAgdGhpcy5mcm9tID0gZGV0YWlsWzFdIHx8ICcnO1xuICAgICAgICAgdGhpcy5wYXRoID0gZGV0YWlsWzJdIHx8ICcnO1xuICAgICAgfVxuICAgfVxufVxuIiwgImltcG9ydCB7IFN0YXR1c1Jlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgYXBwZW5kLCBOVUxMIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgRmlsZVN0YXR1c1N1bW1hcnkgfSBmcm9tICcuL0ZpbGVTdGF0dXNTdW1tYXJ5JztcblxudHlwZSBTdGF0dXNMaW5lUGFyc2VyID0gKHJlc3VsdDogU3RhdHVzUmVzdWx0LCBmaWxlOiBzdHJpbmcpID0+IHZvaWQ7XG5cbmV4cG9ydCBjbGFzcyBTdGF0dXNTdW1tYXJ5IGltcGxlbWVudHMgU3RhdHVzUmVzdWx0IHtcbiAgIHB1YmxpYyBub3RfYWRkZWQgPSBbXTtcbiAgIHB1YmxpYyBjb25mbGljdGVkID0gW107XG4gICBwdWJsaWMgY3JlYXRlZCA9IFtdO1xuICAgcHVibGljIGRlbGV0ZWQgPSBbXTtcbiAgIHB1YmxpYyBpZ25vcmVkID0gdW5kZWZpbmVkO1xuICAgcHVibGljIG1vZGlmaWVkID0gW107XG4gICBwdWJsaWMgcmVuYW1lZCA9IFtdO1xuICAgcHVibGljIGZpbGVzID0gW107XG4gICBwdWJsaWMgc3RhZ2VkID0gW107XG4gICBwdWJsaWMgYWhlYWQgPSAwO1xuICAgcHVibGljIGJlaGluZCA9IDA7XG4gICBwdWJsaWMgY3VycmVudCA9IG51bGw7XG4gICBwdWJsaWMgdHJhY2tpbmcgPSBudWxsO1xuICAgcHVibGljIGRldGFjaGVkID0gZmFsc2U7XG5cbiAgIHB1YmxpYyBpc0NsZWFuID0gKCkgPT4ge1xuICAgICAgcmV0dXJuICF0aGlzLmZpbGVzLmxlbmd0aDtcbiAgIH07XG59XG5cbmVudW0gUG9yY2VsYWluRmlsZVN0YXR1cyB7XG4gICBBRERFRCA9ICdBJyxcbiAgIERFTEVURUQgPSAnRCcsXG4gICBNT0RJRklFRCA9ICdNJyxcbiAgIFJFTkFNRUQgPSAnUicsXG4gICBDT1BJRUQgPSAnQycsXG4gICBVTk1FUkdFRCA9ICdVJyxcbiAgIFVOVFJBQ0tFRCA9ICc/JyxcbiAgIElHTk9SRUQgPSAnIScsXG4gICBOT05FID0gJyAnLFxufVxuXG5mdW5jdGlvbiByZW5hbWVkRmlsZShsaW5lOiBzdHJpbmcpIHtcbiAgIGNvbnN0IFt0bywgZnJvbV0gPSBsaW5lLnNwbGl0KE5VTEwpO1xuXG4gICByZXR1cm4ge1xuICAgICAgZnJvbTogZnJvbSB8fCB0byxcbiAgICAgIHRvLFxuICAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VyKFxuICAgaW5kZXhYOiBQb3JjZWxhaW5GaWxlU3RhdHVzLFxuICAgaW5kZXhZOiBQb3JjZWxhaW5GaWxlU3RhdHVzLFxuICAgaGFuZGxlcjogU3RhdHVzTGluZVBhcnNlclxuKTogW3N0cmluZywgU3RhdHVzTGluZVBhcnNlcl0ge1xuICAgcmV0dXJuIFtgJHtpbmRleFh9JHtpbmRleFl9YCwgaGFuZGxlcl07XG59XG5cbmZ1bmN0aW9uIGNvbmZsaWN0cyhpbmRleFg6IFBvcmNlbGFpbkZpbGVTdGF0dXMsIC4uLmluZGV4WTogUG9yY2VsYWluRmlsZVN0YXR1c1tdKSB7XG4gICByZXR1cm4gaW5kZXhZLm1hcCgoeSkgPT4gcGFyc2VyKGluZGV4WCwgeSwgKHJlc3VsdCwgZmlsZSkgPT4gYXBwZW5kKHJlc3VsdC5jb25mbGljdGVkLCBmaWxlKSkpO1xufVxuXG5jb25zdCBwYXJzZXJzOiBNYXA8c3RyaW5nLCBTdGF0dXNMaW5lUGFyc2VyPiA9IG5ldyBNYXAoW1xuICAgcGFyc2VyKFBvcmNlbGFpbkZpbGVTdGF0dXMuTk9ORSwgUG9yY2VsYWluRmlsZVN0YXR1cy5BRERFRCwgKHJlc3VsdCwgZmlsZSkgPT5cbiAgICAgIGFwcGVuZChyZXN1bHQuY3JlYXRlZCwgZmlsZSlcbiAgICksXG4gICBwYXJzZXIoUG9yY2VsYWluRmlsZVN0YXR1cy5OT05FLCBQb3JjZWxhaW5GaWxlU3RhdHVzLkRFTEVURUQsIChyZXN1bHQsIGZpbGUpID0+XG4gICAgICBhcHBlbmQocmVzdWx0LmRlbGV0ZWQsIGZpbGUpXG4gICApLFxuICAgcGFyc2VyKFBvcmNlbGFpbkZpbGVTdGF0dXMuTk9ORSwgUG9yY2VsYWluRmlsZVN0YXR1cy5NT0RJRklFRCwgKHJlc3VsdCwgZmlsZSkgPT5cbiAgICAgIGFwcGVuZChyZXN1bHQubW9kaWZpZWQsIGZpbGUpXG4gICApLFxuXG4gICBwYXJzZXIoXG4gICAgICBQb3JjZWxhaW5GaWxlU3RhdHVzLkFEREVELFxuICAgICAgUG9yY2VsYWluRmlsZVN0YXR1cy5OT05FLFxuICAgICAgKHJlc3VsdCwgZmlsZSkgPT4gYXBwZW5kKHJlc3VsdC5jcmVhdGVkLCBmaWxlKSAmJiBhcHBlbmQocmVzdWx0LnN0YWdlZCwgZmlsZSlcbiAgICksXG4gICBwYXJzZXIoXG4gICAgICBQb3JjZWxhaW5GaWxlU3RhdHVzLkFEREVELFxuICAgICAgUG9yY2VsYWluRmlsZVN0YXR1cy5NT0RJRklFRCxcbiAgICAgIChyZXN1bHQsIGZpbGUpID0+XG4gICAgICAgICBhcHBlbmQocmVzdWx0LmNyZWF0ZWQsIGZpbGUpICYmXG4gICAgICAgICBhcHBlbmQocmVzdWx0LnN0YWdlZCwgZmlsZSkgJiZcbiAgICAgICAgIGFwcGVuZChyZXN1bHQubW9kaWZpZWQsIGZpbGUpXG4gICApLFxuXG4gICBwYXJzZXIoXG4gICAgICBQb3JjZWxhaW5GaWxlU3RhdHVzLkRFTEVURUQsXG4gICAgICBQb3JjZWxhaW5GaWxlU3RhdHVzLk5PTkUsXG4gICAgICAocmVzdWx0LCBmaWxlKSA9PiBhcHBlbmQocmVzdWx0LmRlbGV0ZWQsIGZpbGUpICYmIGFwcGVuZChyZXN1bHQuc3RhZ2VkLCBmaWxlKVxuICAgKSxcblxuICAgcGFyc2VyKFxuICAgICAgUG9yY2VsYWluRmlsZVN0YXR1cy5NT0RJRklFRCxcbiAgICAgIFBvcmNlbGFpbkZpbGVTdGF0dXMuTk9ORSxcbiAgICAgIChyZXN1bHQsIGZpbGUpID0+IGFwcGVuZChyZXN1bHQubW9kaWZpZWQsIGZpbGUpICYmIGFwcGVuZChyZXN1bHQuc3RhZ2VkLCBmaWxlKVxuICAgKSxcbiAgIHBhcnNlcihcbiAgICAgIFBvcmNlbGFpbkZpbGVTdGF0dXMuTU9ESUZJRUQsXG4gICAgICBQb3JjZWxhaW5GaWxlU3RhdHVzLk1PRElGSUVELFxuICAgICAgKHJlc3VsdCwgZmlsZSkgPT4gYXBwZW5kKHJlc3VsdC5tb2RpZmllZCwgZmlsZSkgJiYgYXBwZW5kKHJlc3VsdC5zdGFnZWQsIGZpbGUpXG4gICApLFxuXG4gICBwYXJzZXIoUG9yY2VsYWluRmlsZVN0YXR1cy5SRU5BTUVELCBQb3JjZWxhaW5GaWxlU3RhdHVzLk5PTkUsIChyZXN1bHQsIGZpbGUpID0+IHtcbiAgICAgIGFwcGVuZChyZXN1bHQucmVuYW1lZCwgcmVuYW1lZEZpbGUoZmlsZSkpO1xuICAgfSksXG4gICBwYXJzZXIoUG9yY2VsYWluRmlsZVN0YXR1cy5SRU5BTUVELCBQb3JjZWxhaW5GaWxlU3RhdHVzLk1PRElGSUVELCAocmVzdWx0LCBmaWxlKSA9PiB7XG4gICAgICBjb25zdCByZW5hbWVkID0gcmVuYW1lZEZpbGUoZmlsZSk7XG4gICAgICBhcHBlbmQocmVzdWx0LnJlbmFtZWQsIHJlbmFtZWQpO1xuICAgICAgYXBwZW5kKHJlc3VsdC5tb2RpZmllZCwgcmVuYW1lZC50byk7XG4gICB9KSxcbiAgIHBhcnNlcihQb3JjZWxhaW5GaWxlU3RhdHVzLklHTk9SRUQsIFBvcmNlbGFpbkZpbGVTdGF0dXMuSUdOT1JFRCwgKF9yZXN1bHQsIF9maWxlKSA9PiB7XG4gICAgICBhcHBlbmQoKF9yZXN1bHQuaWdub3JlZCA9IF9yZXN1bHQuaWdub3JlZCB8fCBbXSksIF9maWxlKTtcbiAgIH0pLFxuXG4gICBwYXJzZXIoUG9yY2VsYWluRmlsZVN0YXR1cy5VTlRSQUNLRUQsIFBvcmNlbGFpbkZpbGVTdGF0dXMuVU5UUkFDS0VELCAocmVzdWx0LCBmaWxlKSA9PlxuICAgICAgYXBwZW5kKHJlc3VsdC5ub3RfYWRkZWQsIGZpbGUpXG4gICApLFxuXG4gICAuLi5jb25mbGljdHMoUG9yY2VsYWluRmlsZVN0YXR1cy5BRERFRCwgUG9yY2VsYWluRmlsZVN0YXR1cy5BRERFRCwgUG9yY2VsYWluRmlsZVN0YXR1cy5VTk1FUkdFRCksXG4gICAuLi5jb25mbGljdHMoXG4gICAgICBQb3JjZWxhaW5GaWxlU3RhdHVzLkRFTEVURUQsXG4gICAgICBQb3JjZWxhaW5GaWxlU3RhdHVzLkRFTEVURUQsXG4gICAgICBQb3JjZWxhaW5GaWxlU3RhdHVzLlVOTUVSR0VEXG4gICApLFxuICAgLi4uY29uZmxpY3RzKFxuICAgICAgUG9yY2VsYWluRmlsZVN0YXR1cy5VTk1FUkdFRCxcbiAgICAgIFBvcmNlbGFpbkZpbGVTdGF0dXMuQURERUQsXG4gICAgICBQb3JjZWxhaW5GaWxlU3RhdHVzLkRFTEVURUQsXG4gICAgICBQb3JjZWxhaW5GaWxlU3RhdHVzLlVOTUVSR0VEXG4gICApLFxuXG4gICBbXG4gICAgICAnIyMnLFxuICAgICAgKHJlc3VsdCwgbGluZSkgPT4ge1xuICAgICAgICAgY29uc3QgYWhlYWRSZWcgPSAvYWhlYWQgKFxcZCspLztcbiAgICAgICAgIGNvbnN0IGJlaGluZFJlZyA9IC9iZWhpbmQgKFxcZCspLztcbiAgICAgICAgIGNvbnN0IGN1cnJlbnRSZWcgPSAvXiguKz8oPz0oPzpcXC57M318XFxzfCQpKSkvO1xuICAgICAgICAgY29uc3QgdHJhY2tpbmdSZWcgPSAvXFwuezN9KFxcUyopLztcbiAgICAgICAgIGNvbnN0IG9uRW1wdHlCcmFuY2hSZWcgPSAvXFxzb25cXHMoW1xcU10rKSQvO1xuICAgICAgICAgbGV0IHJlZ2V4UmVzdWx0O1xuXG4gICAgICAgICByZWdleFJlc3VsdCA9IGFoZWFkUmVnLmV4ZWMobGluZSk7XG4gICAgICAgICByZXN1bHQuYWhlYWQgPSAocmVnZXhSZXN1bHQgJiYgK3JlZ2V4UmVzdWx0WzFdKSB8fCAwO1xuXG4gICAgICAgICByZWdleFJlc3VsdCA9IGJlaGluZFJlZy5leGVjKGxpbmUpO1xuICAgICAgICAgcmVzdWx0LmJlaGluZCA9IChyZWdleFJlc3VsdCAmJiArcmVnZXhSZXN1bHRbMV0pIHx8IDA7XG5cbiAgICAgICAgIHJlZ2V4UmVzdWx0ID0gY3VycmVudFJlZy5leGVjKGxpbmUpO1xuICAgICAgICAgcmVzdWx0LmN1cnJlbnQgPSByZWdleFJlc3VsdCAmJiByZWdleFJlc3VsdFsxXTtcblxuICAgICAgICAgcmVnZXhSZXN1bHQgPSB0cmFja2luZ1JlZy5leGVjKGxpbmUpO1xuICAgICAgICAgcmVzdWx0LnRyYWNraW5nID0gcmVnZXhSZXN1bHQgJiYgcmVnZXhSZXN1bHRbMV07XG5cbiAgICAgICAgIHJlZ2V4UmVzdWx0ID0gb25FbXB0eUJyYW5jaFJlZy5leGVjKGxpbmUpO1xuICAgICAgICAgcmVzdWx0LmN1cnJlbnQgPSAocmVnZXhSZXN1bHQgJiYgcmVnZXhSZXN1bHRbMV0pIHx8IHJlc3VsdC5jdXJyZW50O1xuXG4gICAgICAgICByZXN1bHQuZGV0YWNoZWQgPSAvXFwobm8gYnJhbmNoXFwpLy50ZXN0KGxpbmUpO1xuICAgICAgfSxcbiAgIF0sXG5dKTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlU3RhdHVzU3VtbWFyeSA9IGZ1bmN0aW9uICh0ZXh0OiBzdHJpbmcpOiBTdGF0dXNSZXN1bHQge1xuICAgY29uc3QgbGluZXMgPSB0ZXh0LnNwbGl0KE5VTEwpO1xuICAgY29uc3Qgc3RhdHVzID0gbmV3IFN0YXR1c1N1bW1hcnkoKTtcblxuICAgZm9yIChsZXQgaSA9IDAsIGwgPSBsaW5lcy5sZW5ndGg7IGkgPCBsOyApIHtcbiAgICAgIGxldCBsaW5lID0gbGluZXNbaSsrXS50cmltKCk7XG5cbiAgICAgIGlmICghbGluZSkge1xuICAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChsaW5lLmNoYXJBdCgwKSA9PT0gUG9yY2VsYWluRmlsZVN0YXR1cy5SRU5BTUVEKSB7XG4gICAgICAgICBsaW5lICs9IE5VTEwgKyAobGluZXNbaSsrXSB8fCAnJyk7XG4gICAgICB9XG5cbiAgICAgIHNwbGl0TGluZShzdGF0dXMsIGxpbmUpO1xuICAgfVxuXG4gICByZXR1cm4gc3RhdHVzO1xufTtcblxuZnVuY3Rpb24gc3BsaXRMaW5lKHJlc3VsdDogU3RhdHVzUmVzdWx0LCBsaW5lU3RyOiBzdHJpbmcpIHtcbiAgIGNvbnN0IHRyaW1tZWQgPSBsaW5lU3RyLnRyaW0oKTtcbiAgIHN3aXRjaCAoJyAnKSB7XG4gICAgICBjYXNlIHRyaW1tZWQuY2hhckF0KDIpOlxuICAgICAgICAgcmV0dXJuIGRhdGEodHJpbW1lZC5jaGFyQXQoMCksIHRyaW1tZWQuY2hhckF0KDEpLCB0cmltbWVkLnN1YnN0cigzKSk7XG4gICAgICBjYXNlIHRyaW1tZWQuY2hhckF0KDEpOlxuICAgICAgICAgcmV0dXJuIGRhdGEoUG9yY2VsYWluRmlsZVN0YXR1cy5OT05FLCB0cmltbWVkLmNoYXJBdCgwKSwgdHJpbW1lZC5zdWJzdHIoMikpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgIHJldHVybjtcbiAgIH1cblxuICAgZnVuY3Rpb24gZGF0YShpbmRleDogc3RyaW5nLCB3b3JraW5nRGlyOiBzdHJpbmcsIHBhdGg6IHN0cmluZykge1xuICAgICAgY29uc3QgcmF3ID0gYCR7aW5kZXh9JHt3b3JraW5nRGlyfWA7XG4gICAgICBjb25zdCBoYW5kbGVyID0gcGFyc2Vycy5nZXQocmF3KTtcblxuICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgIGhhbmRsZXIocmVzdWx0LCBwYXRoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJhdyAhPT0gJyMjJyAmJiByYXcgIT09ICchIScpIHtcbiAgICAgICAgIHJlc3VsdC5maWxlcy5wdXNoKG5ldyBGaWxlU3RhdHVzU3VtbWFyeShwYXRoLnJlcGxhY2UoL1xcMC4rJC8sICcnKSwgaW5kZXgsIHdvcmtpbmdEaXIpKTtcbiAgICAgIH1cbiAgIH1cbn1cbiIsICJpbXBvcnQgeyBTdGF0dXNSZXN1bHQgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IHBhcnNlU3RhdHVzU3VtbWFyeSB9IGZyb20gJy4uL3Jlc3BvbnNlcy9TdGF0dXNTdW1tYXJ5JztcbmltcG9ydCB7IFN0cmluZ1Rhc2sgfSBmcm9tICcuLi90eXBlcyc7XG5cbmNvbnN0IGlnbm9yZWRPcHRpb25zID0gWyctLW51bGwnLCAnLXonXTtcblxuZXhwb3J0IGZ1bmN0aW9uIHN0YXR1c1Rhc2soY3VzdG9tQXJnczogc3RyaW5nW10pOiBTdHJpbmdUYXNrPFN0YXR1c1Jlc3VsdD4ge1xuICAgY29uc3QgY29tbWFuZHMgPSBbXG4gICAgICAnc3RhdHVzJyxcbiAgICAgICctLXBvcmNlbGFpbicsXG4gICAgICAnLWInLFxuICAgICAgJy11JyxcbiAgICAgICctLW51bGwnLFxuICAgICAgLi4uY3VzdG9tQXJncy5maWx0ZXIoKGFyZykgPT4gIWlnbm9yZWRPcHRpb25zLmluY2x1ZGVzKGFyZykpLFxuICAgXTtcblxuICAgcmV0dXJuIHtcbiAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgIGNvbW1hbmRzLFxuICAgICAgcGFyc2VyKHRleHQ6IHN0cmluZykge1xuICAgICAgICAgcmV0dXJuIHBhcnNlU3RhdHVzU3VtbWFyeSh0ZXh0KTtcbiAgICAgIH0sXG4gICB9O1xufVxuIiwgImltcG9ydCB0eXBlIHsgU2ltcGxlR2l0QXBpIH0gZnJvbSAnLi4vc2ltcGxlLWdpdC1hcGknO1xuaW1wb3J0IHR5cGUgeyBTaW1wbGVHaXQgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IGFzTnVtYmVyLCBFeGl0Q29kZXMsIExpbmVQYXJzZXIsIHBhcnNlU3RyaW5nUmVzcG9uc2UgfSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmVyc2lvblJlc3VsdCB7XG4gICBtYWpvcjogbnVtYmVyO1xuICAgbWlub3I6IG51bWJlcjtcbiAgIHBhdGNoOiBudW1iZXIgfCBzdHJpbmc7XG4gICBhZ2VudDogc3RyaW5nO1xuICAgaW5zdGFsbGVkOiBib29sZWFuO1xufVxuXG5jb25zdCBOT1RfSU5TVEFMTEVEID0gJ2luc3RhbGxlZD1mYWxzZSc7XG5cbmZ1bmN0aW9uIHZlcnNpb25SZXNwb25zZShcbiAgIG1ham9yID0gMCxcbiAgIG1pbm9yID0gMCxcbiAgIHBhdGNoOiBzdHJpbmcgfCBudW1iZXIgPSAwLFxuICAgYWdlbnQgPSAnJyxcbiAgIGluc3RhbGxlZCA9IHRydWVcbik6IFZlcnNpb25SZXN1bHQge1xuICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgIHtcbiAgICAgICAgIG1ham9yLFxuICAgICAgICAgbWlub3IsXG4gICAgICAgICBwYXRjaCxcbiAgICAgICAgIGFnZW50LFxuICAgICAgICAgaW5zdGFsbGVkLFxuICAgICAgfSxcbiAgICAgICd0b1N0cmluZycsXG4gICAgICB7XG4gICAgICAgICB2YWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLm1ham9yfS4ke3RoaXMubWlub3J9LiR7dGhpcy5wYXRjaH1gO1xuICAgICAgICAgfSxcbiAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIH1cbiAgICk7XG59XG5cbmZ1bmN0aW9uIG5vdEluc3RhbGxlZFJlc3BvbnNlKCkge1xuICAgcmV0dXJuIHZlcnNpb25SZXNwb25zZSgwLCAwLCAwLCAnJywgZmFsc2UpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKTogUGljazxTaW1wbGVHaXQsICd2ZXJzaW9uJz4ge1xuICAgcmV0dXJuIHtcbiAgICAgIHZlcnNpb24odGhpczogU2ltcGxlR2l0QXBpKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayh7XG4gICAgICAgICAgICBjb21tYW5kczogWyctLXZlcnNpb24nXSxcbiAgICAgICAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgICAgICAgIHBhcnNlcjogdmVyc2lvblBhcnNlcixcbiAgICAgICAgICAgIG9uRXJyb3IocmVzdWx0LCBlcnJvciwgZG9uZSwgZmFpbCkge1xuICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5leGl0Q29kZSA9PT0gRXhpdENvZGVzLk5PVF9GT1VORCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvbmUoQnVmZmVyLmZyb20oTk9UX0lOU1RBTExFRCkpO1xuICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICBmYWlsKGVycm9yKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICB9KTtcbiAgICAgIH0sXG4gICB9O1xufVxuXG5jb25zdCBwYXJzZXJzOiBMaW5lUGFyc2VyPFZlcnNpb25SZXN1bHQ+W10gPSBbXG4gICBuZXcgTGluZVBhcnNlcihcbiAgICAgIC92ZXJzaW9uIChcXGQrKVxcLihcXGQrKVxcLihcXGQrKSg/OlxccypcXCgoLispXFwpKT8vLFxuICAgICAgKHJlc3VsdCwgW21ham9yLCBtaW5vciwgcGF0Y2gsIGFnZW50ID0gJyddKSA9PiB7XG4gICAgICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgICAgdmVyc2lvblJlc3BvbnNlKGFzTnVtYmVyKG1ham9yKSwgYXNOdW1iZXIobWlub3IpLCBhc051bWJlcihwYXRjaCksIGFnZW50KVxuICAgICAgICAgKTtcbiAgICAgIH1cbiAgICksXG4gICBuZXcgTGluZVBhcnNlcihcbiAgICAgIC92ZXJzaW9uIChcXGQrKVxcLihcXGQrKVxcLihcXEQrKSguKyk/JC8sXG4gICAgICAocmVzdWx0LCBbbWFqb3IsIG1pbm9yLCBwYXRjaCwgYWdlbnQgPSAnJ10pID0+IHtcbiAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzdWx0LCB2ZXJzaW9uUmVzcG9uc2UoYXNOdW1iZXIobWFqb3IpLCBhc051bWJlcihtaW5vciksIHBhdGNoLCBhZ2VudCkpO1xuICAgICAgfVxuICAgKSxcbl07XG5cbmZ1bmN0aW9uIHZlcnNpb25QYXJzZXIoc3RkT3V0OiBzdHJpbmcpIHtcbiAgIGlmIChzdGRPdXQgPT09IE5PVF9JTlNUQUxMRUQpIHtcbiAgICAgIHJldHVybiBub3RJbnN0YWxsZWRSZXNwb25zZSgpO1xuICAgfVxuXG4gICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZSh2ZXJzaW9uUmVzcG9uc2UoMCwgMCwgMCwgc3RkT3V0KSwgcGFyc2Vycywgc3RkT3V0KTtcbn1cbiIsICJpbXBvcnQgeyBTaW1wbGVHaXRCYXNlIH0gZnJvbSAnLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyB0YXNrQ2FsbGJhY2sgfSBmcm9tICcuL3Rhc2stY2FsbGJhY2snO1xuaW1wb3J0IHsgY2hhbmdlV29ya2luZ0RpcmVjdG9yeVRhc2sgfSBmcm9tICcuL3Rhc2tzL2NoYW5nZS13b3JraW5nLWRpcmVjdG9yeSc7XG5pbXBvcnQgY2hlY2tvdXQgZnJvbSAnLi90YXNrcy9jaGVja291dCc7XG5pbXBvcnQgY29tbWl0IGZyb20gJy4vdGFza3MvY29tbWl0JztcbmltcG9ydCBjb25maWcgZnJvbSAnLi90YXNrcy9jb25maWcnO1xuaW1wb3J0IGZpcnN0Q29tbWl0IGZyb20gJy4vdGFza3MvZmlyc3QtY29tbWl0JztcbmltcG9ydCBncmVwIGZyb20gJy4vdGFza3MvZ3JlcCc7XG5pbXBvcnQgeyBoYXNoT2JqZWN0VGFzayB9IGZyb20gJy4vdGFza3MvaGFzaC1vYmplY3QnO1xuaW1wb3J0IHsgaW5pdFRhc2sgfSBmcm9tICcuL3Rhc2tzL2luaXQnO1xuaW1wb3J0IGxvZyBmcm9tICcuL3Rhc2tzL2xvZyc7XG5pbXBvcnQgeyBtZXJnZVRhc2sgfSBmcm9tICcuL3Rhc2tzL21lcmdlJztcbmltcG9ydCB7IHB1c2hUYXNrIH0gZnJvbSAnLi90YXNrcy9wdXNoJztcbmltcG9ydCBzaG93IGZyb20gJy4vdGFza3Mvc2hvdyc7XG5pbXBvcnQgeyBzdGF0dXNUYXNrIH0gZnJvbSAnLi90YXNrcy9zdGF0dXMnO1xuaW1wb3J0IHsgY29uZmlndXJhdGlvbkVycm9yVGFzaywgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayB9IGZyb20gJy4vdGFza3MvdGFzayc7XG5pbXBvcnQgdmVyc2lvbiBmcm9tICcuL3Rhc2tzL3ZlcnNpb24nO1xuaW1wb3J0IHsgb3V0cHV0SGFuZGxlciwgU2ltcGxlR2l0RXhlY3V0b3IsIFNpbXBsZUdpdFRhc2ssIFNpbXBsZUdpdFRhc2tDYWxsYmFjayB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHtcbiAgIGFzQXJyYXksXG4gICBmaWx0ZXJTdHJpbmcsXG4gICBmaWx0ZXJUeXBlLFxuICAgZ2V0VHJhaWxpbmdPcHRpb25zLFxuICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50LFxufSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGNsYXNzIFNpbXBsZUdpdEFwaSBpbXBsZW1lbnRzIFNpbXBsZUdpdEJhc2Uge1xuICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZXhlY3V0b3I6IFNpbXBsZUdpdEV4ZWN1dG9yKSB7fVxuXG4gICBwcm90ZWN0ZWQgX3J1blRhc2s8VD4odGFzazogU2ltcGxlR2l0VGFzazxUPiwgdGhlbj86IFNpbXBsZUdpdFRhc2tDYWxsYmFjazxUPikge1xuICAgICAgY29uc3QgY2hhaW4gPSB0aGlzLl9leGVjdXRvci5jaGFpbigpO1xuICAgICAgY29uc3QgcHJvbWlzZSA9IGNoYWluLnB1c2godGFzayk7XG5cbiAgICAgIGlmICh0aGVuKSB7XG4gICAgICAgICB0YXNrQ2FsbGJhY2sodGFzaywgcHJvbWlzZSwgdGhlbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBPYmplY3QuY3JlYXRlKHRoaXMsIHtcbiAgICAgICAgIHRoZW46IHsgdmFsdWU6IHByb21pc2UudGhlbi5iaW5kKHByb21pc2UpIH0sXG4gICAgICAgICBjYXRjaDogeyB2YWx1ZTogcHJvbWlzZS5jYXRjaC5iaW5kKHByb21pc2UpIH0sXG4gICAgICAgICBfZXhlY3V0b3I6IHsgdmFsdWU6IGNoYWluIH0sXG4gICAgICB9KTtcbiAgIH1cblxuICAgYWRkKGZpbGVzOiBzdHJpbmcgfCBzdHJpbmdbXSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKFsnYWRkJywgLi4uYXNBcnJheShmaWxlcyldKSxcbiAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICApO1xuICAgfVxuXG4gICBjd2QoZGlyZWN0b3J5OiBzdHJpbmcgfCB7IHBhdGg6IHN0cmluZzsgcm9vdD86IGJvb2xlYW4gfSkge1xuICAgICAgY29uc3QgbmV4dCA9IHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpO1xuXG4gICAgICBpZiAodHlwZW9mIGRpcmVjdG9yeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKGNoYW5nZVdvcmtpbmdEaXJlY3RvcnlUYXNrKGRpcmVjdG9yeSwgdGhpcy5fZXhlY3V0b3IpLCBuZXh0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBkaXJlY3Rvcnk/LnBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgICAgIGNoYW5nZVdvcmtpbmdEaXJlY3RvcnlUYXNrKFxuICAgICAgICAgICAgICAgZGlyZWN0b3J5LnBhdGgsXG4gICAgICAgICAgICAgICAoZGlyZWN0b3J5LnJvb3QgJiYgdGhpcy5fZXhlY3V0b3IpIHx8IHVuZGVmaW5lZFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIG5leHRcbiAgICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgY29uZmlndXJhdGlvbkVycm9yVGFzaygnR2l0LmN3ZDogd29ya2luZ0RpcmVjdG9yeSBtdXN0IGJlIHN1cHBsaWVkIGFzIGEgc3RyaW5nJyksXG4gICAgICAgICBuZXh0XG4gICAgICApO1xuICAgfVxuXG4gICBoYXNoT2JqZWN0KHBhdGg6IHN0cmluZywgd3JpdGU6IGJvb2xlYW4gfCB1bmtub3duKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgIGhhc2hPYmplY3RUYXNrKHBhdGgsIHdyaXRlID09PSB0cnVlKSxcbiAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICApO1xuICAgfVxuXG4gICBpbml0KGJhcmU/OiBib29sZWFuIHwgdW5rbm93bikge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICBpbml0VGFzayhiYXJlID09PSB0cnVlLCB0aGlzLl9leGVjdXRvci5jd2QsIGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpKSxcbiAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICApO1xuICAgfVxuXG4gICBtZXJnZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgbWVyZ2VUYXNrKGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpKSxcbiAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICApO1xuICAgfVxuXG4gICBtZXJnZUZyb21UbyhyZW1vdGU6IHN0cmluZywgYnJhbmNoOiBzdHJpbmcpIHtcbiAgICAgIGlmICghKGZpbHRlclN0cmluZyhyZW1vdGUpICYmIGZpbHRlclN0cmluZyhicmFuY2gpKSkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgICBjb25maWd1cmF0aW9uRXJyb3JUYXNrKFxuICAgICAgICAgICAgICAgYEdpdC5tZXJnZUZyb21UbyByZXF1aXJlcyB0aGF0IHRoZSAncmVtb3RlJyBhbmQgJ2JyYW5jaCcgYXJndW1lbnRzIGFyZSBzdXBwbGllZCBhcyBzdHJpbmdzYFxuICAgICAgICAgICAgKVxuICAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICBtZXJnZVRhc2soW3JlbW90ZSwgYnJhbmNoLCAuLi5nZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKV0pLFxuICAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cywgZmFsc2UpXG4gICAgICApO1xuICAgfVxuXG4gICBvdXRwdXRIYW5kbGVyKGhhbmRsZXI6IG91dHB1dEhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX2V4ZWN1dG9yLm91dHB1dEhhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICB9XG5cbiAgIHB1c2goKSB7XG4gICAgICBjb25zdCB0YXNrID0gcHVzaFRhc2soXG4gICAgICAgICB7XG4gICAgICAgICAgICByZW1vdGU6IGZpbHRlclR5cGUoYXJndW1lbnRzWzBdLCBmaWx0ZXJTdHJpbmcpLFxuICAgICAgICAgICAgYnJhbmNoOiBmaWx0ZXJUeXBlKGFyZ3VtZW50c1sxXSwgZmlsdGVyU3RyaW5nKSxcbiAgICAgICAgIH0sXG4gICAgICAgICBnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2sodGFzaywgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cykpO1xuICAgfVxuXG4gICBzdGFzaCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhbJ3N0YXNoJywgLi4uZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cyldKSxcbiAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICApO1xuICAgfVxuXG4gICBzdGF0dXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgIHN0YXR1c1Rhc2soZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cykpLFxuICAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICk7XG4gICB9XG59XG5cbk9iamVjdC5hc3NpZ24oXG4gICBTaW1wbGVHaXRBcGkucHJvdG90eXBlLFxuICAgY2hlY2tvdXQoKSxcbiAgIGNvbW1pdCgpLFxuICAgY29uZmlnKCksXG4gICBmaXJzdENvbW1pdCgpLFxuICAgZ3JlcCgpLFxuICAgbG9nKCksXG4gICBzaG93KCksXG4gICB2ZXJzaW9uKClcbik7XG4iLCAiaW1wb3J0IHsgYXBwZW5kLCByZW1vdmUgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBjcmVhdGVEZWZlcnJlZCwgRGVmZXJyZWRQcm9taXNlIH0gZnJvbSAnQGt3c2l0ZXMvcHJvbWlzZS1kZWZlcnJlZCc7XG5pbXBvcnQgeyBjcmVhdGVMb2dnZXIgfSBmcm9tICcuLi9naXQtbG9nZ2VyJztcblxudHlwZSBTY2hlZHVsZUNvbXBsZXRlQ2FsbGJhY2sgPSAoKSA9PiB2b2lkO1xudHlwZSBTY2hlZHVsZWRUYXNrID0gUGljazxEZWZlcnJlZFByb21pc2U8U2NoZWR1bGVDb21wbGV0ZUNhbGxiYWNrPiwgJ3Byb21pc2UnIHwgJ2RvbmUnPiAmIHtcbiAgIGlkOiBudW1iZXI7XG59O1xuXG5jb25zdCBjcmVhdGVTY2hlZHVsZWRUYXNrOiAoKSA9PiBTY2hlZHVsZWRUYXNrID0gKCgpID0+IHtcbiAgIGxldCBpZCA9IDA7XG4gICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWQrKztcbiAgICAgIGNvbnN0IHsgcHJvbWlzZSwgZG9uZSB9ID0gY3JlYXRlRGVmZXJyZWQ8U2NoZWR1bGVDb21wbGV0ZUNhbGxiYWNrPigpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAgcHJvbWlzZSxcbiAgICAgICAgIGRvbmUsXG4gICAgICAgICBpZCxcbiAgICAgIH07XG4gICB9O1xufSkoKTtcblxuZXhwb3J0IGNsYXNzIFNjaGVkdWxlciB7XG4gICBwcml2YXRlIGxvZ2dlciA9IGNyZWF0ZUxvZ2dlcignJywgJ3NjaGVkdWxlcicpO1xuICAgcHJpdmF0ZSBwZW5kaW5nOiBTY2hlZHVsZWRUYXNrW10gPSBbXTtcbiAgIHByaXZhdGUgcnVubmluZzogU2NoZWR1bGVkVGFza1tdID0gW107XG5cbiAgIGNvbnN0cnVjdG9yKHByaXZhdGUgY29uY3VycmVuY3kgPSAyKSB7XG4gICAgICB0aGlzLmxvZ2dlcihgQ29uc3RydWN0ZWQsIGNvbmN1cnJlbmN5PSVzYCwgY29uY3VycmVuY3kpO1xuICAgfVxuXG4gICBwcml2YXRlIHNjaGVkdWxlKCkge1xuICAgICAgaWYgKCF0aGlzLnBlbmRpbmcubGVuZ3RoIHx8IHRoaXMucnVubmluZy5sZW5ndGggPj0gdGhpcy5jb25jdXJyZW5jeSkge1xuICAgICAgICAgdGhpcy5sb2dnZXIoXG4gICAgICAgICAgICBgU2NoZWR1bGUgYXR0ZW1wdCBpZ25vcmVkLCBwZW5kaW5nPSVzIHJ1bm5pbmc9JXMgY29uY3VycmVuY3k9JXNgLFxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nLmxlbmd0aCxcbiAgICAgICAgICAgIHRoaXMucnVubmluZy5sZW5ndGgsXG4gICAgICAgICAgICB0aGlzLmNvbmN1cnJlbmN5XG4gICAgICAgICApO1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0YXNrID0gYXBwZW5kKHRoaXMucnVubmluZywgdGhpcy5wZW5kaW5nLnNoaWZ0KCkhKTtcbiAgICAgIHRoaXMubG9nZ2VyKGBBdHRlbXB0aW5nIGlkPSVzYCwgdGFzay5pZCk7XG4gICAgICB0YXNrLmRvbmUoKCkgPT4ge1xuICAgICAgICAgdGhpcy5sb2dnZXIoYENvbXBsZXRpbmcgaWQ9YCwgdGFzay5pZCk7XG4gICAgICAgICByZW1vdmUodGhpcy5ydW5uaW5nLCB0YXNrKTtcbiAgICAgICAgIHRoaXMuc2NoZWR1bGUoKTtcbiAgICAgIH0pO1xuICAgfVxuXG4gICBuZXh0KCk6IFByb21pc2U8U2NoZWR1bGVDb21wbGV0ZUNhbGxiYWNrPiB7XG4gICAgICBjb25zdCB7IHByb21pc2UsIGlkIH0gPSBhcHBlbmQodGhpcy5wZW5kaW5nLCBjcmVhdGVTY2hlZHVsZWRUYXNrKCkpO1xuICAgICAgdGhpcy5sb2dnZXIoYFNjaGVkdWxpbmcgaWQ9JXNgLCBpZCk7XG5cbiAgICAgIHRoaXMuc2NoZWR1bGUoKTtcblxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICB9XG59XG4iLCAiaW1wb3J0IHsgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayB9IGZyb20gJy4vdGFzayc7XG5pbXBvcnQgeyBPcHRpb25GbGFncywgT3B0aW9ucywgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IHR5cGUgQXBwbHlPcHRpb25zID0gT3B0aW9ucyAmXG4gICBPcHRpb25GbGFnczxcbiAgICAgIHwgJy0tc3RhdCdcbiAgICAgIHwgJy0tbnVtc3RhdCdcbiAgICAgIHwgJy0tc3VtbWFyeSdcbiAgICAgIHwgJy0tY2hlY2snXG4gICAgICB8ICctLWluZGV4J1xuICAgICAgfCAnLS1pbnRlbnQtdG8tYWRkJ1xuICAgICAgfCAnLS0zd2F5J1xuICAgICAgfCAnLS1hcHBseSdcbiAgICAgIHwgJy0tbm8tYWRkJ1xuICAgICAgfCAnLVInXG4gICAgICB8ICctLXJldmVyc2UnXG4gICAgICB8ICctLWFsbG93LWJpbmFyeS1yZXBsYWNlbWVudCdcbiAgICAgIHwgJy0tYmluYXJ5J1xuICAgICAgfCAnLS1yZWplY3QnXG4gICAgICB8ICcteidcbiAgICAgIHwgJy0taW5hY2N1cmF0ZS1lb2YnXG4gICAgICB8ICctLXJlY291bnQnXG4gICAgICB8ICctLWNhY2hlZCdcbiAgICAgIHwgJy0taWdub3JlLXNwYWNlLWNoYW5nZSdcbiAgICAgIHwgJy0taWdub3JlLXdoaXRlc3BhY2UnXG4gICAgICB8ICctLXZlcmJvc2UnXG4gICAgICB8ICctLXVuc2FmZS1wYXRocydcbiAgID4gJlxuICAgT3B0aW9uRmxhZ3M8Jy0td2hpdGVzcGFjZScsICdub3dhcm4nIHwgJ3dhcm4nIHwgJ2ZpeCcgfCAnZXJyb3InIHwgJ2Vycm9yLWFsbCc+ICZcbiAgIE9wdGlvbkZsYWdzPCctLWJ1aWxkLWZha2UtYW5jZXN0b3InIHwgJy0tZXhjbHVkZScgfCAnLS1pbmNsdWRlJyB8ICctLWRpcmVjdG9yeScsIHN0cmluZz4gJlxuICAgT3B0aW9uRmxhZ3M8Jy1wJyB8ICctQycsIG51bWJlcj47XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVBhdGNoVGFzayhwYXRjaGVzOiBzdHJpbmdbXSwgY3VzdG9tQXJnczogc3RyaW5nW10pOiBTdHJpbmdUYXNrPHN0cmluZz4ge1xuICAgcmV0dXJuIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soWydhcHBseScsIC4uLmN1c3RvbUFyZ3MsIC4uLnBhdGNoZXNdKTtcbn1cbiIsICJpbXBvcnQge1xuICAgQnJhbmNoTXVsdGlEZWxldGVSZXN1bHQsXG4gICBCcmFuY2hTaW5nbGVEZWxldGVGYWlsdXJlLFxuICAgQnJhbmNoU2luZ2xlRGVsZXRlUmVzdWx0LFxuICAgQnJhbmNoU2luZ2xlRGVsZXRlU3VjY2Vzcyxcbn0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5cbmV4cG9ydCBjbGFzcyBCcmFuY2hEZWxldGlvbkJhdGNoIGltcGxlbWVudHMgQnJhbmNoTXVsdGlEZWxldGVSZXN1bHQge1xuICAgYWxsOiBCcmFuY2hTaW5nbGVEZWxldGVSZXN1bHRbXSA9IFtdO1xuICAgYnJhbmNoZXM6IHsgW2JyYW5jaE5hbWU6IHN0cmluZ106IEJyYW5jaFNpbmdsZURlbGV0ZVJlc3VsdCB9ID0ge307XG4gICBlcnJvcnM6IEJyYW5jaFNpbmdsZURlbGV0ZVJlc3VsdFtdID0gW107XG5cbiAgIGdldCBzdWNjZXNzKCk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuICF0aGlzLmVycm9ycy5sZW5ndGg7XG4gICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBicmFuY2hEZWxldGlvblN1Y2Nlc3MoYnJhbmNoOiBzdHJpbmcsIGhhc2g6IHN0cmluZyk6IEJyYW5jaFNpbmdsZURlbGV0ZVN1Y2Nlc3Mge1xuICAgcmV0dXJuIHtcbiAgICAgIGJyYW5jaCxcbiAgICAgIGhhc2gsXG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJyYW5jaERlbGV0aW9uRmFpbHVyZShicmFuY2g6IHN0cmluZyk6IEJyYW5jaFNpbmdsZURlbGV0ZUZhaWx1cmUge1xuICAgcmV0dXJuIHtcbiAgICAgIGJyYW5jaCxcbiAgICAgIGhhc2g6IG51bGwsXG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1NpbmdsZUJyYW5jaERlbGV0ZUZhaWx1cmUoXG4gICB0ZXN0OiBCcmFuY2hTaW5nbGVEZWxldGVSZXN1bHRcbik6IHRlc3QgaXMgQnJhbmNoU2luZ2xlRGVsZXRlU3VjY2VzcyB7XG4gICByZXR1cm4gdGVzdC5zdWNjZXNzO1xufVxuIiwgImltcG9ydCB7IEJyYW5jaE11bHRpRGVsZXRlUmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQge1xuICAgQnJhbmNoRGVsZXRpb25CYXRjaCxcbiAgIGJyYW5jaERlbGV0aW9uRmFpbHVyZSxcbiAgIGJyYW5jaERlbGV0aW9uU3VjY2Vzcyxcbn0gZnJvbSAnLi4vcmVzcG9uc2VzL0JyYW5jaERlbGV0ZVN1bW1hcnknO1xuaW1wb3J0IHsgVGFza1BhcnNlciB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IEV4aXRDb2RlcywgTGluZVBhcnNlciwgcGFyc2VTdHJpbmdSZXNwb25zZSB9IGZyb20gJy4uL3V0aWxzJztcblxuY29uc3QgZGVsZXRlU3VjY2Vzc1JlZ2V4ID0gLyhcXFMrKVxccytcXChcXFMrXFxzKFteKV0rKVxcKS87XG5jb25zdCBkZWxldGVFcnJvclJlZ2V4ID0gL15lcnJvclteJ10rJyhbXiddKyknL207XG5cbmNvbnN0IHBhcnNlcnM6IExpbmVQYXJzZXI8QnJhbmNoTXVsdGlEZWxldGVSZXN1bHQ+W10gPSBbXG4gICBuZXcgTGluZVBhcnNlcihkZWxldGVTdWNjZXNzUmVnZXgsIChyZXN1bHQsIFticmFuY2gsIGhhc2hdKSA9PiB7XG4gICAgICBjb25zdCBkZWxldGlvbiA9IGJyYW5jaERlbGV0aW9uU3VjY2VzcyhicmFuY2gsIGhhc2gpO1xuXG4gICAgICByZXN1bHQuYWxsLnB1c2goZGVsZXRpb24pO1xuICAgICAgcmVzdWx0LmJyYW5jaGVzW2JyYW5jaF0gPSBkZWxldGlvbjtcbiAgIH0pLFxuICAgbmV3IExpbmVQYXJzZXIoZGVsZXRlRXJyb3JSZWdleCwgKHJlc3VsdCwgW2JyYW5jaF0pID0+IHtcbiAgICAgIGNvbnN0IGRlbGV0aW9uID0gYnJhbmNoRGVsZXRpb25GYWlsdXJlKGJyYW5jaCk7XG5cbiAgICAgIHJlc3VsdC5lcnJvcnMucHVzaChkZWxldGlvbik7XG4gICAgICByZXN1bHQuYWxsLnB1c2goZGVsZXRpb24pO1xuICAgICAgcmVzdWx0LmJyYW5jaGVzW2JyYW5jaF0gPSBkZWxldGlvbjtcbiAgIH0pLFxuXTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlQnJhbmNoRGVsZXRpb25zOiBUYXNrUGFyc2VyPHN0cmluZywgQnJhbmNoTXVsdGlEZWxldGVSZXN1bHQ+ID0gKFxuICAgc3RkT3V0LFxuICAgc3RkRXJyXG4pID0+IHtcbiAgIHJldHVybiBwYXJzZVN0cmluZ1Jlc3BvbnNlKG5ldyBCcmFuY2hEZWxldGlvbkJhdGNoKCksIHBhcnNlcnMsIFtzdGRPdXQsIHN0ZEVycl0pO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0JyYW5jaERlbGV0aW9uRXJyb3IoZGF0YTogc3RyaW5nLCBwcm9jZXNzRXhpdENvZGU6IEV4aXRDb2Rlcyk6IGJvb2xlYW4ge1xuICAgcmV0dXJuIHByb2Nlc3NFeGl0Q29kZSA9PT0gRXhpdENvZGVzLkVSUk9SICYmIGRlbGV0ZUVycm9yUmVnZXgudGVzdChkYXRhKTtcbn1cbiIsICJpbXBvcnQgdHlwZSB7IEJyYW5jaFN1bW1hcnksIEJyYW5jaFN1bW1hcnlCcmFuY2ggfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcblxuZXhwb3J0IGVudW0gQnJhbmNoU3RhdHVzSWRlbnRpZmllciB7XG4gICBDVVJSRU5UID0gJyonLFxuICAgTElOS0VEID0gJysnLFxufVxuXG5leHBvcnQgY2xhc3MgQnJhbmNoU3VtbWFyeVJlc3VsdCBpbXBsZW1lbnRzIEJyYW5jaFN1bW1hcnkge1xuICAgcHVibGljIGFsbDogc3RyaW5nW10gPSBbXTtcbiAgIHB1YmxpYyBicmFuY2hlczogeyBbcDogc3RyaW5nXTogQnJhbmNoU3VtbWFyeUJyYW5jaCB9ID0ge307XG4gICBwdWJsaWMgY3VycmVudDogc3RyaW5nID0gJyc7XG4gICBwdWJsaWMgZGV0YWNoZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgcHVzaChcbiAgICAgIHN0YXR1czogQnJhbmNoU3RhdHVzSWRlbnRpZmllciB8IHVua25vd24sXG4gICAgICBkZXRhY2hlZDogYm9vbGVhbixcbiAgICAgIG5hbWU6IHN0cmluZyxcbiAgICAgIGNvbW1pdDogc3RyaW5nLFxuICAgICAgbGFiZWw6IHN0cmluZ1xuICAgKSB7XG4gICAgICBpZiAoc3RhdHVzID09PSBCcmFuY2hTdGF0dXNJZGVudGlmaWVyLkNVUlJFTlQpIHtcbiAgICAgICAgIHRoaXMuZGV0YWNoZWQgPSBkZXRhY2hlZDtcbiAgICAgICAgIHRoaXMuY3VycmVudCA9IG5hbWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYWxsLnB1c2gobmFtZSk7XG4gICAgICB0aGlzLmJyYW5jaGVzW25hbWVdID0ge1xuICAgICAgICAgY3VycmVudDogc3RhdHVzID09PSBCcmFuY2hTdGF0dXNJZGVudGlmaWVyLkNVUlJFTlQsXG4gICAgICAgICBsaW5rZWRXb3JrVHJlZTogc3RhdHVzID09PSBCcmFuY2hTdGF0dXNJZGVudGlmaWVyLkxJTktFRCxcbiAgICAgICAgIG5hbWUsXG4gICAgICAgICBjb21taXQsXG4gICAgICAgICBsYWJlbCxcbiAgICAgIH07XG4gICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBCcmFuY2hTdW1tYXJ5IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBCcmFuY2hTdW1tYXJ5UmVzdWx0IH0gZnJvbSAnLi4vcmVzcG9uc2VzL0JyYW5jaFN1bW1hcnknO1xuaW1wb3J0IHsgTGluZVBhcnNlciwgcGFyc2VTdHJpbmdSZXNwb25zZSB9IGZyb20gJy4uL3V0aWxzJztcblxuY29uc3QgcGFyc2VyczogTGluZVBhcnNlcjxCcmFuY2hTdW1tYXJ5UmVzdWx0PltdID0gW1xuICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAvXihbKitdXFxzKT9cXCgoPzpIRUFEICk/ZGV0YWNoZWQgKD86ZnJvbXxhdCkgKFxcUyspXFwpXFxzKyhbYS16MC05XSspXFxzKC4qKSQvLFxuICAgICAgKHJlc3VsdCwgW2N1cnJlbnQsIG5hbWUsIGNvbW1pdCwgbGFiZWxdKSA9PiB7XG4gICAgICAgICByZXN1bHQucHVzaChicmFuY2hTdGF0dXMoY3VycmVudCksIHRydWUsIG5hbWUsIGNvbW1pdCwgbGFiZWwpO1xuICAgICAgfVxuICAgKSxcbiAgIG5ldyBMaW5lUGFyc2VyKFxuICAgICAgL14oWyorXVxccyk/KFxcUyspXFxzKyhbYS16MC05XSspXFxzPyguKikkL3MsXG4gICAgICAocmVzdWx0LCBbY3VycmVudCwgbmFtZSwgY29tbWl0LCBsYWJlbF0pID0+IHtcbiAgICAgICAgIHJlc3VsdC5wdXNoKGJyYW5jaFN0YXR1cyhjdXJyZW50KSwgZmFsc2UsIG5hbWUsIGNvbW1pdCwgbGFiZWwpO1xuICAgICAgfVxuICAgKSxcbl07XG5cbmZ1bmN0aW9uIGJyYW5jaFN0YXR1cyhpbnB1dD86IHN0cmluZykge1xuICAgcmV0dXJuIGlucHV0ID8gaW5wdXQuY2hhckF0KDApIDogJyc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUJyYW5jaFN1bW1hcnkoc3RkT3V0OiBzdHJpbmcpOiBCcmFuY2hTdW1tYXJ5IHtcbiAgIHJldHVybiBwYXJzZVN0cmluZ1Jlc3BvbnNlKG5ldyBCcmFuY2hTdW1tYXJ5UmVzdWx0KCksIHBhcnNlcnMsIHN0ZE91dCk7XG59XG4iLCAiaW1wb3J0IHsgQnJhbmNoTXVsdGlEZWxldGVSZXN1bHQsIEJyYW5jaFNpbmdsZURlbGV0ZVJlc3VsdCwgQnJhbmNoU3VtbWFyeSB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IEdpdFJlc3BvbnNlRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMvZ2l0LXJlc3BvbnNlLWVycm9yJztcbmltcG9ydCB7IGhhc0JyYW5jaERlbGV0aW9uRXJyb3IsIHBhcnNlQnJhbmNoRGVsZXRpb25zIH0gZnJvbSAnLi4vcGFyc2Vycy9wYXJzZS1icmFuY2gtZGVsZXRlJztcbmltcG9ydCB7IHBhcnNlQnJhbmNoU3VtbWFyeSB9IGZyb20gJy4uL3BhcnNlcnMvcGFyc2UtYnJhbmNoJztcbmltcG9ydCB7IGJ1ZmZlclRvU3RyaW5nIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gY29udGFpbnNEZWxldGVCcmFuY2hDb21tYW5kKGNvbW1hbmRzOiBzdHJpbmdbXSkge1xuICAgY29uc3QgZGVsZXRlQ29tbWFuZHMgPSBbJy1kJywgJy1EJywgJy0tZGVsZXRlJ107XG4gICByZXR1cm4gY29tbWFuZHMuc29tZSgoY29tbWFuZCkgPT4gZGVsZXRlQ29tbWFuZHMuaW5jbHVkZXMoY29tbWFuZCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYnJhbmNoVGFzayhcbiAgIGN1c3RvbUFyZ3M6IHN0cmluZ1tdXG4pOiBTdHJpbmdUYXNrPEJyYW5jaFN1bW1hcnkgfCBCcmFuY2hTaW5nbGVEZWxldGVSZXN1bHQ+IHtcbiAgIGNvbnN0IGlzRGVsZXRlID0gY29udGFpbnNEZWxldGVCcmFuY2hDb21tYW5kKGN1c3RvbUFyZ3MpO1xuICAgY29uc3QgY29tbWFuZHMgPSBbJ2JyYW5jaCcsIC4uLmN1c3RvbUFyZ3NdO1xuXG4gICBpZiAoY29tbWFuZHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb21tYW5kcy5wdXNoKCctYScpO1xuICAgfVxuXG4gICBpZiAoIWNvbW1hbmRzLmluY2x1ZGVzKCctdicpKSB7XG4gICAgICBjb21tYW5kcy5zcGxpY2UoMSwgMCwgJy12Jyk7XG4gICB9XG5cbiAgIHJldHVybiB7XG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBjb21tYW5kcyxcbiAgICAgIHBhcnNlcihzdGRPdXQsIHN0ZEVycikge1xuICAgICAgICAgaWYgKGlzRGVsZXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VCcmFuY2hEZWxldGlvbnMoc3RkT3V0LCBzdGRFcnIpLmFsbFswXTtcbiAgICAgICAgIH1cblxuICAgICAgICAgcmV0dXJuIHBhcnNlQnJhbmNoU3VtbWFyeShzdGRPdXQpO1xuICAgICAgfSxcbiAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBicmFuY2hMb2NhbFRhc2soKTogU3RyaW5nVGFzazxCcmFuY2hTdW1tYXJ5PiB7XG4gICBjb25zdCBwYXJzZXIgPSBwYXJzZUJyYW5jaFN1bW1hcnk7XG5cbiAgIHJldHVybiB7XG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBjb21tYW5kczogWydicmFuY2gnLCAnLXYnXSxcbiAgICAgIHBhcnNlcixcbiAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWxldGVCcmFuY2hlc1Rhc2soXG4gICBicmFuY2hlczogc3RyaW5nW10sXG4gICBmb3JjZURlbGV0ZSA9IGZhbHNlXG4pOiBTdHJpbmdUYXNrPEJyYW5jaE11bHRpRGVsZXRlUmVzdWx0PiB7XG4gICByZXR1cm4ge1xuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgY29tbWFuZHM6IFsnYnJhbmNoJywgJy12JywgZm9yY2VEZWxldGUgPyAnLUQnIDogJy1kJywgLi4uYnJhbmNoZXNdLFxuICAgICAgcGFyc2VyKHN0ZE91dCwgc3RkRXJyKSB7XG4gICAgICAgICByZXR1cm4gcGFyc2VCcmFuY2hEZWxldGlvbnMoc3RkT3V0LCBzdGRFcnIpO1xuICAgICAgfSxcbiAgICAgIG9uRXJyb3IoeyBleGl0Q29kZSwgc3RkT3V0IH0sIGVycm9yLCBkb25lLCBmYWlsKSB7XG4gICAgICAgICBpZiAoIWhhc0JyYW5jaERlbGV0aW9uRXJyb3IoU3RyaW5nKGVycm9yKSwgZXhpdENvZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFpbChlcnJvcik7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGRvbmUoc3RkT3V0KTtcbiAgICAgIH0sXG4gICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVsZXRlQnJhbmNoVGFzayhcbiAgIGJyYW5jaDogc3RyaW5nLFxuICAgZm9yY2VEZWxldGUgPSBmYWxzZVxuKTogU3RyaW5nVGFzazxCcmFuY2hTaW5nbGVEZWxldGVSZXN1bHQ+IHtcbiAgIGNvbnN0IHRhc2s6IFN0cmluZ1Rhc2s8QnJhbmNoU2luZ2xlRGVsZXRlUmVzdWx0PiA9IHtcbiAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgIGNvbW1hbmRzOiBbJ2JyYW5jaCcsICctdicsIGZvcmNlRGVsZXRlID8gJy1EJyA6ICctZCcsIGJyYW5jaF0sXG4gICAgICBwYXJzZXIoc3RkT3V0LCBzdGRFcnIpIHtcbiAgICAgICAgIHJldHVybiBwYXJzZUJyYW5jaERlbGV0aW9ucyhzdGRPdXQsIHN0ZEVycikuYnJhbmNoZXNbYnJhbmNoXSE7XG4gICAgICB9LFxuICAgICAgb25FcnJvcih7IGV4aXRDb2RlLCBzdGRFcnIsIHN0ZE91dCB9LCBlcnJvciwgXywgZmFpbCkge1xuICAgICAgICAgaWYgKCFoYXNCcmFuY2hEZWxldGlvbkVycm9yKFN0cmluZyhlcnJvciksIGV4aXRDb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhaWwoZXJyb3IpO1xuICAgICAgICAgfVxuXG4gICAgICAgICB0aHJvdyBuZXcgR2l0UmVzcG9uc2VFcnJvcihcbiAgICAgICAgICAgIHRhc2sucGFyc2VyKGJ1ZmZlclRvU3RyaW5nKHN0ZE91dCksIGJ1ZmZlclRvU3RyaW5nKHN0ZEVycikpLFxuICAgICAgICAgICAgU3RyaW5nKGVycm9yKVxuICAgICAgICAgKTtcbiAgICAgIH0sXG4gICB9O1xuXG4gICByZXR1cm4gdGFzaztcbn1cbiIsICIvKipcbiAqIFBhcnNlciBmb3IgdGhlIGBjaGVjay1pZ25vcmVgIGNvbW1hbmQgLSByZXR1cm5zIGVhY2ggZmlsZSBhcyBhIHN0cmluZyBhcnJheVxuICovXG5leHBvcnQgY29uc3QgcGFyc2VDaGVja0lnbm9yZSA9ICh0ZXh0OiBzdHJpbmcpOiBzdHJpbmdbXSA9PiB7XG4gICByZXR1cm4gdGV4dFxuICAgICAgLnNwbGl0KC9cXG4vZylcbiAgICAgIC5tYXAoKGxpbmUpID0+IGxpbmUudHJpbSgpKVxuICAgICAgLmZpbHRlcigoZmlsZSkgPT4gISFmaWxlKTtcbn07XG4iLCAiaW1wb3J0IHsgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IHBhcnNlQ2hlY2tJZ25vcmUgfSBmcm9tICcuLi9yZXNwb25zZXMvQ2hlY2tJZ25vcmUnO1xuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tJZ25vcmVUYXNrKHBhdGhzOiBzdHJpbmdbXSk6IFN0cmluZ1Rhc2s8c3RyaW5nW10+IHtcbiAgIHJldHVybiB7XG4gICAgICBjb21tYW5kczogWydjaGVjay1pZ25vcmUnLCAuLi5wYXRoc10sXG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBwYXJzZXI6IHBhcnNlQ2hlY2tJZ25vcmUsXG4gICB9O1xufVxuIiwgImltcG9ydCB7IGNvbmZpZ3VyYXRpb25FcnJvclRhc2ssIEVtcHR5VGFzaywgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayB9IGZyb20gJy4vdGFzayc7XG5pbXBvcnQgeyBPcHRpb25GbGFncywgT3B0aW9ucywgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGFwcGVuZCwgZmlsdGVyU3RyaW5nIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgdHlwZSBDbG9uZU9wdGlvbnMgPSBPcHRpb25zICZcbiAgIE9wdGlvbkZsYWdzPFxuICAgICAgfCAnLS1iYXJlJ1xuICAgICAgfCAnLS1kaXNzb2NpYXRlJ1xuICAgICAgfCAnLS1taXJyb3InXG4gICAgICB8ICctLW5vLWNoZWNrb3V0J1xuICAgICAgfCAnLS1uby1yZW1vdGUtc3VibW9kdWxlcydcbiAgICAgIHwgJy0tbm8tc2hhbGxvdy1zdWJtb2R1bGVzJ1xuICAgICAgfCAnLS1uby1zaW5nbGUtYnJhbmNoJ1xuICAgICAgfCAnLS1uby10YWdzJ1xuICAgICAgfCAnLS1yZW1vdGUtc3VibW9kdWxlcydcbiAgICAgIHwgJy0tc2luZ2xlLWJyYW5jaCdcbiAgICAgIHwgJy0tc2hhbGxvdy1zdWJtb2R1bGVzJ1xuICAgICAgfCAnLS12ZXJib3NlJ1xuICAgPiAmXG4gICBPcHRpb25GbGFnczwnLS1kZXB0aCcgfCAnLWonIHwgJy0tam9icycsIG51bWJlcj4gJlxuICAgT3B0aW9uRmxhZ3M8XG4gICAgICB8ICctLWJyYW5jaCdcbiAgICAgIHwgJy0tb3JpZ2luJ1xuICAgICAgfCAnLS1yZWN1cnNlLXN1Ym1vZHVsZXMnXG4gICAgICB8ICctLXNlcGFyYXRlLWdpdC1kaXInXG4gICAgICB8ICctLXNoYWxsb3ctZXhjbHVkZSdcbiAgICAgIHwgJy0tc2hhbGxvdy1zaW5jZSdcbiAgICAgIHwgJy0tdGVtcGxhdGUnLFxuICAgICAgc3RyaW5nXG4gICA+O1xuXG5mdW5jdGlvbiBkaXNhbGxvd2VkQ29tbWFuZChjb21tYW5kOiBzdHJpbmcpIHtcbiAgIHJldHVybiAvXi0tdXBsb2FkLXBhY2soPXwkKS8udGVzdChjb21tYW5kKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lVGFzayhcbiAgIHJlcG86IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgIGRpcmVjdG9yeTogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgY3VzdG9tQXJnczogc3RyaW5nW11cbik6IFN0cmluZ1Rhc2s8c3RyaW5nPiB8IEVtcHR5VGFzayB7XG4gICBjb25zdCBjb21tYW5kcyA9IFsnY2xvbmUnLCAuLi5jdXN0b21BcmdzXTtcblxuICAgZmlsdGVyU3RyaW5nKHJlcG8pICYmIGNvbW1hbmRzLnB1c2gocmVwbyk7XG4gICBmaWx0ZXJTdHJpbmcoZGlyZWN0b3J5KSAmJiBjb21tYW5kcy5wdXNoKGRpcmVjdG9yeSk7XG5cbiAgIGNvbnN0IGJhbm5lZCA9IGNvbW1hbmRzLmZpbmQoZGlzYWxsb3dlZENvbW1hbmQpO1xuICAgaWYgKGJhbm5lZCkge1xuICAgICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25FcnJvclRhc2soYGdpdC5mZXRjaDogcG90ZW50aWFsIGV4cGxvaXQgYXJndW1lbnQgYmxvY2tlZC5gKTtcbiAgIH1cblxuICAgcmV0dXJuIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soY29tbWFuZHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xvbmVNaXJyb3JUYXNrKFxuICAgcmVwbzogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgZGlyZWN0b3J5OiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICBjdXN0b21BcmdzOiBzdHJpbmdbXVxuKSB7XG4gICBhcHBlbmQoY3VzdG9tQXJncywgJy0tbWlycm9yJyk7XG5cbiAgIHJldHVybiBjbG9uZVRhc2socmVwbywgZGlyZWN0b3J5LCBjdXN0b21BcmdzKTtcbn1cbiIsICJpbXBvcnQgeyBGZXRjaFJlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgTGluZVBhcnNlciwgcGFyc2VTdHJpbmdSZXNwb25zZSB9IGZyb20gJy4uL3V0aWxzJztcblxuY29uc3QgcGFyc2VyczogTGluZVBhcnNlcjxGZXRjaFJlc3VsdD5bXSA9IFtcbiAgIG5ldyBMaW5lUGFyc2VyKC9Gcm9tICguKykkLywgKHJlc3VsdCwgW3JlbW90ZV0pID0+IHtcbiAgICAgIHJlc3VsdC5yZW1vdGUgPSByZW1vdGU7XG4gICB9KSxcbiAgIG5ldyBMaW5lUGFyc2VyKC9cXCogXFxbbmV3IGJyYW5jaF1cXHMrKFxcUyspXFxzKi0+ICguKykkLywgKHJlc3VsdCwgW25hbWUsIHRyYWNraW5nXSkgPT4ge1xuICAgICAgcmVzdWx0LmJyYW5jaGVzLnB1c2goe1xuICAgICAgICAgbmFtZSxcbiAgICAgICAgIHRyYWNraW5nLFxuICAgICAgfSk7XG4gICB9KSxcbiAgIG5ldyBMaW5lUGFyc2VyKC9cXCogXFxbbmV3IHRhZ11cXHMrKFxcUyspXFxzKi0+ICguKykkLywgKHJlc3VsdCwgW25hbWUsIHRyYWNraW5nXSkgPT4ge1xuICAgICAgcmVzdWx0LnRhZ3MucHVzaCh7XG4gICAgICAgICBuYW1lLFxuICAgICAgICAgdHJhY2tpbmcsXG4gICAgICB9KTtcbiAgIH0pLFxuICAgbmV3IExpbmVQYXJzZXIoLy0gXFxbZGVsZXRlZF1cXHMrXFxTK1xccyotPiAoLispJC8sIChyZXN1bHQsIFt0cmFja2luZ10pID0+IHtcbiAgICAgIHJlc3VsdC5kZWxldGVkLnB1c2goe1xuICAgICAgICAgdHJhY2tpbmcsXG4gICAgICB9KTtcbiAgIH0pLFxuICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAvXFxzKihbXi5dKylcXC5cXC4oXFxTKylcXHMrKFxcUyspXFxzKi0+ICguKykkLyxcbiAgICAgIChyZXN1bHQsIFtmcm9tLCB0bywgbmFtZSwgdHJhY2tpbmddKSA9PiB7XG4gICAgICAgICByZXN1bHQudXBkYXRlZC5wdXNoKHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB0cmFja2luZyxcbiAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgIH0pO1xuICAgICAgfVxuICAgKSxcbl07XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUZldGNoUmVzdWx0KHN0ZE91dDogc3RyaW5nLCBzdGRFcnI6IHN0cmluZyk6IEZldGNoUmVzdWx0IHtcbiAgIGNvbnN0IHJlc3VsdDogRmV0Y2hSZXN1bHQgPSB7XG4gICAgICByYXc6IHN0ZE91dCxcbiAgICAgIHJlbW90ZTogbnVsbCxcbiAgICAgIGJyYW5jaGVzOiBbXSxcbiAgICAgIHRhZ3M6IFtdLFxuICAgICAgdXBkYXRlZDogW10sXG4gICAgICBkZWxldGVkOiBbXSxcbiAgIH07XG4gICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZShyZXN1bHQsIHBhcnNlcnMsIFtzdGRPdXQsIHN0ZEVycl0pO1xufVxuIiwgImltcG9ydCB7IEZldGNoUmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBwYXJzZUZldGNoUmVzdWx0IH0gZnJvbSAnLi4vcGFyc2Vycy9wYXJzZS1mZXRjaCc7XG5pbXBvcnQgeyBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBjb25maWd1cmF0aW9uRXJyb3JUYXNrLCBFbXB0eVRhc2sgfSBmcm9tICcuL3Rhc2snO1xuXG5mdW5jdGlvbiBkaXNhbGxvd2VkQ29tbWFuZChjb21tYW5kOiBzdHJpbmcpIHtcbiAgIHJldHVybiAvXi0tdXBsb2FkLXBhY2soPXwkKS8udGVzdChjb21tYW5kKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZldGNoVGFzayhcbiAgIHJlbW90ZTogc3RyaW5nLFxuICAgYnJhbmNoOiBzdHJpbmcsXG4gICBjdXN0b21BcmdzOiBzdHJpbmdbXVxuKTogU3RyaW5nVGFzazxGZXRjaFJlc3VsdD4gfCBFbXB0eVRhc2sge1xuICAgY29uc3QgY29tbWFuZHMgPSBbJ2ZldGNoJywgLi4uY3VzdG9tQXJnc107XG4gICBpZiAocmVtb3RlICYmIGJyYW5jaCkge1xuICAgICAgY29tbWFuZHMucHVzaChyZW1vdGUsIGJyYW5jaCk7XG4gICB9XG5cbiAgIGNvbnN0IGJhbm5lZCA9IGNvbW1hbmRzLmZpbmQoZGlzYWxsb3dlZENvbW1hbmQpO1xuICAgaWYgKGJhbm5lZCkge1xuICAgICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25FcnJvclRhc2soYGdpdC5mZXRjaDogcG90ZW50aWFsIGV4cGxvaXQgYXJndW1lbnQgYmxvY2tlZC5gKTtcbiAgIH1cblxuICAgcmV0dXJuIHtcbiAgICAgIGNvbW1hbmRzLFxuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgcGFyc2VyOiBwYXJzZUZldGNoUmVzdWx0LFxuICAgfTtcbn1cbiIsICJpbXBvcnQgeyBNb3ZlUmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBMaW5lUGFyc2VyLCBwYXJzZVN0cmluZ1Jlc3BvbnNlIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5jb25zdCBwYXJzZXJzOiBMaW5lUGFyc2VyPE1vdmVSZXN1bHQ+W10gPSBbXG4gICBuZXcgTGluZVBhcnNlcigvXlJlbmFtaW5nICguKykgdG8gKC4rKSQvLCAocmVzdWx0LCBbZnJvbSwgdG9dKSA9PiB7XG4gICAgICByZXN1bHQubW92ZXMucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgfSksXG5dO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VNb3ZlUmVzdWx0KHN0ZE91dDogc3RyaW5nKTogTW92ZVJlc3VsdCB7XG4gICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZSh7IG1vdmVzOiBbXSB9LCBwYXJzZXJzLCBzdGRPdXQpO1xufVxuIiwgImltcG9ydCB7IE1vdmVSZXN1bHQgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IHBhcnNlTW92ZVJlc3VsdCB9IGZyb20gJy4uL3BhcnNlcnMvcGFyc2UtbW92ZSc7XG5pbXBvcnQgeyBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgYXNBcnJheSB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIG1vdmVUYXNrKGZyb206IHN0cmluZyB8IHN0cmluZ1tdLCB0bzogc3RyaW5nKTogU3RyaW5nVGFzazxNb3ZlUmVzdWx0PiB7XG4gICByZXR1cm4ge1xuICAgICAgY29tbWFuZHM6IFsnbXYnLCAnLXYnLCAuLi5hc0FycmF5KGZyb20pLCB0b10sXG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBwYXJzZXI6IHBhcnNlTW92ZVJlc3VsdCxcbiAgIH07XG59XG4iLCAiaW1wb3J0IHsgUHVsbFJlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgR2l0UmVzcG9uc2VFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9naXQtcmVzcG9uc2UtZXJyb3InO1xuaW1wb3J0IHsgcGFyc2VQdWxsRXJyb3JSZXN1bHQsIHBhcnNlUHVsbFJlc3VsdCB9IGZyb20gJy4uL3BhcnNlcnMvcGFyc2UtcHVsbCc7XG5pbXBvcnQgeyBNYXliZSwgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGJ1ZmZlclRvU3RyaW5nIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gcHVsbFRhc2soXG4gICByZW1vdGU6IE1heWJlPHN0cmluZz4sXG4gICBicmFuY2g6IE1heWJlPHN0cmluZz4sXG4gICBjdXN0b21BcmdzOiBzdHJpbmdbXVxuKTogU3RyaW5nVGFzazxQdWxsUmVzdWx0PiB7XG4gICBjb25zdCBjb21tYW5kczogc3RyaW5nW10gPSBbJ3B1bGwnLCAuLi5jdXN0b21BcmdzXTtcbiAgIGlmIChyZW1vdGUgJiYgYnJhbmNoKSB7XG4gICAgICBjb21tYW5kcy5zcGxpY2UoMSwgMCwgcmVtb3RlLCBicmFuY2gpO1xuICAgfVxuXG4gICByZXR1cm4ge1xuICAgICAgY29tbWFuZHMsXG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBwYXJzZXIoc3RkT3V0LCBzdGRFcnIpOiBQdWxsUmVzdWx0IHtcbiAgICAgICAgIHJldHVybiBwYXJzZVB1bGxSZXN1bHQoc3RkT3V0LCBzdGRFcnIpO1xuICAgICAgfSxcbiAgICAgIG9uRXJyb3IocmVzdWx0LCBfZXJyb3IsIF9kb25lLCBmYWlsKSB7XG4gICAgICAgICBjb25zdCBwdWxsRXJyb3IgPSBwYXJzZVB1bGxFcnJvclJlc3VsdChcbiAgICAgICAgICAgIGJ1ZmZlclRvU3RyaW5nKHJlc3VsdC5zdGRPdXQpLFxuICAgICAgICAgICAgYnVmZmVyVG9TdHJpbmcocmVzdWx0LnN0ZEVycilcbiAgICAgICAgICk7XG4gICAgICAgICBpZiAocHVsbEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFpbChuZXcgR2l0UmVzcG9uc2VFcnJvcihwdWxsRXJyb3IpKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgZmFpbChfZXJyb3IpO1xuICAgICAgfSxcbiAgIH07XG59XG4iLCAiaW1wb3J0IHsgZm9yRWFjaExpbmVXaXRoQ29udGVudCB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGludGVyZmFjZSBSZW1vdGVXaXRob3V0UmVmcyB7XG4gICBuYW1lOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVtb3RlV2l0aFJlZnMgZXh0ZW5kcyBSZW1vdGVXaXRob3V0UmVmcyB7XG4gICByZWZzOiB7XG4gICAgICBmZXRjaDogc3RyaW5nO1xuICAgICAgcHVzaDogc3RyaW5nO1xuICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlR2V0UmVtb3Rlcyh0ZXh0OiBzdHJpbmcpOiBSZW1vdGVXaXRob3V0UmVmc1tdIHtcbiAgIGNvbnN0IHJlbW90ZXM6IHsgW25hbWU6IHN0cmluZ106IFJlbW90ZVdpdGhvdXRSZWZzIH0gPSB7fTtcblxuICAgZm9yRWFjaCh0ZXh0LCAoW25hbWVdKSA9PiAocmVtb3Rlc1tuYW1lXSA9IHsgbmFtZSB9KSk7XG5cbiAgIHJldHVybiBPYmplY3QudmFsdWVzKHJlbW90ZXMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VHZXRSZW1vdGVzVmVyYm9zZSh0ZXh0OiBzdHJpbmcpOiBSZW1vdGVXaXRoUmVmc1tdIHtcbiAgIGNvbnN0IHJlbW90ZXM6IHsgW25hbWU6IHN0cmluZ106IFJlbW90ZVdpdGhSZWZzIH0gPSB7fTtcblxuICAgZm9yRWFjaCh0ZXh0LCAoW25hbWUsIHVybCwgcHVycG9zZV0pID0+IHtcbiAgICAgIGlmICghcmVtb3Rlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgcmVtb3Rlc1tuYW1lXSA9IHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICByZWZzOiB7IGZldGNoOiAnJywgcHVzaDogJycgfSxcbiAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChwdXJwb3NlICYmIHVybCkge1xuICAgICAgICAgcmVtb3Rlc1tuYW1lXS5yZWZzW3B1cnBvc2UucmVwbGFjZSgvW15hLXpdL2csICcnKSBhcyBrZXlvZiBSZW1vdGVXaXRoUmVmc1sncmVmcyddXSA9IHVybDtcbiAgICAgIH1cbiAgIH0pO1xuXG4gICByZXR1cm4gT2JqZWN0LnZhbHVlcyhyZW1vdGVzKTtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaCh0ZXh0OiBzdHJpbmcsIGhhbmRsZXI6IChsaW5lOiBzdHJpbmdbXSkgPT4gdm9pZCkge1xuICAgZm9yRWFjaExpbmVXaXRoQ29udGVudCh0ZXh0LCAobGluZSkgPT4gaGFuZGxlcihsaW5lLnNwbGl0KC9cXHMrLykpKTtcbn1cbiIsICJpbXBvcnQgeyBwYXJzZUdldFJlbW90ZXMsIHBhcnNlR2V0UmVtb3Rlc1ZlcmJvc2UgfSBmcm9tICcuLi9yZXNwb25zZXMvR2V0UmVtb3RlU3VtbWFyeSc7XG5pbXBvcnQgeyBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayB9IGZyb20gJy4vdGFzayc7XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRSZW1vdGVUYXNrKFxuICAgcmVtb3RlTmFtZTogc3RyaW5nLFxuICAgcmVtb3RlUmVwbzogc3RyaW5nLFxuICAgY3VzdG9tQXJnczogc3RyaW5nW10gPSBbXVxuKTogU3RyaW5nVGFzazxzdHJpbmc+IHtcbiAgIHJldHVybiBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKFsncmVtb3RlJywgJ2FkZCcsIC4uLmN1c3RvbUFyZ3MsIHJlbW90ZU5hbWUsIHJlbW90ZVJlcG9dKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlbW90ZXNUYXNrKHZlcmJvc2U6IGJvb2xlYW4pOiBTdHJpbmdUYXNrPGFueT4ge1xuICAgY29uc3QgY29tbWFuZHMgPSBbJ3JlbW90ZSddO1xuICAgaWYgKHZlcmJvc2UpIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goJy12Jyk7XG4gICB9XG5cbiAgIHJldHVybiB7XG4gICAgICBjb21tYW5kcyxcbiAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgIHBhcnNlcjogdmVyYm9zZSA/IHBhcnNlR2V0UmVtb3Rlc1ZlcmJvc2UgOiBwYXJzZUdldFJlbW90ZXMsXG4gICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGlzdFJlbW90ZXNUYXNrKGN1c3RvbUFyZ3M6IHN0cmluZ1tdID0gW10pOiBTdHJpbmdUYXNrPHN0cmluZz4ge1xuICAgY29uc3QgY29tbWFuZHMgPSBbLi4uY3VzdG9tQXJnc107XG4gICBpZiAoY29tbWFuZHNbMF0gIT09ICdscy1yZW1vdGUnKSB7XG4gICAgICBjb21tYW5kcy51bnNoaWZ0KCdscy1yZW1vdGUnKTtcbiAgIH1cblxuICAgcmV0dXJuIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soY29tbWFuZHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3RlVGFzayhjdXN0b21BcmdzOiBzdHJpbmdbXSA9IFtdKTogU3RyaW5nVGFzazxzdHJpbmc+IHtcbiAgIGNvbnN0IGNvbW1hbmRzID0gWy4uLmN1c3RvbUFyZ3NdO1xuICAgaWYgKGNvbW1hbmRzWzBdICE9PSAncmVtb3RlJykge1xuICAgICAgY29tbWFuZHMudW5zaGlmdCgncmVtb3RlJyk7XG4gICB9XG5cbiAgIHJldHVybiBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKGNvbW1hbmRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVJlbW90ZVRhc2socmVtb3RlTmFtZTogc3RyaW5nKSB7XG4gICByZXR1cm4gc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhbJ3JlbW90ZScsICdyZW1vdmUnLCByZW1vdGVOYW1lXSk7XG59XG4iLCAiaW1wb3J0IHsgTG9nT3B0aW9ucywgTG9nUmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBsb2dGb3JtYXRGcm9tQ29tbWFuZCB9IGZyb20gJy4uL2FyZ3MvbG9nLWZvcm1hdCc7XG5pbXBvcnQgeyBjcmVhdGVMaXN0TG9nU3VtbWFyeVBhcnNlciB9IGZyb20gJy4uL3BhcnNlcnMvcGFyc2UtbGlzdC1sb2ctc3VtbWFyeSc7XG5pbXBvcnQgdHlwZSB7IFN0cmluZ1Rhc2sgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyB2YWxpZGF0ZUxvZ0Zvcm1hdENvbmZpZyB9IGZyb20gJy4vZGlmZic7XG5pbXBvcnQgeyBwYXJzZUxvZ09wdGlvbnMgfSBmcm9tICcuL2xvZyc7XG5pbXBvcnQgdHlwZSB7IEVtcHR5VGFzayB9IGZyb20gJy4vdGFzayc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGFzaExpc3RUYXNrKFxuICAgb3B0OiBMb2dPcHRpb25zID0ge30sXG4gICBjdXN0b21BcmdzOiBzdHJpbmdbXVxuKTogRW1wdHlUYXNrIHwgU3RyaW5nVGFzazxMb2dSZXN1bHQ+IHtcbiAgIGNvbnN0IG9wdGlvbnMgPSBwYXJzZUxvZ09wdGlvbnM8YW55PihvcHQpO1xuICAgY29uc3QgY29tbWFuZHMgPSBbJ3N0YXNoJywgJ2xpc3QnLCAuLi5vcHRpb25zLmNvbW1hbmRzLCAuLi5jdXN0b21BcmdzXTtcbiAgIGNvbnN0IHBhcnNlciA9IGNyZWF0ZUxpc3RMb2dTdW1tYXJ5UGFyc2VyKFxuICAgICAgb3B0aW9ucy5zcGxpdHRlcixcbiAgICAgIG9wdGlvbnMuZmllbGRzLFxuICAgICAgbG9nRm9ybWF0RnJvbUNvbW1hbmQoY29tbWFuZHMpXG4gICApO1xuXG4gICByZXR1cm4gKFxuICAgICAgdmFsaWRhdGVMb2dGb3JtYXRDb25maWcoY29tbWFuZHMpIHx8IHtcbiAgICAgICAgIGNvbW1hbmRzLFxuICAgICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgICAgcGFyc2VyLFxuICAgICAgfVxuICAgKTtcbn1cbiIsICJpbXBvcnQgeyBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayB9IGZyb20gJy4vdGFzayc7XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRTdWJNb2R1bGVUYXNrKHJlcG86IHN0cmluZywgcGF0aDogc3RyaW5nKTogU3RyaW5nVGFzazxzdHJpbmc+IHtcbiAgIHJldHVybiBzdWJNb2R1bGVUYXNrKFsnYWRkJywgcmVwbywgcGF0aF0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdFN1Yk1vZHVsZVRhc2soY3VzdG9tQXJnczogc3RyaW5nW10pOiBTdHJpbmdUYXNrPHN0cmluZz4ge1xuICAgcmV0dXJuIHN1Yk1vZHVsZVRhc2soWydpbml0JywgLi4uY3VzdG9tQXJnc10pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3ViTW9kdWxlVGFzayhjdXN0b21BcmdzOiBzdHJpbmdbXSk6IFN0cmluZ1Rhc2s8c3RyaW5nPiB7XG4gICBjb25zdCBjb21tYW5kcyA9IFsuLi5jdXN0b21BcmdzXTtcbiAgIGlmIChjb21tYW5kc1swXSAhPT0gJ3N1Ym1vZHVsZScpIHtcbiAgICAgIGNvbW1hbmRzLnVuc2hpZnQoJ3N1Ym1vZHVsZScpO1xuICAgfVxuXG4gICByZXR1cm4gc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhjb21tYW5kcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVTdWJNb2R1bGVUYXNrKGN1c3RvbUFyZ3M6IHN0cmluZ1tdKTogU3RyaW5nVGFzazxzdHJpbmc+IHtcbiAgIHJldHVybiBzdWJNb2R1bGVUYXNrKFsndXBkYXRlJywgLi4uY3VzdG9tQXJnc10pO1xufVxuIiwgImltcG9ydCB7IFRhZ1Jlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuXG5leHBvcnQgY2xhc3MgVGFnTGlzdCBpbXBsZW1lbnRzIFRhZ1Jlc3VsdCB7XG4gICBjb25zdHJ1Y3RvcihcbiAgICAgIHB1YmxpYyByZWFkb25seSBhbGw6IHN0cmluZ1tdLFxuICAgICAgcHVibGljIHJlYWRvbmx5IGxhdGVzdDogc3RyaW5nIHwgdW5kZWZpbmVkXG4gICApIHt9XG59XG5cbmV4cG9ydCBjb25zdCBwYXJzZVRhZ0xpc3QgPSBmdW5jdGlvbiAoZGF0YTogc3RyaW5nLCBjdXN0b21Tb3J0ID0gZmFsc2UpIHtcbiAgIGNvbnN0IHRhZ3MgPSBkYXRhLnNwbGl0KCdcXG4nKS5tYXAodHJpbW1lZCkuZmlsdGVyKEJvb2xlYW4pO1xuXG4gICBpZiAoIWN1c3RvbVNvcnQpIHtcbiAgICAgIHRhZ3Muc29ydChmdW5jdGlvbiAodGFnQSwgdGFnQikge1xuICAgICAgICAgY29uc3QgcGFydHNBID0gdGFnQS5zcGxpdCgnLicpO1xuICAgICAgICAgY29uc3QgcGFydHNCID0gdGFnQi5zcGxpdCgnLicpO1xuXG4gICAgICAgICBpZiAocGFydHNBLmxlbmd0aCA9PT0gMSB8fCBwYXJ0c0IubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gc2luZ2xlU29ydGVkKHRvTnVtYmVyKHBhcnRzQVswXSksIHRvTnVtYmVyKHBhcnRzQlswXSkpO1xuICAgICAgICAgfVxuXG4gICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IE1hdGgubWF4KHBhcnRzQS5sZW5ndGgsIHBhcnRzQi5sZW5ndGgpOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBkaWZmID0gc29ydGVkKHRvTnVtYmVyKHBhcnRzQVtpXSksIHRvTnVtYmVyKHBhcnRzQltpXSkpO1xuXG4gICAgICAgICAgICBpZiAoZGlmZikge1xuICAgICAgICAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG5cbiAgICAgICAgIHJldHVybiAwO1xuICAgICAgfSk7XG4gICB9XG5cbiAgIGNvbnN0IGxhdGVzdCA9IGN1c3RvbVNvcnQgPyB0YWdzWzBdIDogWy4uLnRhZ3NdLnJldmVyc2UoKS5maW5kKCh0YWcpID0+IHRhZy5pbmRleE9mKCcuJykgPj0gMCk7XG5cbiAgIHJldHVybiBuZXcgVGFnTGlzdCh0YWdzLCBsYXRlc3QpO1xufTtcblxuZnVuY3Rpb24gc2luZ2xlU29ydGVkKGE6IG51bWJlciwgYjogbnVtYmVyKTogbnVtYmVyIHtcbiAgIGNvbnN0IGFJc051bSA9IGlzTmFOKGEpO1xuICAgY29uc3QgYklzTnVtID0gaXNOYU4oYik7XG5cbiAgIGlmIChhSXNOdW0gIT09IGJJc051bSkge1xuICAgICAgcmV0dXJuIGFJc051bSA/IDEgOiAtMTtcbiAgIH1cblxuICAgcmV0dXJuIGFJc051bSA/IHNvcnRlZChhLCBiKSA6IDA7XG59XG5cbmZ1bmN0aW9uIHNvcnRlZChhOiBudW1iZXIsIGI6IG51bWJlcikge1xuICAgcmV0dXJuIGEgPT09IGIgPyAwIDogYSA+IGIgPyAxIDogLTE7XG59XG5cbmZ1bmN0aW9uIHRyaW1tZWQoaW5wdXQ6IHN0cmluZykge1xuICAgcmV0dXJuIGlucHV0LnRyaW0oKTtcbn1cblxuZnVuY3Rpb24gdG9OdW1iZXIoaW5wdXQ6IHN0cmluZyB8IHVuZGVmaW5lZCkge1xuICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBwYXJzZUludChpbnB1dC5yZXBsYWNlKC9eXFxEKy9nLCAnJyksIDEwKSB8fCAwO1xuICAgfVxuXG4gICByZXR1cm4gMDtcbn1cbiIsICJpbXBvcnQgeyBUYWdSZXN1bHQgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IHBhcnNlVGFnTGlzdCB9IGZyb20gJy4uL3Jlc3BvbnNlcy9UYWdMaXN0JztcbmltcG9ydCB7IFN0cmluZ1Rhc2sgfSBmcm9tICcuLi90eXBlcyc7XG5cbi8qKlxuICogVGFzayB1c2VkIGJ5IGBnaXQudGFnc2BcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRhZ0xpc3RUYXNrKGN1c3RvbUFyZ3M6IHN0cmluZ1tdID0gW10pOiBTdHJpbmdUYXNrPFRhZ1Jlc3VsdD4ge1xuICAgY29uc3QgaGFzQ3VzdG9tU29ydCA9IGN1c3RvbUFyZ3Muc29tZSgob3B0aW9uKSA9PiAvXi0tc29ydD0vLnRlc3Qob3B0aW9uKSk7XG5cbiAgIHJldHVybiB7XG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBjb21tYW5kczogWyd0YWcnLCAnLWwnLCAuLi5jdXN0b21BcmdzXSxcbiAgICAgIHBhcnNlcih0ZXh0OiBzdHJpbmcpIHtcbiAgICAgICAgIHJldHVybiBwYXJzZVRhZ0xpc3QodGV4dCwgaGFzQ3VzdG9tU29ydCk7XG4gICAgICB9LFxuICAgfTtcbn1cblxuLyoqXG4gKiBUYXNrIHVzZWQgYnkgYGdpdC5hZGRUYWdgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRUYWdUYXNrKG5hbWU6IHN0cmluZyk6IFN0cmluZ1Rhc2s8eyBuYW1lOiBzdHJpbmcgfT4ge1xuICAgcmV0dXJuIHtcbiAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgIGNvbW1hbmRzOiBbJ3RhZycsIG5hbWVdLFxuICAgICAgcGFyc2VyKCkge1xuICAgICAgICAgcmV0dXJuIHsgbmFtZSB9O1xuICAgICAgfSxcbiAgIH07XG59XG5cbi8qKlxuICogVGFzayB1c2VkIGJ5IGBnaXQuYWRkVGFnYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkQW5ub3RhdGVkVGFnVGFzayhcbiAgIG5hbWU6IHN0cmluZyxcbiAgIHRhZ01lc3NhZ2U6IHN0cmluZ1xuKTogU3RyaW5nVGFzazx7IG5hbWU6IHN0cmluZyB9PiB7XG4gICByZXR1cm4ge1xuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgY29tbWFuZHM6IFsndGFnJywgJy1hJywgJy1tJywgdGFnTWVzc2FnZSwgbmFtZV0sXG4gICAgICBwYXJzZXIoKSB7XG4gICAgICAgICByZXR1cm4geyBuYW1lIH07XG4gICAgICB9LFxuICAgfTtcbn1cbiIsICJjb25zdCB7IEdpdEV4ZWN1dG9yIH0gPSByZXF1aXJlKCcuL2xpYi9ydW5uZXJzL2dpdC1leGVjdXRvcicpO1xuY29uc3QgeyBTaW1wbGVHaXRBcGkgfSA9IHJlcXVpcmUoJy4vbGliL3NpbXBsZS1naXQtYXBpJyk7XG5cbmNvbnN0IHsgU2NoZWR1bGVyIH0gPSByZXF1aXJlKCcuL2xpYi9ydW5uZXJzL3NjaGVkdWxlcicpO1xuY29uc3QgeyBjb25maWd1cmF0aW9uRXJyb3JUYXNrIH0gPSByZXF1aXJlKCcuL2xpYi90YXNrcy90YXNrJyk7XG5jb25zdCB7XG4gICBhc0FycmF5LFxuICAgZmlsdGVyQXJyYXksXG4gICBmaWx0ZXJQcmltaXRpdmVzLFxuICAgZmlsdGVyU3RyaW5nLFxuICAgZmlsdGVyU3RyaW5nT3JTdHJpbmdBcnJheSxcbiAgIGZpbHRlclR5cGUsXG4gICBnZXRUcmFpbGluZ09wdGlvbnMsXG4gICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQsXG4gICB0cmFpbGluZ09wdGlvbnNBcmd1bWVudCxcbn0gPSByZXF1aXJlKCcuL2xpYi91dGlscycpO1xuY29uc3QgeyBhcHBseVBhdGNoVGFzayB9ID0gcmVxdWlyZSgnLi9saWIvdGFza3MvYXBwbHktcGF0Y2gnKTtcbmNvbnN0IHtcbiAgIGJyYW5jaFRhc2ssXG4gICBicmFuY2hMb2NhbFRhc2ssXG4gICBkZWxldGVCcmFuY2hlc1Rhc2ssXG4gICBkZWxldGVCcmFuY2hUYXNrLFxufSA9IHJlcXVpcmUoJy4vbGliL3Rhc2tzL2JyYW5jaCcpO1xuY29uc3QgeyBjaGVja0lnbm9yZVRhc2sgfSA9IHJlcXVpcmUoJy4vbGliL3Rhc2tzL2NoZWNrLWlnbm9yZScpO1xuY29uc3QgeyBjaGVja0lzUmVwb1Rhc2sgfSA9IHJlcXVpcmUoJy4vbGliL3Rhc2tzL2NoZWNrLWlzLXJlcG8nKTtcbmNvbnN0IHsgY2xvbmVUYXNrLCBjbG9uZU1pcnJvclRhc2sgfSA9IHJlcXVpcmUoJy4vbGliL3Rhc2tzL2Nsb25lJyk7XG5jb25zdCB7IGNsZWFuV2l0aE9wdGlvbnNUYXNrLCBpc0NsZWFuT3B0aW9uc0FycmF5IH0gPSByZXF1aXJlKCcuL2xpYi90YXNrcy9jbGVhbicpO1xuY29uc3QgeyBkaWZmU3VtbWFyeVRhc2sgfSA9IHJlcXVpcmUoJy4vbGliL3Rhc2tzL2RpZmYnKTtcbmNvbnN0IHsgZmV0Y2hUYXNrIH0gPSByZXF1aXJlKCcuL2xpYi90YXNrcy9mZXRjaCcpO1xuY29uc3QgeyBtb3ZlVGFzayB9ID0gcmVxdWlyZSgnLi9saWIvdGFza3MvbW92ZScpO1xuY29uc3QgeyBwdWxsVGFzayB9ID0gcmVxdWlyZSgnLi9saWIvdGFza3MvcHVsbCcpO1xuY29uc3QgeyBwdXNoVGFnc1Rhc2sgfSA9IHJlcXVpcmUoJy4vbGliL3Rhc2tzL3B1c2gnKTtcbmNvbnN0IHtcbiAgIGFkZFJlbW90ZVRhc2ssXG4gICBnZXRSZW1vdGVzVGFzayxcbiAgIGxpc3RSZW1vdGVzVGFzayxcbiAgIHJlbW90ZVRhc2ssXG4gICByZW1vdmVSZW1vdGVUYXNrLFxufSA9IHJlcXVpcmUoJy4vbGliL3Rhc2tzL3JlbW90ZScpO1xuY29uc3QgeyBnZXRSZXNldE1vZGUsIHJlc2V0VGFzayB9ID0gcmVxdWlyZSgnLi9saWIvdGFza3MvcmVzZXQnKTtcbmNvbnN0IHsgc3Rhc2hMaXN0VGFzayB9ID0gcmVxdWlyZSgnLi9saWIvdGFza3Mvc3Rhc2gtbGlzdCcpO1xuY29uc3Qge1xuICAgYWRkU3ViTW9kdWxlVGFzayxcbiAgIGluaXRTdWJNb2R1bGVUYXNrLFxuICAgc3ViTW9kdWxlVGFzayxcbiAgIHVwZGF0ZVN1Yk1vZHVsZVRhc2ssXG59ID0gcmVxdWlyZSgnLi9saWIvdGFza3Mvc3ViLW1vZHVsZScpO1xuY29uc3QgeyBhZGRBbm5vdGF0ZWRUYWdUYXNrLCBhZGRUYWdUYXNrLCB0YWdMaXN0VGFzayB9ID0gcmVxdWlyZSgnLi9saWIvdGFza3MvdGFnJyk7XG5jb25zdCB7IHN0cmFpZ2h0VGhyb3VnaEJ1ZmZlclRhc2ssIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2sgfSA9IHJlcXVpcmUoJy4vbGliL3Rhc2tzL3Rhc2snKTtcblxuZnVuY3Rpb24gR2l0KG9wdGlvbnMsIHBsdWdpbnMpIHtcbiAgIHRoaXMuX2V4ZWN1dG9yID0gbmV3IEdpdEV4ZWN1dG9yKFxuICAgICAgb3B0aW9ucy5iaW5hcnksXG4gICAgICBvcHRpb25zLmJhc2VEaXIsXG4gICAgICBuZXcgU2NoZWR1bGVyKG9wdGlvbnMubWF4Q29uY3VycmVudFByb2Nlc3NlcyksXG4gICAgICBwbHVnaW5zXG4gICApO1xuXG4gICB0aGlzLl90cmltbWVkID0gb3B0aW9ucy50cmltbWVkO1xufVxuXG4oR2l0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU2ltcGxlR2l0QXBpLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gR2l0O1xuXG4vKipcbiAqIFNldHMgdGhlIHBhdGggdG8gYSBjdXN0b20gZ2l0IGJpbmFyeSwgc2hvdWxkIGVpdGhlciBiZSBgZ2l0YCB3aGVuIHRoZXJlIGlzIGFuIGluc3RhbGxhdGlvbiBvZiBnaXQgYXZhaWxhYmxlIG9uXG4gKiB0aGUgc3lzdGVtIHBhdGgsIG9yIGEgZnVsbHkgcXVhbGlmaWVkIHBhdGggdG8gdGhlIGV4ZWN1dGFibGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbW1hbmRcbiAqIEByZXR1cm5zIHtHaXR9XG4gKi9cbkdpdC5wcm90b3R5cGUuY3VzdG9tQmluYXJ5ID0gZnVuY3Rpb24gKGNvbW1hbmQpIHtcbiAgIHRoaXMuX2V4ZWN1dG9yLmJpbmFyeSA9IGNvbW1hbmQ7XG4gICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyBhbiBlbnZpcm9ubWVudCB2YXJpYWJsZSBmb3IgdGhlIHNwYXduZWQgY2hpbGQgcHJvY2VzcywgZWl0aGVyIHN1cHBseSBib3RoIGEgbmFtZSBhbmQgdmFsdWUgYXMgc3RyaW5ncyBvclxuICogYSBzaW5nbGUgb2JqZWN0IHRvIGVudGlyZWx5IHJlcGxhY2UgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IFt2YWx1ZV1cbiAqIEByZXR1cm5zIHtHaXR9XG4gKi9cbkdpdC5wcm90b3R5cGUuZW52ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHRoaXMuX2V4ZWN1dG9yLmVudiA9IG5hbWU7XG4gICB9IGVsc2Uge1xuICAgICAgKHRoaXMuX2V4ZWN1dG9yLmVudiA9IHRoaXMuX2V4ZWN1dG9yLmVudiB8fCB7fSlbbmFtZV0gPSB2YWx1ZTtcbiAgIH1cblxuICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIExpc3QgdGhlIHN0YXNoKHMpIG9mIHRoZSBsb2NhbCByZXBvXG4gKi9cbkdpdC5wcm90b3R5cGUuc3Rhc2hMaXN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgc3Rhc2hMaXN0VGFzayhcbiAgICAgICAgIHRyYWlsaW5nT3B0aW9uc0FyZ3VtZW50KGFyZ3VtZW50cykgfHwge30sXG4gICAgICAgICAoZmlsdGVyQXJyYXkob3B0aW9ucykgJiYgb3B0aW9ucykgfHwgW11cbiAgICAgICksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUNsb25lVGFzayhhcGksIHRhc2ssIHJlcG9QYXRoLCBsb2NhbFBhdGgpIHtcbiAgIGlmICh0eXBlb2YgcmVwb1BhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gY29uZmlndXJhdGlvbkVycm9yVGFzayhgZ2l0LiR7YXBpfSgpIHJlcXVpcmVzIGEgc3RyaW5nICdyZXBvUGF0aCdgKTtcbiAgIH1cblxuICAgcmV0dXJuIHRhc2socmVwb1BhdGgsIGZpbHRlclR5cGUobG9jYWxQYXRoLCBmaWx0ZXJTdHJpbmcpLCBnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKSk7XG59XG5cbi8qKlxuICogQ2xvbmUgYSBnaXQgcmVwb1xuICovXG5HaXQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICBjcmVhdGVDbG9uZVRhc2soJ2Nsb25lJywgY2xvbmVUYXNrLCAuLi5hcmd1bWVudHMpLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG4vKipcbiAqIE1pcnJvciBhIGdpdCByZXBvXG4gKi9cbkdpdC5wcm90b3R5cGUubWlycm9yID0gZnVuY3Rpb24gKCkge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICBjcmVhdGVDbG9uZVRhc2soJ21pcnJvcicsIGNsb25lTWlycm9yVGFzaywgLi4uYXJndW1lbnRzKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxuLyoqXG4gKiBNb3ZlcyBvbmUgb3IgbW9yZSBmaWxlcyB0byBhIG5ldyBkZXN0aW5hdGlvbi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0LXNjbS5jb20vZG9jcy9naXQtbXZcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gZnJvbVxuICogQHBhcmFtIHtzdHJpbmd9IHRvXG4gKi9cbkdpdC5wcm90b3R5cGUubXYgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKG1vdmVUYXNrKGZyb20sIHRvKSwgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cykpO1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbGx5IHVzZXMgcHVsbCBhbmQgdGFncyB0byBnZXQgdGhlIGxpc3Qgb2YgdGFncyB0aGVuIGNoZWNrcyBvdXQgdGhlIGxhdGVzdCB0YWcuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3RoZW5dXG4gKi9cbkdpdC5wcm90b3R5cGUuY2hlY2tvdXRMYXRlc3RUYWcgPSBmdW5jdGlvbiAodGhlbikge1xuICAgdmFyIGdpdCA9IHRoaXM7XG4gICByZXR1cm4gdGhpcy5wdWxsKGZ1bmN0aW9uICgpIHtcbiAgICAgIGdpdC50YWdzKGZ1bmN0aW9uIChlcnIsIHRhZ3MpIHtcbiAgICAgICAgIGdpdC5jaGVja291dCh0YWdzLmxhdGVzdCwgdGhlbik7XG4gICAgICB9KTtcbiAgIH0pO1xufTtcblxuLyoqXG4gKiBQdWxsIHRoZSB1cGRhdGVkIGNvbnRlbnRzIG9mIHRoZSBjdXJyZW50IHJlcG9cbiAqL1xuR2l0LnByb3RvdHlwZS5wdWxsID0gZnVuY3Rpb24gKHJlbW90ZSwgYnJhbmNoLCBvcHRpb25zLCB0aGVuKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgIHB1bGxUYXNrKFxuICAgICAgICAgZmlsdGVyVHlwZShyZW1vdGUsIGZpbHRlclN0cmluZyksXG4gICAgICAgICBmaWx0ZXJUeXBlKGJyYW5jaCwgZmlsdGVyU3RyaW5nKSxcbiAgICAgICAgIGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpXG4gICAgICApLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG4vKipcbiAqIEZldGNoIHRoZSB1cGRhdGVkIGNvbnRlbnRzIG9mIHRoZSBjdXJyZW50IHJlcG8uXG4gKlxuICogQGV4YW1wbGVcbiAqICAgLmZldGNoKCd1cHN0cmVhbScsICdtYXN0ZXInKSAvLyBmZXRjaGVzIGZyb20gbWFzdGVyIG9uIHJlbW90ZSBuYW1lZCB1cHN0cmVhbVxuICogICAuZmV0Y2goZnVuY3Rpb24gKCkge30pIC8vIHJ1bnMgZmV0Y2ggYWdhaW5zdCBkZWZhdWx0IHJlbW90ZSBhbmQgYnJhbmNoIGFuZCBjYWxscyBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcmVtb3RlXVxuICogQHBhcmFtIHtzdHJpbmd9IFticmFuY2hdXG4gKi9cbkdpdC5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbiAocmVtb3RlLCBicmFuY2gpIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgZmV0Y2hUYXNrKFxuICAgICAgICAgZmlsdGVyVHlwZShyZW1vdGUsIGZpbHRlclN0cmluZyksXG4gICAgICAgICBmaWx0ZXJUeXBlKGJyYW5jaCwgZmlsdGVyU3RyaW5nKSxcbiAgICAgICAgIGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpXG4gICAgICApLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG4vKipcbiAqIERpc2FibGVzL2VuYWJsZXMgdGhlIHVzZSBvZiB0aGUgY29uc29sZSBmb3IgcHJpbnRpbmcgd2FybmluZ3MgYW5kIGVycm9ycywgYnkgZGVmYXVsdCBtZXNzYWdlcyBhcmUgbm90IHNob3duIGluXG4gKiBhIHByb2R1Y3Rpb24gZW52aXJvbm1lbnQuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBzaWxlbmNlXG4gKiBAcmV0dXJucyB7R2l0fVxuICovXG5HaXQucHJvdG90eXBlLnNpbGVudCA9IGZ1bmN0aW9uIChzaWxlbmNlKSB7XG4gICBjb25zb2xlLndhcm4oXG4gICAgICAnc2ltcGxlLWdpdCBkZXByZWNhdGlvbiBub3RpY2U6IGdpdC5zaWxlbnQ6IGxvZ2dpbmcgc2hvdWxkIGJlIGNvbmZpZ3VyZWQgdXNpbmcgdGhlIGBkZWJ1Z2AgbGlicmFyeSAvIGBERUJVR2AgZW52aXJvbm1lbnQgdmFyaWFibGUsIHRoaXMgd2lsbCBiZSBhbiBlcnJvciBpbiB2ZXJzaW9uIDMnXG4gICApO1xuICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIExpc3QgYWxsIHRhZ3MuIFdoZW4gdXNpbmcgZ2l0IDIuNy4wIG9yIGFib3ZlLCBpbmNsdWRlIGFuIG9wdGlvbnMgb2JqZWN0IHdpdGggYFwiLS1zb3J0XCI6IFwicHJvcGVydHktbmFtZVwiYCB0b1xuICogc29ydCB0aGUgdGFncyBieSB0aGF0IHByb3BlcnR5IGluc3RlYWQgb2YgdXNpbmcgdGhlIGRlZmF1bHQgc2VtYW50aWMgdmVyc2lvbmluZyBzb3J0LlxuICpcbiAqIE5vdGUsIHN1cHBseWluZyB0aGlzIG9wdGlvbiB3aGVuIGl0IGlzIG5vdCBzdXBwb3J0ZWQgYnkgeW91ciBHaXQgdmVyc2lvbiB3aWxsIGNhdXNlIHRoZSBvcGVyYXRpb24gdG8gZmFpbC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbdGhlbl1cbiAqL1xuR2l0LnByb3RvdHlwZS50YWdzID0gZnVuY3Rpb24gKG9wdGlvbnMsIHRoZW4pIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgdGFnTGlzdFRhc2soZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cykpLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG4vKipcbiAqIFJlYmFzZXMgdGhlIGN1cnJlbnQgd29ya2luZyBjb3B5LiBPcHRpb25zIGNhbiBiZSBzdXBwbGllZCBlaXRoZXIgYXMgYW4gYXJyYXkgb2Ygc3RyaW5nIHBhcmFtZXRlcnNcbiAqIHRvIGJlIHNlbnQgdG8gdGhlIGBnaXQgcmViYXNlYCBjb21tYW5kLCBvciBhIHN0YW5kYXJkIG9wdGlvbnMgb2JqZWN0LlxuICovXG5HaXQucHJvdG90eXBlLnJlYmFzZSA9IGZ1bmN0aW9uICgpIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhbJ3JlYmFzZScsIC4uLmdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpXSksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbi8qKlxuICogUmVzZXQgYSByZXBvXG4gKi9cbkdpdC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAobW9kZSkge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICByZXNldFRhc2soZ2V0UmVzZXRNb2RlKG1vZGUpLCBnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKSksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbi8qKlxuICogUmV2ZXJ0IG9uZSBvciBtb3JlIGNvbW1pdHMgaW4gdGhlIGxvY2FsIHdvcmtpbmcgY29weVxuICovXG5HaXQucHJvdG90eXBlLnJldmVydCA9IGZ1bmN0aW9uIChjb21taXQpIHtcbiAgIGNvbnN0IG5leHQgPSB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKTtcblxuICAgaWYgKHR5cGVvZiBjb21taXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhjb25maWd1cmF0aW9uRXJyb3JUYXNrKCdDb21taXQgbXVzdCBiZSBhIHN0cmluZycpLCBuZXh0KTtcbiAgIH1cblxuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKFsncmV2ZXJ0JywgLi4uZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cywgMCwgdHJ1ZSksIGNvbW1pdF0pLFxuICAgICAgbmV4dFxuICAgKTtcbn07XG5cbi8qKlxuICogQWRkIGEgbGlnaHR3ZWlnaHQgdGFnIHRvIHRoZSBoZWFkIG9mIHRoZSBjdXJyZW50IGJyYW5jaFxuICovXG5HaXQucHJvdG90eXBlLmFkZFRhZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICBjb25zdCB0YXNrID1cbiAgICAgIHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJ1xuICAgICAgICAgPyBhZGRUYWdUYXNrKG5hbWUpXG4gICAgICAgICA6IGNvbmZpZ3VyYXRpb25FcnJvclRhc2soJ0dpdC5hZGRUYWcgcmVxdWlyZXMgYSB0YWcgbmFtZScpO1xuXG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayh0YXNrLCB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKSk7XG59O1xuXG4vKipcbiAqIEFkZCBhbiBhbm5vdGF0ZWQgdGFnIHRvIHRoZSBoZWFkIG9mIHRoZSBjdXJyZW50IGJyYW5jaFxuICovXG5HaXQucHJvdG90eXBlLmFkZEFubm90YXRlZFRhZyA9IGZ1bmN0aW9uICh0YWdOYW1lLCB0YWdNZXNzYWdlKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgIGFkZEFubm90YXRlZFRhZ1Rhc2sodGFnTmFtZSwgdGFnTWVzc2FnZSksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbi8qKlxuICogRGVsZXRlIGEgbG9jYWwgYnJhbmNoXG4gKi9cbkdpdC5wcm90b3R5cGUuZGVsZXRlTG9jYWxCcmFuY2ggPSBmdW5jdGlvbiAoYnJhbmNoTmFtZSwgZm9yY2VEZWxldGUsIHRoZW4pIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgZGVsZXRlQnJhbmNoVGFzayhicmFuY2hOYW1lLCB0eXBlb2YgZm9yY2VEZWxldGUgPT09ICdib29sZWFuJyA/IGZvcmNlRGVsZXRlIDogZmFsc2UpLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG4vKipcbiAqIERlbGV0ZSBvbmUgb3IgbW9yZSBsb2NhbCBicmFuY2hlc1xuICovXG5HaXQucHJvdG90eXBlLmRlbGV0ZUxvY2FsQnJhbmNoZXMgPSBmdW5jdGlvbiAoYnJhbmNoTmFtZXMsIGZvcmNlRGVsZXRlLCB0aGVuKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgIGRlbGV0ZUJyYW5jaGVzVGFzayhicmFuY2hOYW1lcywgdHlwZW9mIGZvcmNlRGVsZXRlID09PSAnYm9vbGVhbicgPyBmb3JjZURlbGV0ZSA6IGZhbHNlKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxuLyoqXG4gKiBMaXN0IGFsbCBicmFuY2hlc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0IHwgc3RyaW5nW119IFtvcHRpb25zXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3RoZW5dXG4gKi9cbkdpdC5wcm90b3R5cGUuYnJhbmNoID0gZnVuY3Rpb24gKG9wdGlvbnMsIHRoZW4pIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgYnJhbmNoVGFzayhnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKSksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGxpc3Qgb2YgbG9jYWwgYnJhbmNoZXNcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbdGhlbl1cbiAqL1xuR2l0LnByb3RvdHlwZS5icmFuY2hMb2NhbCA9IGZ1bmN0aW9uICh0aGVuKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhicmFuY2hMb2NhbFRhc2soKSwgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cykpO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyBhbnkgY29tbWFuZCBhZ2FpbnN0IHRoZSBnaXQgYmluYXJ5LlxuICovXG5HaXQucHJvdG90eXBlLnJhdyA9IGZ1bmN0aW9uIChjb21tYW5kcykge1xuICAgY29uc3QgY3JlYXRlUmVzdENvbW1hbmRzID0gIUFycmF5LmlzQXJyYXkoY29tbWFuZHMpO1xuICAgY29uc3QgY29tbWFuZCA9IFtdLnNsaWNlLmNhbGwoY3JlYXRlUmVzdENvbW1hbmRzID8gYXJndW1lbnRzIDogY29tbWFuZHMsIDApO1xuXG4gICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbW1hbmQubGVuZ3RoICYmIGNyZWF0ZVJlc3RDb21tYW5kczsgaSsrKSB7XG4gICAgICBpZiAoIWZpbHRlclByaW1pdGl2ZXMoY29tbWFuZFtpXSkpIHtcbiAgICAgICAgIGNvbW1hbmQuc3BsaWNlKGksIGNvbW1hbmQubGVuZ3RoIC0gaSk7XG4gICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgIH1cblxuICAgY29tbWFuZC5wdXNoKC4uLmdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMsIDAsIHRydWUpKTtcblxuICAgdmFyIG5leHQgPSB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKTtcblxuICAgaWYgKCFjb21tYW5kLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICBjb25maWd1cmF0aW9uRXJyb3JUYXNrKCdSYXc6IG11c3Qgc3VwcGx5IG9uZSBvciBtb3JlIGNvbW1hbmQgdG8gZXhlY3V0ZScpLFxuICAgICAgICAgbmV4dFxuICAgICAgKTtcbiAgIH1cblxuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhjb21tYW5kLCB0aGlzLl90cmltbWVkKSwgbmV4dCk7XG59O1xuXG5HaXQucHJvdG90eXBlLnN1Ym1vZHVsZUFkZCA9IGZ1bmN0aW9uIChyZXBvLCBwYXRoLCB0aGVuKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhhZGRTdWJNb2R1bGVUYXNrKHJlcG8sIHBhdGgpLCB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKSk7XG59O1xuXG5HaXQucHJvdG90eXBlLnN1Ym1vZHVsZVVwZGF0ZSA9IGZ1bmN0aW9uIChhcmdzLCB0aGVuKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgIHVwZGF0ZVN1Yk1vZHVsZVRhc2soZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cywgdHJ1ZSkpLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG5HaXQucHJvdG90eXBlLnN1Ym1vZHVsZUluaXQgPSBmdW5jdGlvbiAoYXJncywgdGhlbikge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICBpbml0U3ViTW9kdWxlVGFzayhnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzLCB0cnVlKSksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbkdpdC5wcm90b3R5cGUuc3ViTW9kdWxlID0gZnVuY3Rpb24gKG9wdGlvbnMsIHRoZW4pIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgc3ViTW9kdWxlVGFzayhnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKSksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbkdpdC5wcm90b3R5cGUubGlzdFJlbW90ZSA9IGZ1bmN0aW9uICgpIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgbGlzdFJlbW90ZXNUYXNrKGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgcmVtb3RlIHRvIHRoZSBsaXN0IG9mIHJlbW90ZXMuXG4gKi9cbkdpdC5wcm90b3R5cGUuYWRkUmVtb3RlID0gZnVuY3Rpb24gKHJlbW90ZU5hbWUsIHJlbW90ZVJlcG8sIHRoZW4pIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgYWRkUmVtb3RlVGFzayhyZW1vdGVOYW1lLCByZW1vdGVSZXBvLCBnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKSksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhbiBlbnRyeSBieSBuYW1lIGZyb20gdGhlIGxpc3Qgb2YgcmVtb3Rlcy5cbiAqL1xuR2l0LnByb3RvdHlwZS5yZW1vdmVSZW1vdGUgPSBmdW5jdGlvbiAocmVtb3RlTmFtZSwgdGhlbikge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2socmVtb3ZlUmVtb3RlVGFzayhyZW1vdGVOYW1lKSwgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cykpO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBjdXJyZW50bHkgYXZhaWxhYmxlIHJlbW90ZXMsIHNldHRpbmcgdGhlIG9wdGlvbmFsIHZlcmJvc2UgYXJndW1lbnQgdG8gdHJ1ZSBpbmNsdWRlcyBhZGRpdGlvbmFsXG4gKiBkZXRhaWwgb24gdGhlIHJlbW90ZXMgdGhlbXNlbHZlcy5cbiAqL1xuR2l0LnByb3RvdHlwZS5nZXRSZW1vdGVzID0gZnVuY3Rpb24gKHZlcmJvc2UsIHRoZW4pIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKGdldFJlbW90ZXNUYXNrKHZlcmJvc2UgPT09IHRydWUpLCB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKSk7XG59O1xuXG4vKipcbiAqIENhbGwgYW55IGBnaXQgcmVtb3RlYCBmdW5jdGlvbiB3aXRoIGFyZ3VtZW50cyBwYXNzZWQgYXMgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBvcHRpb25zXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbdGhlbl1cbiAqL1xuR2l0LnByb3RvdHlwZS5yZW1vdGUgPSBmdW5jdGlvbiAob3B0aW9ucywgdGhlbikge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICByZW1vdGVUYXNrKGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxuLyoqXG4gKiBDYWxsIGFueSBgZ2l0IHRhZ2AgZnVuY3Rpb24gd2l0aCBhcmd1bWVudHMgcGFzc2VkIGFzIGFuIGFycmF5IG9mIHN0cmluZ3MuXG4gKlxuICogQHBhcmFtIHtzdHJpbmdbXX0gb3B0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW3RoZW5dXG4gKi9cbkdpdC5wcm90b3R5cGUudGFnID0gZnVuY3Rpb24gKG9wdGlvbnMsIHRoZW4pIHtcbiAgIGNvbnN0IGNvbW1hbmQgPSBnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKTtcblxuICAgaWYgKGNvbW1hbmRbMF0gIT09ICd0YWcnKSB7XG4gICAgICBjb21tYW5kLnVuc2hpZnQoJ3RhZycpO1xuICAgfVxuXG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKGNvbW1hbmQpLCB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKSk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgcmVwb3NpdG9yeSBzZXJ2ZXIgaW5mb1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFt0aGVuXVxuICovXG5HaXQucHJvdG90eXBlLnVwZGF0ZVNlcnZlckluZm8gPSBmdW5jdGlvbiAodGhlbikge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKFsndXBkYXRlLXNlcnZlci1pbmZvJ10pLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG4vKipcbiAqIFB1c2hlcyB0aGUgY3VycmVudCB0YWcgY2hhbmdlcyB0byBhIHJlbW90ZSB3aGljaCBjYW4gYmUgZWl0aGVyIGEgVVJMIG9yIG5hbWVkIHJlbW90ZS4gV2hlbiBub3Qgc3BlY2lmaWVkIHVzZXMgdGhlXG4gKiBkZWZhdWx0IGNvbmZpZ3VyZWQgcmVtb3RlIHNwZWMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtyZW1vdGVdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbdGhlbl1cbiAqL1xuR2l0LnByb3RvdHlwZS5wdXNoVGFncyA9IGZ1bmN0aW9uIChyZW1vdGUsIHRoZW4pIHtcbiAgIGNvbnN0IHRhc2sgPSBwdXNoVGFnc1Rhc2soXG4gICAgICB7IHJlbW90ZTogZmlsdGVyVHlwZShyZW1vdGUsIGZpbHRlclN0cmluZykgfSxcbiAgICAgIGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpXG4gICApO1xuXG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayh0YXNrLCB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgdGhlIG5hbWVkIGZpbGVzIGZyb20gc291cmNlIGNvbnRyb2wuXG4gKi9cbkdpdC5wcm90b3R5cGUucm0gPSBmdW5jdGlvbiAoZmlsZXMpIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhbJ3JtJywgJy1mJywgLi4uYXNBcnJheShmaWxlcyldKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBuYW1lZCBmaWxlcyBmcm9tIHNvdXJjZSBjb250cm9sIGJ1dCBrZWVwcyB0aGVtIG9uIGRpc2sgcmF0aGVyIHRoYW4gZGVsZXRpbmcgdGhlbSBlbnRpcmVseS4gVG9cbiAqIGNvbXBsZXRlbHkgcmVtb3ZlIHRoZSBmaWxlcywgdXNlIGBybWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGZpbGVzXG4gKi9cbkdpdC5wcm90b3R5cGUucm1LZWVwTG9jYWwgPSBmdW5jdGlvbiAoZmlsZXMpIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhbJ3JtJywgJy0tY2FjaGVkJywgLi4uYXNBcnJheShmaWxlcyldKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdCBvZiBvYmplY3RzIGluIGEgdHJlZSBiYXNlZCBvbiBjb21taXQgaGFzaC4gUGFzc2luZyBpbiBhbiBvYmplY3QgaGFzaCByZXR1cm5zIHRoZSBvYmplY3QncyBjb250ZW50LFxuICogc2l6ZSwgYW5kIHR5cGUuXG4gKlxuICogUGFzc2luZyBcIi1wXCIgd2lsbCBpbnN0cnVjdCBjYXQtZmlsZSB0byBkZXRlcm1pbmUgdGhlIG9iamVjdCB0eXBlLCBhbmQgZGlzcGxheSBpdHMgZm9ybWF0dGVkIGNvbnRlbnRzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nW119IFtvcHRpb25zXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3RoZW5dXG4gKi9cbkdpdC5wcm90b3R5cGUuY2F0RmlsZSA9IGZ1bmN0aW9uIChvcHRpb25zLCB0aGVuKSB7XG4gICByZXR1cm4gdGhpcy5fY2F0RmlsZSgndXRmLTgnLCBhcmd1bWVudHMpO1xufTtcblxuR2l0LnByb3RvdHlwZS5iaW5hcnlDYXRGaWxlID0gZnVuY3Rpb24gKCkge1xuICAgcmV0dXJuIHRoaXMuX2NhdEZpbGUoJ2J1ZmZlcicsIGFyZ3VtZW50cyk7XG59O1xuXG5HaXQucHJvdG90eXBlLl9jYXRGaWxlID0gZnVuY3Rpb24gKGZvcm1hdCwgYXJncykge1xuICAgdmFyIGhhbmRsZXIgPSB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJncyk7XG4gICB2YXIgY29tbWFuZCA9IFsnY2F0LWZpbGUnXTtcbiAgIHZhciBvcHRpb25zID0gYXJnc1swXTtcblxuICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICBjb25maWd1cmF0aW9uRXJyb3JUYXNrKCdHaXQuY2F0RmlsZTogb3B0aW9ucyBtdXN0IGJlIHN1cHBsaWVkIGFzIGFuIGFycmF5IG9mIHN0cmluZ3MnKSxcbiAgICAgICAgIGhhbmRsZXJcbiAgICAgICk7XG4gICB9XG5cbiAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICBjb21tYW5kLnB1c2guYXBwbHkoY29tbWFuZCwgb3B0aW9ucyk7XG4gICB9XG5cbiAgIGNvbnN0IHRhc2sgPVxuICAgICAgZm9ybWF0ID09PSAnYnVmZmVyJyA/IHN0cmFpZ2h0VGhyb3VnaEJ1ZmZlclRhc2soY29tbWFuZCkgOiBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKGNvbW1hbmQpO1xuXG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayh0YXNrLCBoYW5kbGVyKTtcbn07XG5cbkdpdC5wcm90b3R5cGUuZGlmZiA9IGZ1bmN0aW9uIChvcHRpb25zLCB0aGVuKSB7XG4gICBjb25zdCB0YXNrID0gZmlsdGVyU3RyaW5nKG9wdGlvbnMpXG4gICAgICA/IGNvbmZpZ3VyYXRpb25FcnJvclRhc2soXG4gICAgICAgICAgICdnaXQuZGlmZjogc3VwcGx5aW5nIG9wdGlvbnMgYXMgYSBzaW5nbGUgc3RyaW5nIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQsIHN3aXRjaCB0byBhbiBhcnJheSBvZiBzdHJpbmdzJ1xuICAgICAgICApXG4gICAgICA6IHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soWydkaWZmJywgLi4uZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cyldKTtcblxuICAgcmV0dXJuIHRoaXMuX3J1blRhc2sodGFzaywgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cykpO1xufTtcblxuR2l0LnByb3RvdHlwZS5kaWZmU3VtbWFyeSA9IGZ1bmN0aW9uICgpIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgZGlmZlN1bW1hcnlUYXNrKGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMsIDEpKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxuR2l0LnByb3RvdHlwZS5hcHBseVBhdGNoID0gZnVuY3Rpb24gKHBhdGNoZXMpIHtcbiAgIGNvbnN0IHRhc2sgPSAhZmlsdGVyU3RyaW5nT3JTdHJpbmdBcnJheShwYXRjaGVzKVxuICAgICAgPyBjb25maWd1cmF0aW9uRXJyb3JUYXNrKFxuICAgICAgICAgICBgZ2l0LmFwcGx5UGF0Y2ggcmVxdWlyZXMgb25lIG9yIG1vcmUgc3RyaW5nIHBhdGNoZXMgYXMgdGhlIGZpcnN0IGFyZ3VtZW50YFxuICAgICAgICApXG4gICAgICA6IGFwcGx5UGF0Y2hUYXNrKGFzQXJyYXkocGF0Y2hlcyksIGdldFRyYWlsaW5nT3B0aW9ucyhbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpKTtcblxuICAgcmV0dXJuIHRoaXMuX3J1blRhc2sodGFzaywgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cykpO1xufTtcblxuR2l0LnByb3RvdHlwZS5yZXZwYXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgIGNvbnN0IGNvbW1hbmRzID0gWydyZXYtcGFyc2UnLCAuLi5nZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzLCB0cnVlKV07XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soY29tbWFuZHMsIHRydWUpLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG4vKipcbiAqL1xuR2l0LnByb3RvdHlwZS5jbGVhbiA9IGZ1bmN0aW9uIChtb2RlLCBvcHRpb25zLCB0aGVuKSB7XG4gICBjb25zdCB1c2luZ0NsZWFuT3B0aW9uc0FycmF5ID0gaXNDbGVhbk9wdGlvbnNBcnJheShtb2RlKTtcbiAgIGNvbnN0IGNsZWFuTW9kZSA9XG4gICAgICAodXNpbmdDbGVhbk9wdGlvbnNBcnJheSAmJiBtb2RlLmpvaW4oJycpKSB8fCBmaWx0ZXJUeXBlKG1vZGUsIGZpbHRlclN0cmluZykgfHwgJyc7XG4gICBjb25zdCBjdXN0b21BcmdzID0gZ2V0VHJhaWxpbmdPcHRpb25zKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCB1c2luZ0NsZWFuT3B0aW9uc0FycmF5ID8gMSA6IDApKTtcblxuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICBjbGVhbldpdGhPcHRpb25zVGFzayhjbGVhbk1vZGUsIGN1c3RvbUFyZ3MpLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG5HaXQucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbiAodGhlbikge1xuICAgY29uc3QgdGFzayA9IHtcbiAgICAgIGNvbW1hbmRzOiBbXSxcbiAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgIHBhcnNlcigpIHtcbiAgICAgICAgIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhlbigpO1xuICAgICAgICAgfVxuICAgICAgfSxcbiAgIH07XG5cbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKHRhc2spO1xufTtcblxuLyoqXG4gKiBDbGVhcnMgdGhlIHF1ZXVlIG9mIHBlbmRpbmcgY29tbWFuZHMgYW5kIHJldHVybnMgdGhlIHdyYXBwZXIgaW5zdGFuY2UgZm9yIGNoYWluaW5nLlxuICpcbiAqIEByZXR1cm5zIHtHaXR9XG4gKi9cbkdpdC5wcm90b3R5cGUuY2xlYXJRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgIC8vIFRPRE86XG4gICAvLyB0aGlzLl9leGVjdXRvci5jbGVhcigpO1xuICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGEgcGF0aG5hbWUgb3IgcGF0aG5hbWVzIGFyZSBleGNsdWRlZCBieSAuZ2l0aWdub3JlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHBhdGhuYW1lc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW3RoZW5dXG4gKi9cbkdpdC5wcm90b3R5cGUuY2hlY2tJZ25vcmUgPSBmdW5jdGlvbiAocGF0aG5hbWVzLCB0aGVuKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgIGNoZWNrSWdub3JlVGFzayhhc0FycmF5KGZpbHRlclR5cGUocGF0aG5hbWVzLCBmaWx0ZXJTdHJpbmdPclN0cmluZ0FycmF5LCBbXSkpKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxuR2l0LnByb3RvdHlwZS5jaGVja0lzUmVwbyA9IGZ1bmN0aW9uIChjaGVja1R5cGUsIHRoZW4pIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgY2hlY2tJc1JlcG9UYXNrKGZpbHRlclR5cGUoY2hlY2tUeXBlLCBmaWx0ZXJTdHJpbmcpKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHaXQ7XG4iLCAiaW1wb3J0IHsgcGF0aHNwZWMgfSBmcm9tICcuL2FyZ3MvcGF0aHNwZWMnO1xuaW1wb3J0IHsgR2l0Q29uc3RydWN0RXJyb3IgfSBmcm9tICcuL2Vycm9ycy9naXQtY29uc3RydWN0LWVycm9yJztcbmltcG9ydCB7IEdpdEVycm9yIH0gZnJvbSAnLi9lcnJvcnMvZ2l0LWVycm9yJztcbmltcG9ydCB7IEdpdFBsdWdpbkVycm9yIH0gZnJvbSAnLi9lcnJvcnMvZ2l0LXBsdWdpbi1lcnJvcic7XG5pbXBvcnQgeyBHaXRSZXNwb25zZUVycm9yIH0gZnJvbSAnLi9lcnJvcnMvZ2l0LXJlc3BvbnNlLWVycm9yJztcbmltcG9ydCB7IFRhc2tDb25maWd1cmF0aW9uRXJyb3IgfSBmcm9tICcuL2Vycm9ycy90YXNrLWNvbmZpZ3VyYXRpb24tZXJyb3InO1xuaW1wb3J0IHsgQ2hlY2tSZXBvQWN0aW9ucyB9IGZyb20gJy4vdGFza3MvY2hlY2staXMtcmVwbyc7XG5pbXBvcnQgeyBDbGVhbk9wdGlvbnMgfSBmcm9tICcuL3Rhc2tzL2NsZWFuJztcbmltcG9ydCB7IEdpdENvbmZpZ1Njb3BlIH0gZnJvbSAnLi90YXNrcy9jb25maWcnO1xuaW1wb3J0IHsgRGlmZk5hbWVTdGF0dXMgfSBmcm9tICcuL3Rhc2tzL2RpZmYtbmFtZS1zdGF0dXMnO1xuaW1wb3J0IHsgZ3JlcFF1ZXJ5QnVpbGRlciB9IGZyb20gJy4vdGFza3MvZ3JlcCc7XG5pbXBvcnQgeyBSZXNldE1vZGUgfSBmcm9tICcuL3Rhc2tzL3Jlc2V0JztcblxuZXhwb3J0IHtcbiAgIENoZWNrUmVwb0FjdGlvbnMsXG4gICBDbGVhbk9wdGlvbnMsXG4gICBEaWZmTmFtZVN0YXR1cyxcbiAgIEdpdENvbmZpZ1Njb3BlLFxuICAgR2l0Q29uc3RydWN0RXJyb3IsXG4gICBHaXRFcnJvcixcbiAgIEdpdFBsdWdpbkVycm9yLFxuICAgR2l0UmVzcG9uc2VFcnJvcixcbiAgIFJlc2V0TW9kZSxcbiAgIFRhc2tDb25maWd1cmF0aW9uRXJyb3IsXG4gICBncmVwUXVlcnlCdWlsZGVyLFxuICAgcGF0aHNwZWMsXG59O1xuIiwgImltcG9ydCB7IEdpdEVycm9yIH0gZnJvbSAnLi9naXQtZXJyb3InO1xuaW1wb3J0IHsgU2ltcGxlR2l0T3B0aW9ucyB9IGZyb20gJy4uL3R5cGVzJztcblxuLyoqXG4gKiBUaGUgYEdpdENvbnN0cnVjdEVycm9yYCBpcyB0aHJvd24gd2hlbiBhbiBlcnJvciBvY2N1cnMgaW4gdGhlIGNvbnN0cnVjdG9yXG4gKiBvZiB0aGUgYHNpbXBsZS1naXRgIGluc3RhbmNlIGl0c2VsZi4gTW9zdCBjb21tb25seSBhcyBhIHJlc3VsdCBvZiB1c2luZ1xuICogYSBgYmFzZURpcmAgb3B0aW9uIHRoYXQgcG9pbnRzIHRvIGEgZm9sZGVyIHRoYXQgZWl0aGVyIGRvZXMgbm90IGV4aXN0LFxuICogb3IgY2Fubm90IGJlIHJlYWQgYnkgdGhlIHVzZXIgdGhlIG5vZGUgc2NyaXB0IGlzIHJ1bm5pbmcgYXMuXG4gKlxuICogQ2hlY2sgdGhlIGAubWVzc2FnZWAgcHJvcGVydHkgZm9yIG1vcmUgZGV0YWlsIGluY2x1ZGluZyB0aGUgcHJvcGVydGllc1xuICogcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAqL1xuZXhwb3J0IGNsYXNzIEdpdENvbnN0cnVjdEVycm9yIGV4dGVuZHMgR2l0RXJyb3Ige1xuICAgY29uc3RydWN0b3IoXG4gICAgICBwdWJsaWMgcmVhZG9ubHkgY29uZmlnOiBTaW1wbGVHaXRPcHRpb25zLFxuICAgICAgbWVzc2FnZTogc3RyaW5nXG4gICApIHtcbiAgICAgIHN1cGVyKHVuZGVmaW5lZCwgbWVzc2FnZSk7XG4gICB9XG59XG4iLCAiaW1wb3J0IHsgU2ltcGxlR2l0T3B0aW9ucywgU2ltcGxlR2l0VGFzayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IEdpdEVycm9yIH0gZnJvbSAnLi9naXQtZXJyb3InO1xuXG5leHBvcnQgY2xhc3MgR2l0UGx1Z2luRXJyb3IgZXh0ZW5kcyBHaXRFcnJvciB7XG4gICBjb25zdHJ1Y3RvcihcbiAgICAgIHB1YmxpYyB0YXNrPzogU2ltcGxlR2l0VGFzazxhbnk+LFxuICAgICAgcHVibGljIHJlYWRvbmx5IHBsdWdpbj86IGtleW9mIFNpbXBsZUdpdE9wdGlvbnMsXG4gICAgICBtZXNzYWdlPzogc3RyaW5nXG4gICApIHtcbiAgICAgIHN1cGVyKHRhc2ssIG1lc3NhZ2UpO1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTtcbiAgIH1cbn1cbiIsICJpbXBvcnQgeyBTaW1wbGVHaXRPcHRpb25zIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgU2ltcGxlR2l0UGx1Z2luIH0gZnJvbSAnLi9zaW1wbGUtZ2l0LXBsdWdpbic7XG5pbXBvcnQgeyBHaXRQbHVnaW5FcnJvciB9IGZyb20gJy4uL2Vycm9ycy9naXQtcGx1Z2luLWVycm9yJztcblxuZXhwb3J0IGZ1bmN0aW9uIGFib3J0UGx1Z2luKHNpZ25hbDogU2ltcGxlR2l0T3B0aW9uc1snYWJvcnQnXSkge1xuICAgaWYgKCFzaWduYWwpIHtcbiAgICAgIHJldHVybjtcbiAgIH1cblxuICAgY29uc3Qgb25TcGF3bkFmdGVyOiBTaW1wbGVHaXRQbHVnaW48J3NwYXduLmFmdGVyJz4gPSB7XG4gICAgICB0eXBlOiAnc3Bhd24uYWZ0ZXInLFxuICAgICAgYWN0aW9uKF9kYXRhLCBjb250ZXh0KSB7XG4gICAgICAgICBmdW5jdGlvbiBraWxsKCkge1xuICAgICAgICAgICAgY29udGV4dC5raWxsKG5ldyBHaXRQbHVnaW5FcnJvcih1bmRlZmluZWQsICdhYm9ydCcsICdBYm9ydCBzaWduYWwgcmVjZWl2ZWQnKSk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGtpbGwpO1xuXG4gICAgICAgICBjb250ZXh0LnNwYXduZWQub24oJ2Nsb3NlJywgKCkgPT4gc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywga2lsbCkpO1xuICAgICAgfSxcbiAgIH07XG5cbiAgIGNvbnN0IG9uU3Bhd25CZWZvcmU6IFNpbXBsZUdpdFBsdWdpbjwnc3Bhd24uYmVmb3JlJz4gPSB7XG4gICAgICB0eXBlOiAnc3Bhd24uYmVmb3JlJyxcbiAgICAgIGFjdGlvbihfZGF0YSwgY29udGV4dCkge1xuICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICBjb250ZXh0LmtpbGwobmV3IEdpdFBsdWdpbkVycm9yKHVuZGVmaW5lZCwgJ2Fib3J0JywgJ0Fib3J0IGFscmVhZHkgc2lnbmFsZWQnKSk7XG4gICAgICAgICB9XG4gICAgICB9LFxuICAgfTtcblxuICAgcmV0dXJuIFtvblNwYXduQmVmb3JlLCBvblNwYXduQWZ0ZXJdO1xufVxuIiwgImltcG9ydCB0eXBlIHsgU2ltcGxlR2l0UGx1Z2luIH0gZnJvbSAnLi9zaW1wbGUtZ2l0LXBsdWdpbic7XG5cbmltcG9ydCB7IEdpdFBsdWdpbkVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL2dpdC1wbHVnaW4tZXJyb3InO1xuaW1wb3J0IHR5cGUgeyBTaW1wbGVHaXRQbHVnaW5Db25maWcgfSBmcm9tICcuLi90eXBlcyc7XG5cbmZ1bmN0aW9uIGlzQ29uZmlnU3dpdGNoKGFyZzogc3RyaW5nIHwgdW5rbm93bikge1xuICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnICYmIGFyZy50cmltKCkudG9Mb3dlckNhc2UoKSA9PT0gJy1jJztcbn1cblxuZnVuY3Rpb24gcHJldmVudFByb3RvY29sT3ZlcnJpZGUoYXJnOiBzdHJpbmcsIG5leHQ6IHN0cmluZykge1xuICAgaWYgKCFpc0NvbmZpZ1N3aXRjaChhcmcpKSB7XG4gICAgICByZXR1cm47XG4gICB9XG5cbiAgIGlmICghL15cXHMqcHJvdG9jb2woLlthLXpdKyk/LmFsbG93Ly50ZXN0KG5leHQpKSB7XG4gICAgICByZXR1cm47XG4gICB9XG5cbiAgIHRocm93IG5ldyBHaXRQbHVnaW5FcnJvcihcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgICd1bnNhZmUnLFxuICAgICAgJ0NvbmZpZ3VyaW5nIHByb3RvY29sLmFsbG93IGlzIG5vdCBwZXJtaXR0ZWQgd2l0aG91dCBlbmFibGluZyBhbGxvd1Vuc2FmZUV4dFByb3RvY29sJ1xuICAgKTtcbn1cblxuZnVuY3Rpb24gcHJldmVudFVwbG9hZFBhY2soYXJnOiBzdHJpbmcsIG1ldGhvZDogc3RyaW5nKSB7XG4gICBpZiAoL15cXHMqLS0odXBsb2FkfHJlY2VpdmUpLXBhY2svLnRlc3QoYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IEdpdFBsdWdpbkVycm9yKFxuICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgJ3Vuc2FmZScsXG4gICAgICAgICBgVXNlIG9mIC0tdXBsb2FkLXBhY2sgb3IgLS1yZWNlaXZlLXBhY2sgaXMgbm90IHBlcm1pdHRlZCB3aXRob3V0IGVuYWJsaW5nIGFsbG93VW5zYWZlUGFja2BcbiAgICAgICk7XG4gICB9XG5cbiAgIGlmIChtZXRob2QgPT09ICdjbG9uZScgJiYgL15cXHMqLXVcXGIvLnRlc3QoYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IEdpdFBsdWdpbkVycm9yKFxuICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgJ3Vuc2FmZScsXG4gICAgICAgICBgVXNlIG9mIGNsb25lIHdpdGggb3B0aW9uIC11IGlzIG5vdCBwZXJtaXR0ZWQgd2l0aG91dCBlbmFibGluZyBhbGxvd1Vuc2FmZVBhY2tgXG4gICAgICApO1xuICAgfVxuXG4gICBpZiAobWV0aG9kID09PSAncHVzaCcgJiYgL15cXHMqLS1leGVjXFxiLy50ZXN0KGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBHaXRQbHVnaW5FcnJvcihcbiAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICd1bnNhZmUnLFxuICAgICAgICAgYFVzZSBvZiBwdXNoIHdpdGggb3B0aW9uIC0tZXhlYyBpcyBub3QgcGVybWl0dGVkIHdpdGhvdXQgZW5hYmxpbmcgYWxsb3dVbnNhZmVQYWNrYFxuICAgICAgKTtcbiAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJsb2NrVW5zYWZlT3BlcmF0aW9uc1BsdWdpbih7XG4gICBhbGxvd1Vuc2FmZVByb3RvY29sT3ZlcnJpZGUgPSBmYWxzZSxcbiAgIGFsbG93VW5zYWZlUGFjayA9IGZhbHNlLFxufTogU2ltcGxlR2l0UGx1Z2luQ29uZmlnWyd1bnNhZmUnXSA9IHt9KTogU2ltcGxlR2l0UGx1Z2luPCdzcGF3bi5hcmdzJz4ge1xuICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdzcGF3bi5hcmdzJyxcbiAgICAgIGFjdGlvbihhcmdzLCBjb250ZXh0KSB7XG4gICAgICAgICBhcmdzLmZvckVhY2goKGN1cnJlbnQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gaW5kZXggPCBhcmdzLmxlbmd0aCA/IGFyZ3NbaW5kZXggKyAxXSA6ICcnO1xuXG4gICAgICAgICAgICBhbGxvd1Vuc2FmZVByb3RvY29sT3ZlcnJpZGUgfHwgcHJldmVudFByb3RvY29sT3ZlcnJpZGUoY3VycmVudCwgbmV4dCk7XG4gICAgICAgICAgICBhbGxvd1Vuc2FmZVBhY2sgfHwgcHJldmVudFVwbG9hZFBhY2soY3VycmVudCwgY29udGV4dC5tZXRob2QpO1xuICAgICAgICAgfSk7XG5cbiAgICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgfSxcbiAgIH07XG59XG4iLCAiaW1wb3J0IHsgcHJlZml4ZWRBcnJheSB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IFNpbXBsZUdpdFBsdWdpbiB9IGZyb20gJy4vc2ltcGxlLWdpdC1wbHVnaW4nO1xuXG5leHBvcnQgZnVuY3Rpb24gY29tbWFuZENvbmZpZ1ByZWZpeGluZ1BsdWdpbihcbiAgIGNvbmZpZ3VyYXRpb246IHN0cmluZ1tdXG4pOiBTaW1wbGVHaXRQbHVnaW48J3NwYXduLmFyZ3MnPiB7XG4gICBjb25zdCBwcmVmaXggPSBwcmVmaXhlZEFycmF5KGNvbmZpZ3VyYXRpb24sICctYycpO1xuXG4gICByZXR1cm4ge1xuICAgICAgdHlwZTogJ3NwYXduLmFyZ3MnLFxuICAgICAgYWN0aW9uKGRhdGEpIHtcbiAgICAgICAgIHJldHVybiBbLi4ucHJlZml4LCAuLi5kYXRhXTtcbiAgICAgIH0sXG4gICB9O1xufVxuIiwgImltcG9ydCB7IGRlZmVycmVkLCBEZWZlcnJlZFByb21pc2UgfSBmcm9tICdAa3dzaXRlcy9wcm9taXNlLWRlZmVycmVkJztcbmltcG9ydCB7IFNpbXBsZUdpdFBsdWdpbkNvbmZpZyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGRlbGF5IH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgU2ltcGxlR2l0UGx1Z2luIH0gZnJvbSAnLi9zaW1wbGUtZ2l0LXBsdWdpbic7XG5cbmNvbnN0IG5ldmVyID0gZGVmZXJyZWQoKS5wcm9taXNlO1xuXG5leHBvcnQgZnVuY3Rpb24gY29tcGxldGlvbkRldGVjdGlvblBsdWdpbih7XG4gICBvbkNsb3NlID0gdHJ1ZSxcbiAgIG9uRXhpdCA9IDUwLFxufTogU2ltcGxlR2l0UGx1Z2luQ29uZmlnWydjb21wbGV0aW9uJ10gPSB7fSk6IFNpbXBsZUdpdFBsdWdpbjwnc3Bhd24uYWZ0ZXInPiB7XG4gICBmdW5jdGlvbiBjcmVhdGVFdmVudHMoKSB7XG4gICAgICBsZXQgZXhpdENvZGUgPSAtMTtcbiAgICAgIGNvbnN0IGV2ZW50cyA9IHtcbiAgICAgICAgIGNsb3NlOiBkZWZlcnJlZCgpLFxuICAgICAgICAgY2xvc2VUaW1lb3V0OiBkZWZlcnJlZCgpLFxuICAgICAgICAgZXhpdDogZGVmZXJyZWQoKSxcbiAgICAgICAgIGV4aXRUaW1lb3V0OiBkZWZlcnJlZCgpLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgIG9uQ2xvc2UgPT09IGZhbHNlID8gbmV2ZXIgOiBldmVudHMuY2xvc2VUaW1lb3V0LnByb21pc2UsXG4gICAgICAgICBvbkV4aXQgPT09IGZhbHNlID8gbmV2ZXIgOiBldmVudHMuZXhpdFRpbWVvdXQucHJvbWlzZSxcbiAgICAgIF0pO1xuXG4gICAgICBjb25maWd1cmVUaW1lb3V0KG9uQ2xvc2UsIGV2ZW50cy5jbG9zZSwgZXZlbnRzLmNsb3NlVGltZW91dCk7XG4gICAgICBjb25maWd1cmVUaW1lb3V0KG9uRXhpdCwgZXZlbnRzLmV4aXQsIGV2ZW50cy5leGl0VGltZW91dCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgICBjbG9zZShjb2RlOiBudW1iZXIpIHtcbiAgICAgICAgICAgIGV4aXRDb2RlID0gY29kZTtcbiAgICAgICAgICAgIGV2ZW50cy5jbG9zZS5kb25lKCk7XG4gICAgICAgICB9LFxuICAgICAgICAgZXhpdChjb2RlOiBudW1iZXIpIHtcbiAgICAgICAgICAgIGV4aXRDb2RlID0gY29kZTtcbiAgICAgICAgICAgIGV2ZW50cy5leGl0LmRvbmUoKTtcbiAgICAgICAgIH0sXG4gICAgICAgICBnZXQgZXhpdENvZGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhpdENvZGU7XG4gICAgICAgICB9LFxuICAgICAgICAgcmVzdWx0LFxuICAgICAgfTtcbiAgIH1cblxuICAgZnVuY3Rpb24gY29uZmlndXJlVGltZW91dChcbiAgICAgIGZsYWc6IGJvb2xlYW4gfCBudW1iZXIsXG4gICAgICBldmVudDogRGVmZXJyZWRQcm9taXNlPHZvaWQ+LFxuICAgICAgdGltZW91dDogRGVmZXJyZWRQcm9taXNlPHZvaWQ+XG4gICApIHtcbiAgICAgIGlmIChmbGFnID09PSBmYWxzZSkge1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAoZmxhZyA9PT0gdHJ1ZSA/IGV2ZW50LnByb21pc2UgOiBldmVudC5wcm9taXNlLnRoZW4oKCkgPT4gZGVsYXkoZmxhZykpKS50aGVuKHRpbWVvdXQuZG9uZSk7XG4gICB9XG5cbiAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnc3Bhd24uYWZ0ZXInLFxuICAgICAgYXN5bmMgYWN0aW9uKF9kYXRhLCB7IHNwYXduZWQsIGNsb3NlIH0pIHtcbiAgICAgICAgIGNvbnN0IGV2ZW50cyA9IGNyZWF0ZUV2ZW50cygpO1xuXG4gICAgICAgICBsZXQgZGVmZXJDbG9zZSA9IHRydWU7XG4gICAgICAgICBsZXQgcXVpY2tDbG9zZSA9ICgpID0+IHZvaWQgKGRlZmVyQ2xvc2UgPSBmYWxzZSk7XG5cbiAgICAgICAgIHNwYXduZWQuc3Rkb3V0Py5vbignZGF0YScsIHF1aWNrQ2xvc2UpO1xuICAgICAgICAgc3Bhd25lZC5zdGRlcnI/Lm9uKCdkYXRhJywgcXVpY2tDbG9zZSk7XG4gICAgICAgICBzcGF3bmVkLm9uKCdlcnJvcicsIHF1aWNrQ2xvc2UpO1xuXG4gICAgICAgICBzcGF3bmVkLm9uKCdjbG9zZScsIChjb2RlOiBudW1iZXIpID0+IGV2ZW50cy5jbG9zZShjb2RlKSk7XG4gICAgICAgICBzcGF3bmVkLm9uKCdleGl0JywgKGNvZGU6IG51bWJlcikgPT4gZXZlbnRzLmV4aXQoY29kZSkpO1xuXG4gICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgZXZlbnRzLnJlc3VsdDtcbiAgICAgICAgICAgIGlmIChkZWZlckNsb3NlKSB7XG4gICAgICAgICAgICAgICBhd2FpdCBkZWxheSg1MCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbG9zZShldmVudHMuZXhpdENvZGUpO1xuICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjbG9zZShldmVudHMuZXhpdENvZGUsIGVyciBhcyBFcnJvcik7XG4gICAgICAgICB9XG4gICAgICB9LFxuICAgfTtcbn1cbiIsICJpbXBvcnQgeyBHaXRFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9naXQtZXJyb3InO1xuaW1wb3J0IHsgR2l0RXhlY3V0b3JSZXN1bHQsIFNpbXBsZUdpdFBsdWdpbkNvbmZpZyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IFNpbXBsZUdpdFBsdWdpbiB9IGZyb20gJy4vc2ltcGxlLWdpdC1wbHVnaW4nO1xuXG50eXBlIFRhc2tSZXN1bHQgPSBPbWl0PEdpdEV4ZWN1dG9yUmVzdWx0LCAncmVqZWN0aW9uJz47XG5cbmZ1bmN0aW9uIGlzVGFza0Vycm9yKHJlc3VsdDogVGFza1Jlc3VsdCkge1xuICAgcmV0dXJuICEhKHJlc3VsdC5leGl0Q29kZSAmJiByZXN1bHQuc3RkRXJyLmxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZShyZXN1bHQ6IFRhc2tSZXN1bHQpIHtcbiAgIHJldHVybiBCdWZmZXIuY29uY2F0KFsuLi5yZXN1bHQuc3RkT3V0LCAuLi5yZXN1bHQuc3RkRXJyXSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcnJvckRldGVjdGlvbkhhbmRsZXIoXG4gICBvdmVyd3JpdGUgPSBmYWxzZSxcbiAgIGlzRXJyb3IgPSBpc1Rhc2tFcnJvcixcbiAgIGVycm9yTWVzc2FnZTogKHJlc3VsdDogVGFza1Jlc3VsdCkgPT4gQnVmZmVyIHwgRXJyb3IgPSBnZXRFcnJvck1lc3NhZ2Vcbikge1xuICAgcmV0dXJuIChlcnJvcjogQnVmZmVyIHwgRXJyb3IgfCB1bmRlZmluZWQsIHJlc3VsdDogVGFza1Jlc3VsdCkgPT4ge1xuICAgICAgaWYgKCghb3ZlcndyaXRlICYmIGVycm9yKSB8fCAhaXNFcnJvcihyZXN1bHQpKSB7XG4gICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlcnJvck1lc3NhZ2UocmVzdWx0KTtcbiAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcnJvckRldGVjdGlvblBsdWdpbihcbiAgIGNvbmZpZzogU2ltcGxlR2l0UGx1Z2luQ29uZmlnWydlcnJvcnMnXVxuKTogU2ltcGxlR2l0UGx1Z2luPCd0YXNrLmVycm9yJz4ge1xuICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICd0YXNrLmVycm9yJyxcbiAgICAgIGFjdGlvbihkYXRhLCBjb250ZXh0KSB7XG4gICAgICAgICBjb25zdCBlcnJvciA9IGNvbmZpZyhkYXRhLmVycm9yLCB7XG4gICAgICAgICAgICBzdGRFcnI6IGNvbnRleHQuc3RkRXJyLFxuICAgICAgICAgICAgc3RkT3V0OiBjb250ZXh0LnN0ZE91dCxcbiAgICAgICAgICAgIGV4aXRDb2RlOiBjb250ZXh0LmV4aXRDb2RlLFxuICAgICAgICAgfSk7XG5cbiAgICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoZXJyb3IpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcjogbmV3IEdpdEVycm9yKHVuZGVmaW5lZCwgZXJyb3IudG9TdHJpbmcoJ3V0Zi04JykpIH07XG4gICAgICAgICB9XG5cbiAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgIH07XG4gICAgICB9LFxuICAgfTtcbn1cbiIsICJpbXBvcnQgeyBTaW1wbGVHaXRQbHVnaW4sIFNpbXBsZUdpdFBsdWdpblR5cGUsIFNpbXBsZUdpdFBsdWdpblR5cGVzIH0gZnJvbSAnLi9zaW1wbGUtZ2l0LXBsdWdpbic7XG5pbXBvcnQgeyBhcHBlbmQsIGFzQXJyYXkgfSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBjbGFzcyBQbHVnaW5TdG9yZSB7XG4gICBwcml2YXRlIHBsdWdpbnM6IFNldDxTaW1wbGVHaXRQbHVnaW48U2ltcGxlR2l0UGx1Z2luVHlwZT4+ID0gbmV3IFNldCgpO1xuXG4gICBwdWJsaWMgYWRkPFQgZXh0ZW5kcyBTaW1wbGVHaXRQbHVnaW5UeXBlPihcbiAgICAgIHBsdWdpbjogdm9pZCB8IFNpbXBsZUdpdFBsdWdpbjxUPiB8IFNpbXBsZUdpdFBsdWdpbjxUPltdXG4gICApIHtcbiAgICAgIGNvbnN0IHBsdWdpbnM6IFNpbXBsZUdpdFBsdWdpbjxUPltdID0gW107XG5cbiAgICAgIGFzQXJyYXkocGx1Z2luKS5mb3JFYWNoKChwbHVnaW4pID0+IHBsdWdpbiAmJiB0aGlzLnBsdWdpbnMuYWRkKGFwcGVuZChwbHVnaW5zLCBwbHVnaW4pKSk7XG5cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICBwbHVnaW5zLmZvckVhY2goKHBsdWdpbikgPT4gdGhpcy5wbHVnaW5zLmRlbGV0ZShwbHVnaW4pKTtcbiAgICAgIH07XG4gICB9XG5cbiAgIHB1YmxpYyBleGVjPFQgZXh0ZW5kcyBTaW1wbGVHaXRQbHVnaW5UeXBlPihcbiAgICAgIHR5cGU6IFQsXG4gICAgICBkYXRhOiBTaW1wbGVHaXRQbHVnaW5UeXBlc1tUXVsnZGF0YSddLFxuICAgICAgY29udGV4dDogU2ltcGxlR2l0UGx1Z2luVHlwZXNbVF1bJ2NvbnRleHQnXVxuICAgKTogdHlwZW9mIGRhdGEge1xuICAgICAgbGV0IG91dHB1dCA9IGRhdGE7XG4gICAgICBjb25zdCBjb250ZXh0dWFsID0gT2JqZWN0LmZyZWV6ZShPYmplY3QuY3JlYXRlKGNvbnRleHQpKTtcblxuICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKSB7XG4gICAgICAgICBpZiAocGx1Z2luLnR5cGUgPT09IHR5cGUpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IHBsdWdpbi5hY3Rpb24ob3V0cHV0LCBjb250ZXh0dWFsKTtcbiAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgIH1cbn1cbiIsICJpbXBvcnQgeyBTaW1wbGVHaXRPcHRpb25zIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgYXNOdW1iZXIsIGluY2x1ZGluZyB9IGZyb20gJy4uL3V0aWxzJztcblxuaW1wb3J0IHsgU2ltcGxlR2l0UGx1Z2luIH0gZnJvbSAnLi9zaW1wbGUtZ2l0LXBsdWdpbic7XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9ncmVzc01vbml0b3JQbHVnaW4ocHJvZ3Jlc3M6IEV4Y2x1ZGU8U2ltcGxlR2l0T3B0aW9uc1sncHJvZ3Jlc3MnXSwgdm9pZD4pIHtcbiAgIGNvbnN0IHByb2dyZXNzQ29tbWFuZCA9ICctLXByb2dyZXNzJztcbiAgIGNvbnN0IHByb2dyZXNzTWV0aG9kcyA9IFsnY2hlY2tvdXQnLCAnY2xvbmUnLCAnZmV0Y2gnLCAncHVsbCcsICdwdXNoJ107XG5cbiAgIGNvbnN0IG9uUHJvZ3Jlc3M6IFNpbXBsZUdpdFBsdWdpbjwnc3Bhd24uYWZ0ZXInPiA9IHtcbiAgICAgIHR5cGU6ICdzcGF3bi5hZnRlcicsXG4gICAgICBhY3Rpb24oX2RhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgIGlmICghY29udGV4dC5jb21tYW5kcy5pbmNsdWRlcyhwcm9ncmVzc0NvbW1hbmQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICB9XG5cbiAgICAgICAgIGNvbnRleHQuc3Bhd25lZC5zdGRlcnI/Lm9uKCdkYXRhJywgKGNodW5rOiBCdWZmZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAvXihbXFxzXFxTXSs/KTpcXHMqKFxcZCspJSBcXCgoXFxkKylcXC8oXFxkKylcXCkvLmV4ZWMoY2h1bmsudG9TdHJpbmcoJ3V0ZjgnKSk7XG4gICAgICAgICAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJvZ3Jlc3Moe1xuICAgICAgICAgICAgICAgbWV0aG9kOiBjb250ZXh0Lm1ldGhvZCxcbiAgICAgICAgICAgICAgIHN0YWdlOiBwcm9ncmVzc0V2ZW50U3RhZ2UobWVzc2FnZVsxXSksXG4gICAgICAgICAgICAgICBwcm9ncmVzczogYXNOdW1iZXIobWVzc2FnZVsyXSksXG4gICAgICAgICAgICAgICBwcm9jZXNzZWQ6IGFzTnVtYmVyKG1lc3NhZ2VbM10pLFxuICAgICAgICAgICAgICAgdG90YWw6IGFzTnVtYmVyKG1lc3NhZ2VbNF0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICB9KTtcbiAgICAgIH0sXG4gICB9O1xuXG4gICBjb25zdCBvbkFyZ3M6IFNpbXBsZUdpdFBsdWdpbjwnc3Bhd24uYXJncyc+ID0ge1xuICAgICAgdHlwZTogJ3NwYXduLmFyZ3MnLFxuICAgICAgYWN0aW9uKGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgICAgIGlmICghcHJvZ3Jlc3NNZXRob2RzLmluY2x1ZGVzKGNvbnRleHQubWV0aG9kKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHJldHVybiBpbmNsdWRpbmcoYXJncywgcHJvZ3Jlc3NDb21tYW5kKTtcbiAgICAgIH0sXG4gICB9O1xuXG4gICByZXR1cm4gW29uQXJncywgb25Qcm9ncmVzc107XG59XG5cbmZ1bmN0aW9uIHByb2dyZXNzRXZlbnRTdGFnZShpbnB1dDogc3RyaW5nKSB7XG4gICByZXR1cm4gU3RyaW5nKGlucHV0LnRvTG93ZXJDYXNlKCkuc3BsaXQoJyAnLCAxKSkgfHwgJ3Vua25vd24nO1xufVxuIiwgImltcG9ydCB7IFNwYXduT3B0aW9ucyB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IHsgcGljayB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IFNpbXBsZUdpdFBsdWdpbiB9IGZyb20gJy4vc2ltcGxlLWdpdC1wbHVnaW4nO1xuXG5leHBvcnQgZnVuY3Rpb24gc3Bhd25PcHRpb25zUGx1Z2luKFxuICAgc3Bhd25PcHRpb25zOiBQYXJ0aWFsPFNwYXduT3B0aW9ucz5cbik6IFNpbXBsZUdpdFBsdWdpbjwnc3Bhd24ub3B0aW9ucyc+IHtcbiAgIGNvbnN0IG9wdGlvbnMgPSBwaWNrKHNwYXduT3B0aW9ucywgWyd1aWQnLCAnZ2lkJ10pO1xuXG4gICByZXR1cm4ge1xuICAgICAgdHlwZTogJ3NwYXduLm9wdGlvbnMnLFxuICAgICAgYWN0aW9uKGRhdGEpIHtcbiAgICAgICAgIHJldHVybiB7IC4uLm9wdGlvbnMsIC4uLmRhdGEgfTtcbiAgICAgIH0sXG4gICB9O1xufVxuIiwgImltcG9ydCB0eXBlIHsgU2ltcGxlR2l0UGx1Z2luIH0gZnJvbSAnLi9zaW1wbGUtZ2l0LXBsdWdpbic7XG5cbmltcG9ydCB0eXBlIHsgU2ltcGxlR2l0T3B0aW9ucyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IEdpdFBsdWdpbkVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL2dpdC1wbHVnaW4tZXJyb3InO1xuXG5leHBvcnQgZnVuY3Rpb24gdGltZW91dFBsdWdpbih7XG4gICBibG9jayxcbiAgIHN0ZEVyciA9IHRydWUsXG4gICBzdGRPdXQgPSB0cnVlLFxufTogRXhjbHVkZTxTaW1wbGVHaXRPcHRpb25zWyd0aW1lb3V0J10sIHVuZGVmaW5lZD4pOiBTaW1wbGVHaXRQbHVnaW48J3NwYXduLmFmdGVyJz4gfCB2b2lkIHtcbiAgIGlmIChibG9jayA+IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICB0eXBlOiAnc3Bhd24uYWZ0ZXInLFxuICAgICAgICAgYWN0aW9uKF9kYXRhLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBsZXQgdGltZW91dDogTm9kZUpTLlRpbWVvdXQ7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHdhaXQoKSB7XG4gICAgICAgICAgICAgICB0aW1lb3V0ICYmIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGtpbGwsIGJsb2NrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgICAgICAgIGNvbnRleHQuc3Bhd25lZC5zdGRvdXQ/Lm9mZignZGF0YScsIHdhaXQpO1xuICAgICAgICAgICAgICAgY29udGV4dC5zcGF3bmVkLnN0ZGVycj8ub2ZmKCdkYXRhJywgd2FpdCk7XG4gICAgICAgICAgICAgICBjb250ZXh0LnNwYXduZWQub2ZmKCdleGl0Jywgc3RvcCk7XG4gICAgICAgICAgICAgICBjb250ZXh0LnNwYXduZWQub2ZmKCdjbG9zZScsIHN0b3ApO1xuICAgICAgICAgICAgICAgdGltZW91dCAmJiBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGtpbGwoKSB7XG4gICAgICAgICAgICAgICBzdG9wKCk7XG4gICAgICAgICAgICAgICBjb250ZXh0LmtpbGwobmV3IEdpdFBsdWdpbkVycm9yKHVuZGVmaW5lZCwgJ3RpbWVvdXQnLCBgYmxvY2sgdGltZW91dCByZWFjaGVkYCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGRPdXQgJiYgY29udGV4dC5zcGF3bmVkLnN0ZG91dD8ub24oJ2RhdGEnLCB3YWl0KTtcbiAgICAgICAgICAgIHN0ZEVyciAmJiBjb250ZXh0LnNwYXduZWQuc3RkZXJyPy5vbignZGF0YScsIHdhaXQpO1xuICAgICAgICAgICAgY29udGV4dC5zcGF3bmVkLm9uKCdleGl0Jywgc3RvcCk7XG4gICAgICAgICAgICBjb250ZXh0LnNwYXduZWQub24oJ2Nsb3NlJywgc3RvcCk7XG5cbiAgICAgICAgICAgIHdhaXQoKTtcbiAgICAgICAgIH0sXG4gICAgICB9O1xuICAgfVxufVxuIiwgImltcG9ydCB7IFNpbXBsZUdpdFBsdWdpbiB9IGZyb20gJy4vc2ltcGxlLWdpdC1wbHVnaW4nO1xuaW1wb3J0IHsgaXNQYXRoU3BlYywgdG9QYXRocyB9IGZyb20gJy4uL2FyZ3MvcGF0aHNwZWMnO1xuXG5leHBvcnQgZnVuY3Rpb24gc3VmZml4UGF0aHNQbHVnaW4oKTogU2ltcGxlR2l0UGx1Z2luPCdzcGF3bi5hcmdzJz4ge1xuICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdzcGF3bi5hcmdzJyxcbiAgICAgIGFjdGlvbihkYXRhKSB7XG4gICAgICAgICBjb25zdCBwcmVmaXg6IHN0cmluZ1tdID0gW107XG4gICAgICAgICBsZXQgc3VmZml4OiB1bmRlZmluZWQgfCBzdHJpbmdbXTtcbiAgICAgICAgIGZ1bmN0aW9uIGFwcGVuZChhcmdzOiBzdHJpbmdbXSkge1xuICAgICAgICAgICAgKHN1ZmZpeCA9IHN1ZmZpeCB8fCBbXSkucHVzaCguLi5hcmdzKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbSA9IGRhdGFbaV07XG5cbiAgICAgICAgICAgIGlmIChpc1BhdGhTcGVjKHBhcmFtKSkge1xuICAgICAgICAgICAgICAgYXBwZW5kKHRvUGF0aHMocGFyYW0pKTtcbiAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFyYW0gPT09ICctLScpIHtcbiAgICAgICAgICAgICAgIGFwcGVuZChcbiAgICAgICAgICAgICAgICAgIGRhdGEuc2xpY2UoaSArIDEpLmZsYXRNYXAoKGl0ZW0pID0+IChpc1BhdGhTcGVjKGl0ZW0pICYmIHRvUGF0aHMoaXRlbSkpIHx8IGl0ZW0pXG4gICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZWZpeC5wdXNoKHBhcmFtKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgcmV0dXJuICFzdWZmaXggPyBwcmVmaXggOiBbLi4ucHJlZml4LCAnLS0nLCAuLi5zdWZmaXgubWFwKFN0cmluZyldO1xuICAgICAgfSxcbiAgIH07XG59XG4iLCAiaW1wb3J0IHsgU2ltcGxlR2l0RmFjdG9yeSB9IGZyb20gJy4uLy4uL3R5cGluZ3MnO1xuXG5pbXBvcnQgKiBhcyBhcGkgZnJvbSAnLi9hcGknO1xuaW1wb3J0IHtcbiAgIGFib3J0UGx1Z2luLFxuICAgYmxvY2tVbnNhZmVPcGVyYXRpb25zUGx1Z2luLFxuICAgY29tbWFuZENvbmZpZ1ByZWZpeGluZ1BsdWdpbixcbiAgIGNvbXBsZXRpb25EZXRlY3Rpb25QbHVnaW4sXG4gICBlcnJvckRldGVjdGlvbkhhbmRsZXIsXG4gICBlcnJvckRldGVjdGlvblBsdWdpbixcbiAgIFBsdWdpblN0b3JlLFxuICAgcHJvZ3Jlc3NNb25pdG9yUGx1Z2luLFxuICAgc3Bhd25PcHRpb25zUGx1Z2luLFxuICAgdGltZW91dFBsdWdpbixcbn0gZnJvbSAnLi9wbHVnaW5zJztcbmltcG9ydCB7IHN1ZmZpeFBhdGhzUGx1Z2luIH0gZnJvbSAnLi9wbHVnaW5zL3N1ZmZpeC1wYXRocy5wbHVnaW4nO1xuaW1wb3J0IHsgY3JlYXRlSW5zdGFuY2VDb25maWcsIGZvbGRlckV4aXN0cyB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgU2ltcGxlR2l0T3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnO1xuXG5jb25zdCBHaXQgPSByZXF1aXJlKCcuLi9naXQnKTtcblxuLyoqXG4gKiBBZGRzIHRoZSBuZWNlc3NhcnkgcHJvcGVydGllcyB0byB0aGUgc3VwcGxpZWQgb2JqZWN0IHRvIGVuYWJsZSBpdCBmb3IgdXNlIGFzXG4gKiB0aGUgZGVmYXVsdCBleHBvcnQgb2YgYSBtb2R1bGUuXG4gKlxuICogRWc6IGBtb2R1bGUuZXhwb3J0cyA9IGVzTW9kdWxlRmFjdG9yeSh7IHNvbWV0aGluZyAoKSB7fSB9KWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVzTW9kdWxlRmFjdG9yeTxUPihkZWZhdWx0RXhwb3J0OiBUKSB7XG4gICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZGVmYXVsdEV4cG9ydCwge1xuICAgICAgX19lc01vZHVsZTogeyB2YWx1ZTogdHJ1ZSB9LFxuICAgICAgZGVmYXVsdDogeyB2YWx1ZTogZGVmYXVsdEV4cG9ydCB9LFxuICAgfSkgYXMgVCAmIHsgX19lc01vZHVsZTogdHJ1ZTsgZGVmYXVsdDogVCB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2l0RXhwb3J0RmFjdG9yeShmYWN0b3J5OiBTaW1wbGVHaXRGYWN0b3J5KSB7XG4gICByZXR1cm4gT2JqZWN0LmFzc2lnbihmYWN0b3J5LmJpbmQobnVsbCksIGFwaSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnaXRJbnN0YW5jZUZhY3RvcnkoXG4gICBiYXNlRGlyPzogc3RyaW5nIHwgUGFydGlhbDxTaW1wbGVHaXRPcHRpb25zPixcbiAgIG9wdGlvbnM/OiBQYXJ0aWFsPFNpbXBsZUdpdE9wdGlvbnM+XG4pIHtcbiAgIGNvbnN0IHBsdWdpbnMgPSBuZXcgUGx1Z2luU3RvcmUoKTtcbiAgIGNvbnN0IGNvbmZpZyA9IGNyZWF0ZUluc3RhbmNlQ29uZmlnKFxuICAgICAgKGJhc2VEaXIgJiYgKHR5cGVvZiBiYXNlRGlyID09PSAnc3RyaW5nJyA/IHsgYmFzZURpciB9IDogYmFzZURpcikpIHx8IHt9LFxuICAgICAgb3B0aW9uc1xuICAgKTtcblxuICAgaWYgKCFmb2xkZXJFeGlzdHMoY29uZmlnLmJhc2VEaXIpKSB7XG4gICAgICB0aHJvdyBuZXcgYXBpLkdpdENvbnN0cnVjdEVycm9yKFxuICAgICAgICAgY29uZmlnLFxuICAgICAgICAgYENhbm5vdCB1c2Ugc2ltcGxlLWdpdCBvbiBhIGRpcmVjdG9yeSB0aGF0IGRvZXMgbm90IGV4aXN0YFxuICAgICAgKTtcbiAgIH1cblxuICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnLmNvbmZpZykpIHtcbiAgICAgIHBsdWdpbnMuYWRkKGNvbW1hbmRDb25maWdQcmVmaXhpbmdQbHVnaW4oY29uZmlnLmNvbmZpZykpO1xuICAgfVxuXG4gICBwbHVnaW5zLmFkZChibG9ja1Vuc2FmZU9wZXJhdGlvbnNQbHVnaW4oY29uZmlnLnVuc2FmZSkpO1xuICAgcGx1Z2lucy5hZGQoc3VmZml4UGF0aHNQbHVnaW4oKSk7XG4gICBwbHVnaW5zLmFkZChjb21wbGV0aW9uRGV0ZWN0aW9uUGx1Z2luKGNvbmZpZy5jb21wbGV0aW9uKSk7XG4gICBjb25maWcuYWJvcnQgJiYgcGx1Z2lucy5hZGQoYWJvcnRQbHVnaW4oY29uZmlnLmFib3J0KSk7XG4gICBjb25maWcucHJvZ3Jlc3MgJiYgcGx1Z2lucy5hZGQocHJvZ3Jlc3NNb25pdG9yUGx1Z2luKGNvbmZpZy5wcm9ncmVzcykpO1xuICAgY29uZmlnLnRpbWVvdXQgJiYgcGx1Z2lucy5hZGQodGltZW91dFBsdWdpbihjb25maWcudGltZW91dCkpO1xuICAgY29uZmlnLnNwYXduT3B0aW9ucyAmJiBwbHVnaW5zLmFkZChzcGF3bk9wdGlvbnNQbHVnaW4oY29uZmlnLnNwYXduT3B0aW9ucykpO1xuXG4gICBwbHVnaW5zLmFkZChlcnJvckRldGVjdGlvblBsdWdpbihlcnJvckRldGVjdGlvbkhhbmRsZXIodHJ1ZSkpKTtcbiAgIGNvbmZpZy5lcnJvcnMgJiYgcGx1Z2lucy5hZGQoZXJyb3JEZXRlY3Rpb25QbHVnaW4oY29uZmlnLmVycm9ycykpO1xuXG4gICByZXR1cm4gbmV3IEdpdChjb25maWcsIHBsdWdpbnMpO1xufVxuIiwgImltcG9ydCB7IFNpbXBsZUdpdCwgU2ltcGxlR2l0T3B0aW9ucyB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuXG5pbXBvcnQgeyBHaXRSZXNwb25zZUVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL2dpdC1yZXNwb25zZS1lcnJvcic7XG5pbXBvcnQgeyBnaXRJbnN0YW5jZUZhY3RvcnkgfSBmcm9tICcuLi9naXQtZmFjdG9yeSc7XG5pbXBvcnQgeyBTaW1wbGVHaXRUYXNrQ2FsbGJhY2sgfSBmcm9tICcuLi90eXBlcyc7XG5cbmNvbnN0IGZ1bmN0aW9uTmFtZXNCdWlsZGVyQXBpID0gWydjdXN0b21CaW5hcnknLCAnZW52JywgJ291dHB1dEhhbmRsZXInLCAnc2lsZW50J107XG5cbmNvbnN0IGZ1bmN0aW9uTmFtZXNQcm9taXNlQXBpID0gW1xuICAgJ2FkZCcsXG4gICAnYWRkQW5ub3RhdGVkVGFnJyxcbiAgICdhZGRDb25maWcnLFxuICAgJ2FkZFJlbW90ZScsXG4gICAnYWRkVGFnJyxcbiAgICdhcHBseVBhdGNoJyxcbiAgICdiaW5hcnlDYXRGaWxlJyxcbiAgICdicmFuY2gnLFxuICAgJ2JyYW5jaExvY2FsJyxcbiAgICdjYXRGaWxlJyxcbiAgICdjaGVja0lnbm9yZScsXG4gICAnY2hlY2tJc1JlcG8nLFxuICAgJ2NoZWNrb3V0JyxcbiAgICdjaGVja291dEJyYW5jaCcsXG4gICAnY2hlY2tvdXRMYXRlc3RUYWcnLFxuICAgJ2NoZWNrb3V0TG9jYWxCcmFuY2gnLFxuICAgJ2NsZWFuJyxcbiAgICdjbG9uZScsXG4gICAnY29tbWl0JyxcbiAgICdjd2QnLFxuICAgJ2RlbGV0ZUxvY2FsQnJhbmNoJyxcbiAgICdkZWxldGVMb2NhbEJyYW5jaGVzJyxcbiAgICdkaWZmJyxcbiAgICdkaWZmU3VtbWFyeScsXG4gICAnZXhlYycsXG4gICAnZmV0Y2gnLFxuICAgJ2dldFJlbW90ZXMnLFxuICAgJ2luaXQnLFxuICAgJ2xpc3RDb25maWcnLFxuICAgJ2xpc3RSZW1vdGUnLFxuICAgJ2xvZycsXG4gICAnbWVyZ2UnLFxuICAgJ21lcmdlRnJvbVRvJyxcbiAgICdtaXJyb3InLFxuICAgJ212JyxcbiAgICdwdWxsJyxcbiAgICdwdXNoJyxcbiAgICdwdXNoVGFncycsXG4gICAncmF3JyxcbiAgICdyZWJhc2UnLFxuICAgJ3JlbW90ZScsXG4gICAncmVtb3ZlUmVtb3RlJyxcbiAgICdyZXNldCcsXG4gICAncmV2ZXJ0JyxcbiAgICdyZXZwYXJzZScsXG4gICAncm0nLFxuICAgJ3JtS2VlcExvY2FsJyxcbiAgICdzaG93JyxcbiAgICdzdGFzaCcsXG4gICAnc3Rhc2hMaXN0JyxcbiAgICdzdGF0dXMnLFxuICAgJ3N1Yk1vZHVsZScsXG4gICAnc3VibW9kdWxlQWRkJyxcbiAgICdzdWJtb2R1bGVJbml0JyxcbiAgICdzdWJtb2R1bGVVcGRhdGUnLFxuICAgJ3RhZycsXG4gICAndGFncycsXG4gICAndXBkYXRlU2VydmVySW5mbycsXG5dO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2l0UChcbiAgIC4uLmFyZ3M6IFtdIHwgW3N0cmluZ10gfCBbUGFydGlhbDxTaW1wbGVHaXRPcHRpb25zPl0gfCBbc3RyaW5nLCBQYXJ0aWFsPFNpbXBsZUdpdE9wdGlvbnM+XVxuKTogU2ltcGxlR2l0IHtcbiAgIGxldCBnaXQ6IGFueTtcblxuICAgbGV0IGNoYWluID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5cbiAgIHRyeSB7XG4gICAgICBnaXQgPSBnaXRJbnN0YW5jZUZhY3RvcnkoLi4uYXJncyk7XG4gICB9IGNhdGNoIChlKSB7XG4gICAgICBjaGFpbiA9IFByb21pc2UucmVqZWN0KGUpO1xuICAgfVxuXG4gICBmdW5jdGlvbiBidWlsZGVyUmV0dXJuKCkge1xuICAgICAgcmV0dXJuIHByb21pc2VBcGk7XG4gICB9XG5cbiAgIGZ1bmN0aW9uIGNoYWluUmV0dXJuKCkge1xuICAgICAgcmV0dXJuIGNoYWluO1xuICAgfVxuXG4gICBjb25zdCBwcm9taXNlQXBpID0gWy4uLmZ1bmN0aW9uTmFtZXNCdWlsZGVyQXBpLCAuLi5mdW5jdGlvbk5hbWVzUHJvbWlzZUFwaV0ucmVkdWNlKFxuICAgICAgKGFwaTogYW55LCBuYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgICAgIGNvbnN0IGlzQXN5bmMgPSBmdW5jdGlvbk5hbWVzUHJvbWlzZUFwaS5pbmNsdWRlcyhuYW1lKTtcblxuICAgICAgICAgY29uc3QgdmFsaWQgPSBpc0FzeW5jID8gYXN5bmNXcmFwcGVyKG5hbWUsIGdpdCkgOiBzeW5jV3JhcHBlcihuYW1lLCBnaXQsIGFwaSk7XG4gICAgICAgICBjb25zdCBhbHRlcm5hdGl2ZSA9IGlzQXN5bmMgPyBjaGFpblJldHVybiA6IGJ1aWxkZXJSZXR1cm47XG5cbiAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcGksIG5hbWUsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBnaXQgPyB2YWxpZCA6IGFsdGVybmF0aXZlLFxuICAgICAgICAgfSk7XG5cbiAgICAgICAgIHJldHVybiBhcGk7XG4gICAgICB9LFxuICAgICAge31cbiAgICk7XG5cbiAgIHJldHVybiBwcm9taXNlQXBpIGFzIFNpbXBsZUdpdDtcblxuICAgZnVuY3Rpb24gYXN5bmNXcmFwcGVyKGZuOiBzdHJpbmcsIGdpdDogYW55KTogKC4uLmFyZ3M6IGFueVtdKSA9PiBQcm9taXNlPGFueT4ge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzOiBhbnlbXSkge1xuICAgICAgICAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICdQcm9taXNlIGludGVyZmFjZSByZXF1aXJlcyB0aGF0IGhhbmRsZXJzIGFyZSBub3Qgc3VwcGxpZWQgaW5saW5lLCAnICtcbiAgICAgICAgICAgICAgICAgICd0cmFpbGluZyBmdW5jdGlvbiBub3QgYWxsb3dlZCBpbiBjYWxsIHRvICcgK1xuICAgICAgICAgICAgICAgICAgZm5cbiAgICAgICAgICAgICk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHJldHVybiBjaGFpbi50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICBjb25zdCBjYWxsYmFjazogU2ltcGxlR2l0VGFza0NhbGxiYWNrID0gKGVycjogRXJyb3IgfCBudWxsLCByZXN1bHQ/OiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QodG9FcnJvcihlcnIpKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgIGFyZ3MucHVzaChjYWxsYmFjayk7XG5cbiAgICAgICAgICAgICAgIGdpdFtmbl0uYXBwbHkoZ2l0LCBhcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgfVxuXG4gICBmdW5jdGlvbiBzeW5jV3JhcHBlcihmbjogc3RyaW5nLCBnaXQ6IGFueSwgYXBpOiBTaW1wbGVHaXQpIHtcbiAgICAgIHJldHVybiAoLi4uYXJnczogYW55W10pID0+IHtcbiAgICAgICAgIGdpdFtmbl0oLi4uYXJncyk7XG5cbiAgICAgICAgIHJldHVybiBhcGk7XG4gICAgICB9O1xuICAgfVxufVxuXG5mdW5jdGlvbiB0b0Vycm9yKGVycm9yOiBFcnJvciB8IHN0cmluZyB8IGFueSk6IEVycm9yIHtcbiAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICByZXR1cm4gZXJyb3I7XG4gICB9XG5cbiAgIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKGVycm9yKTtcbiAgIH1cblxuICAgcmV0dXJuIG5ldyBHaXRSZXNwb25zZUVycm9yKGVycm9yKTtcbn1cbiIsICJpbXBvcnQgeyBnaXRJbnN0YW5jZUZhY3RvcnkgfSBmcm9tICcuL2xpYi9naXQtZmFjdG9yeSc7XG5cbmV4cG9ydCB7IGdpdFAgfSBmcm9tICcuL2xpYi9ydW5uZXJzL3Byb21pc2Utd3JhcHBlZCc7XG5leHBvcnQgKiBmcm9tICcuL2xpYi9hcGknO1xuXG5leHBvcnQgY29uc3Qgc2ltcGxlR2l0ID0gZ2l0SW5zdGFuY2VGYWN0b3J5O1xuXG5leHBvcnQgZGVmYXVsdCBnaXRJbnN0YW5jZUZhY3Rvcnk7XG4iLCAiaW1wb3J0IHNpbXBsZUdpdCwge1xyXG4gIENvbW1pdFJlc3VsdCxcclxuICBHaXRSZXNwb25zZUVycm9yLFxyXG4gIFB1bGxEZXRhaWxTdW1tYXJ5LFxyXG4gIFB1bGxSZXN1bHQsXHJcbiAgUHVzaERldGFpbCxcclxuICBQdXNoUmVzdWx0LFxyXG4gIFJlc3BvbnNlLFxyXG4gIFNpbXBsZUdpdCxcclxuICBTaW1wbGVHaXRPcHRpb25zLFxyXG59IGZyb20gXCJzaW1wbGUtZ2l0XCI7XHJcblxyXG5leHBvcnQgY29uc3QgREVGQVVMVF9HSVRfT1BUSU9OUzogUGFydGlhbDxTaW1wbGVHaXRPcHRpb25zPiA9IHtcclxuICBiaW5hcnk6IFwiZ2l0XCIsXHJcbiAgdHJpbW1lZDogdHJ1ZSxcclxufTtcclxuXHJcbmV4cG9ydCBjbGFzcyBHaXQge1xyXG4gIHByaXZhdGUgX2luc3RhbmNlOiBTaW1wbGVHaXQgfCBudWxsID0gbnVsbDtcclxuICBwcml2YXRlIFJFTU9URV9OQU1FOiBcIm9yaWdpblwiID0gXCJvcmlnaW5cIjtcclxuXHJcbiAgcHJpdmF0ZSBnZXQgaW5zdGFuY2UoKTogU2ltcGxlR2l0IHtcclxuICAgIGlmICghdGhpcy5faW5zdGFuY2UpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2l0IGluc3RhbmNlIGlzIG5vdCBpbnN0YW50aWF0ZWRcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5faW5zdGFuY2U7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHNldCBpbnN0YW5jZShpbnN0OiBTaW1wbGVHaXQpIHtcclxuICAgIHRoaXMuX2luc3RhbmNlID0gaW5zdDtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYnJhbmNoOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcclxuXHJcbiAgY29uc3RydWN0b3IoYmFzZURpcjogc3RyaW5nKSB7XHJcbiAgICB0aGlzLmluc3RhbmNlID0gc2ltcGxlR2l0KHtcclxuICAgICAgLi4uREVGQVVMVF9HSVRfT1BUSU9OUyxcclxuICAgICAgYmFzZURpcixcclxuICAgIH0pLmluaXQoKTtcclxuICAgIHRoaXMuaW5zdGFuY2VcclxuICAgICAgLnN0YXR1cygpXHJcbiAgICAgIC50aGVuKChzdGF0dXMpID0+IHtcclxuICAgICAgICB0aGlzLmJyYW5jaCA9IHN0YXR1cy5jdXJyZW50O1xyXG4gICAgICB9KVxyXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGVycik7XHJcbiAgICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgZ2V0QnJhbmNoKCk6IHN0cmluZyB8IG51bGwge1xyXG4gICAgcmV0dXJuIHRoaXMuYnJhbmNoO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0UmVtb3RlKCk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xyXG4gICAgY29uc3QgcmVtb3RlcyA9IGF3YWl0IHRoaXMuaW5zdGFuY2UuZ2V0UmVtb3Rlcyh0cnVlKTtcclxuICAgIC8vIGNvbnNvbGUubG9nKFxyXG4gICAgLy8gICBhd2FpdCB0aGlzLmluc3RhbmNlLmxpc3RSZW1vdGUoW1wiLS1oZWFkc1wiLCBcIi0tdGFnc1wiXSwgY29uc29sZS5sb2cpXHJcbiAgICAvLyApO1xyXG4gICAgaWYgKHJlbW90ZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICByZXR1cm4gKFxyXG4gICAgICAgIHJlbW90ZXMuZmluZCgocmVtb3RlKSA9PiByZW1vdGUubmFtZSA9PT0gdGhpcy5SRU1PVEVfTkFNRSk/LnJlZnMucHVzaCA/P1xyXG4gICAgICAgIG51bGxcclxuICAgICAgKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYWRkUmVtb3RlKHJlcG86IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRSZW1vdGUoKVxyXG4gICAgICAudGhlbigocmVtb3RlKSA9PiB7XHJcbiAgICAgICAgaWYgKHJlbW90ZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgdGhpcy5pbnN0YW5jZS5yZW1vdmVSZW1vdGUodGhpcy5SRU1PVEVfTkFNRSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gICAgICAudGhlbigoKSA9PiB0aGlzLmluc3RhbmNlLmFkZFJlbW90ZSh0aGlzLlJFTU9URV9OQU1FLCByZXBvKSk7XHJcbiAgfVxyXG5cclxuICBhZGRBbGxBbmRDb21taXQobXNnOiBzdHJpbmcpOiBSZXNwb25zZTxDb21taXRSZXN1bHQ+IHtcclxuICAgIHJldHVybiB0aGlzLmluc3RhbmNlLmFkZChcIipcIikuY29tbWl0KG1zZyk7XHJcbiAgfVxyXG5cclxuICBhZGRBbGxBbmRDb21taXRBbmRQdXNoKG1zZzogc3RyaW5nKTogUHJvbWlzZTxQdXNoUmVzdWx0IHwgbnVsbD4ge1xyXG4gICAgcmV0dXJuIHRoaXMuYWRkQWxsQW5kQ29tbWl0KG1zZylcclxuICAgICAgLnRoZW4oKHJlczogQ29tbWl0UmVzdWx0KSA9PiB7XHJcbiAgICAgICAgaWYgKHJlcy5jb21taXQpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLnB1c2goKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gICAgICAuY2F0Y2goKGVycjogR2l0UmVzcG9uc2VFcnJvcjxQdXNoRGV0YWlsPikgPT4ge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnIubWVzc2FnZSk7XHJcbiAgICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcHVsbCgpOiBQcm9taXNlPHZvaWQgfCBQdWxsUmVzdWx0PiB7XHJcbiAgICByZXR1cm4gdGhpcy5pbnN0YW5jZVxyXG4gICAgICAucHVsbCh0aGlzLlJFTU9URV9OQU1FLCB0aGlzLmdldEJyYW5jaCgpID8/IHVuZGVmaW5lZClcclxuICAgICAgLmNhdGNoKChlcnI6IEdpdFJlc3BvbnNlRXJyb3I8UHVsbERldGFpbFN1bW1hcnk+KSA9PiB7XHJcbiAgICAgICAgaWYgKGVyci5tZXNzYWdlICE9PSBcImNvdWxkbid0IGZpbmQgcmVtb3RlIHJlZiBtYXN0ZXJcIikge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyci5tZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcHVzaCgpOiBQcm9taXNlPFB1c2hSZXN1bHQ+IHtcclxuICAgIHJldHVybiB0aGlzLmluc3RhbmNlXHJcbiAgICAgIC5wdXNoKHRoaXMuUkVNT1RFX05BTUUsIHRoaXMuZ2V0QnJhbmNoKCkgPz8gdW5kZWZpbmVkLCBbXCItLXNldC11cHN0cmVhbVwiXSlcclxuICAgICAgLmNhdGNoKChlcnI6IEdpdFJlc3BvbnNlRXJyb3I8UHVzaERldGFpbD4pID0+IHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyLm1lc3NhZ2UpO1xyXG4gICAgICB9KTtcclxuICB9XHJcblxyXG4gIHN0YXR1cygpOiB2b2lkIHtcclxuICAgIHRoaXMuaW5zdGFuY2Uuc3RhdHVzKCkudGhlbigoc3RhdHVzKSA9PiBjb25zb2xlLmxvZyhzdGF0dXMpKTtcclxuICB9XHJcbn1cclxuIiwgImltcG9ydCB7IEFwcCwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZyB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgR2l0UGx1Z2luIGZyb20gXCJzcmMvbWFpblwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFNldHRpbmdzVGFiIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XHJcbiAgcGx1Z2luOiBHaXRQbHVnaW47XHJcblxyXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IEdpdFBsdWdpbikge1xyXG4gICAgc3VwZXIoYXBwLCBwbHVnaW4pO1xyXG4gICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XHJcbiAgfVxyXG5cclxuICBkaXNwbGF5KCk6IHZvaWQge1xyXG4gICAgY29uc3QgeyBjb250YWluZXJFbCB9ID0gdGhpcztcclxuXHJcbiAgICBjb250YWluZXJFbC5lbXB0eSgpO1xyXG5cclxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAuc2V0TmFtZShcIlJlbW90ZSByZXBvc2l0b3J5IHVybFwiKVxyXG4gICAgICAuc2V0RGVzYyhcclxuICAgICAgICBcIkVudGVyIHlvdXIgcmVtb3RlIHJlcG9zaXRvcnkgdXJsIChvciBjaGFuZ2UgaXQgdG8gcHVzaCB0byBhIGRpZmZlcmVudCB1cmwpXCJcclxuICAgICAgKVxyXG4gICAgICAuYWRkVGV4dCgodGV4dCkgPT5cclxuICAgICAgICB0ZXh0XHJcbiAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoXCJSZW1vdGUgcmVwb3NpdG9yeSB1cmxcIilcclxuICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5naXRSZW1vdGUgPz8gXCJcIilcclxuICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZ2l0UmVtb3RlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wbHVnaW4uc2V0dGluZ3MuZ2l0UmVtb3RlKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uZ2l0LmFkZFJlbW90ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5naXRSZW1vdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KVxyXG4gICAgICApO1xyXG4gIH1cclxufVxyXG4iLCAiaW1wb3J0IHsgQXBwLCBGaWxlU3lzdGVtQWRhcHRlciB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldFZhdWx0UGF0aCA9IChhcHA6IEFwcCk6IHN0cmluZyA9PiB7XHJcblx0aWYgKGFwcC52YXVsdC5hZGFwdGVyIGluc3RhbmNlb2YgRmlsZVN5c3RlbUFkYXB0ZXIpIHtcclxuXHRcdHJldHVybiBhcHAudmF1bHQuYWRhcHRlci5nZXRCYXNlUGF0aCgpO1xyXG5cdH1cclxuXHR0aHJvdyBuZXcgRXJyb3IoXHJcblx0XHRcIlVuYWJsZSB0byBnZXQgdmF1bHQgYmFzZSBwYXRoIGFzIHZhdWx0IGlzIG5vdCB3aXRoaW4gYSB2YWxpZCBmaWxlIHN5c3RlbVwiXHJcblx0KTtcclxufTtcclxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUEsc0NBQUFBLFNBQUE7QUFJQSxRQUFJLElBQUk7QUFDUixRQUFJLElBQUksSUFBSTtBQUNaLFFBQUksSUFBSSxJQUFJO0FBQ1osUUFBSSxJQUFJLElBQUk7QUFDWixRQUFJLElBQUksSUFBSTtBQUNaLFFBQUksSUFBSSxJQUFJO0FBZ0JaLElBQUFBLFFBQU8sVUFBVSxTQUFTLEtBQUssU0FBUztBQUN0QyxnQkFBVSxXQUFXLENBQUM7QUFDdEIsVUFBSSxPQUFPLE9BQU87QUFDbEIsVUFBSSxTQUFTLFlBQVksSUFBSSxTQUFTLEdBQUc7QUFDdkMsZUFBTyxNQUFNLEdBQUc7QUFBQSxNQUNsQixXQUFXLFNBQVMsWUFBWSxTQUFTLEdBQUcsR0FBRztBQUM3QyxlQUFPLFFBQVEsT0FBTyxRQUFRLEdBQUcsSUFBSSxTQUFTLEdBQUc7QUFBQSxNQUNuRDtBQUNBLFlBQU0sSUFBSTtBQUFBLFFBQ1IsMERBQ0UsS0FBSyxVQUFVLEdBQUc7QUFBQSxNQUN0QjtBQUFBLElBQ0Y7QUFVQSxhQUFTLE1BQU0sS0FBSztBQUNsQixZQUFNLE9BQU8sR0FBRztBQUNoQixVQUFJLElBQUksU0FBUyxLQUFLO0FBQ3BCO0FBQUEsTUFDRjtBQUNBLFVBQUksUUFBUSxtSUFBbUk7QUFBQSxRQUM3STtBQUFBLE1BQ0Y7QUFDQSxVQUFJLENBQUMsT0FBTztBQUNWO0FBQUEsTUFDRjtBQUNBLFVBQUksSUFBSSxXQUFXLE1BQU0sQ0FBQyxDQUFDO0FBQzNCLFVBQUksUUFBUSxNQUFNLENBQUMsS0FBSyxNQUFNLFlBQVk7QUFDMUMsY0FBUSxNQUFNO0FBQUEsUUFDWixLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQ0gsaUJBQU8sSUFBSTtBQUFBLFFBQ2IsS0FBSztBQUFBLFFBQ0wsS0FBSztBQUFBLFFBQ0wsS0FBSztBQUNILGlCQUFPLElBQUk7QUFBQSxRQUNiLEtBQUs7QUFBQSxRQUNMLEtBQUs7QUFBQSxRQUNMLEtBQUs7QUFDSCxpQkFBTyxJQUFJO0FBQUEsUUFDYixLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQ0gsaUJBQU8sSUFBSTtBQUFBLFFBQ2IsS0FBSztBQUFBLFFBQ0wsS0FBSztBQUFBLFFBQ0wsS0FBSztBQUFBLFFBQ0wsS0FBSztBQUFBLFFBQ0wsS0FBSztBQUNILGlCQUFPLElBQUk7QUFBQSxRQUNiLEtBQUs7QUFBQSxRQUNMLEtBQUs7QUFBQSxRQUNMLEtBQUs7QUFBQSxRQUNMLEtBQUs7QUFBQSxRQUNMLEtBQUs7QUFDSCxpQkFBTyxJQUFJO0FBQUEsUUFDYixLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQ0gsaUJBQU87QUFBQSxRQUNUO0FBQ0UsaUJBQU87QUFBQSxNQUNYO0FBQUEsSUFDRjtBQVVBLGFBQVMsU0FBUyxJQUFJO0FBQ3BCLFVBQUksUUFBUSxLQUFLLElBQUksRUFBRTtBQUN2QixVQUFJLFNBQVMsR0FBRztBQUNkLGVBQU8sS0FBSyxNQUFNLEtBQUssQ0FBQyxJQUFJO0FBQUEsTUFDOUI7QUFDQSxVQUFJLFNBQVMsR0FBRztBQUNkLGVBQU8sS0FBSyxNQUFNLEtBQUssQ0FBQyxJQUFJO0FBQUEsTUFDOUI7QUFDQSxVQUFJLFNBQVMsR0FBRztBQUNkLGVBQU8sS0FBSyxNQUFNLEtBQUssQ0FBQyxJQUFJO0FBQUEs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LE1BQU0sZUFBZTtBQUNuQixVQUFNLEtBQUssU0FBUyxLQUFLLFFBQVE7QUFBQSxFQUNuQztBQUNGOyIsCiAgIm5hbWVzIjogWyJtb2R1bGUiLCAibW9kdWxlIiwgImRlYnVnIiwgIm1vZHVsZSIsICJwYXRoIiwgImV4aXN0cyIsICJfX2V4cG9ydCIsICJkZWZlcnJlZCIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJwYXRoIiwgImltcG9ydF9kZWJ1ZyIsICJpbXBvcnRfcHJvbWlzZV9kZWZlcnJlZCIsICJwYXRoIiwgIl9fZXhwb3J0IiwgImRlYnVnIiwgIl9fY29tbW9uSlMiLCAibW9kdWxlIiwgIl9fdG9Db21tb25KUyIsICJHaXQyIiwgIkdpdCIsICJfYSIsICJpbXBvcnRfb2JzaWRpYW4iLCAiX2EiLCAiaW1wb3J0X29ic2lkaWFuIiwgIkdpdCJdCn0K
